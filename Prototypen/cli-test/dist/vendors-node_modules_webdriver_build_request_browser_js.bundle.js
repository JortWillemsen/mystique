"use strict";
exports.id = "vendors-node_modules_webdriver_build_request_browser_js";
exports.ids = ["vendors-node_modules_webdriver_build_request_browser_js"];
exports.modules = {

/***/ "./node_modules/ky/distribution/core/Ky.js":
/*!*************************************************!*\
  !*** ./node_modules/ky/distribution/core/Ky.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ky": () => (/* binding */ Ky)
/* harmony export */ });
/* harmony import */ var _errors_HTTPError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/HTTPError.js */ "./node_modules/ky/distribution/errors/HTTPError.js");
/* harmony import */ var _errors_TimeoutError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../errors/TimeoutError.js */ "./node_modules/ky/distribution/errors/TimeoutError.js");
/* harmony import */ var _utils_merge_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/merge.js */ "./node_modules/ky/distribution/utils/merge.js");
/* harmony import */ var _utils_normalize_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/normalize.js */ "./node_modules/ky/distribution/utils/normalize.js");
/* harmony import */ var _utils_timeout_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/timeout.js */ "./node_modules/ky/distribution/utils/timeout.js");
/* harmony import */ var _utils_delay_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/delay.js */ "./node_modules/ky/distribution/utils/delay.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./node_modules/ky/distribution/core/constants.js");







class Ky {
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    static create(input, options) {
        const ky = new Ky(input, options);
        const fn = async () => {
            if (ky._options.timeout > _constants_js__WEBPACK_IMPORTED_MODULE_0__.maxSafeTimeout) {
                throw new RangeError(`The \`timeout\` option cannot be greater than ${_constants_js__WEBPACK_IMPORTED_MODULE_0__.maxSafeTimeout}`);
            }
            // Delay the fetch so that body method shortcuts can set the Accept header
            await Promise.resolve();
            let response = await ky._fetch();
            for (const hook of ky._options.hooks.afterResponse) {
                // eslint-disable-next-line no-await-in-loop
                const modifiedResponse = await hook(ky.request, ky._options, ky._decorateResponse(response.clone()));
                if (modifiedResponse instanceof globalThis.Response) {
                    response = modifiedResponse;
                }
            }
            ky._decorateResponse(response);
            if (!response.ok && ky._options.throwHttpErrors) {
                let error = new _errors_HTTPError_js__WEBPACK_IMPORTED_MODULE_1__.HTTPError(response, ky.request, ky._options);
                for (const hook of ky._options.hooks.beforeError) {
                    // eslint-disable-next-line no-await-in-loop
                    error = await hook(error);
                }
                throw error;
            }
            // If `onDownloadProgress` is passed, it uses the stream API internally
            /* istanbul ignore next */
            if (ky._options.onDownloadProgress) {
                if (typeof ky._options.onDownloadProgress !== 'function') {
                    throw new TypeError('The `onDownloadProgress` option must be a function');
                }
                if (!_constants_js__WEBPACK_IMPORTED_MODULE_0__.supportsResponseStreams) {
                    throw new Error('Streams are not supported in your environment. `ReadableStream` is missing.');
                }
                return ky._stream(response.clone(), ky._options.onDownloadProgress);
            }
            return response;
        };
        const isRetriableMethod = ky._options.retry.methods.includes(ky.request.method.toLowerCase());
        const result = (isRetriableMethod ? ky._retry(fn) : fn());
        for (const [type, mimeType] of Object.entries(_constants_js__WEBPACK_IMPORTED_MODULE_0__.responseTypes)) {
            result[type] = async () => {
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                ky.request.headers.set('accept', ky.request.headers.get('accept') || mimeType);
                const awaitedResult = await result;
                const response = awaitedResult.clone();
                if (type === 'json') {
                    if (response.status === 204) {
                        return '';
                    }
                    const arrayBuffer = await response.clone().arrayBuffer();
                    const responseSize = arrayBuffer.byteLength;
                    if (responseSize === 0) {
                        return '';
                    }
                    if (options.parseJson) {
                        return options.parseJson(await response.text());
                    }
                }
                return response[type]();
            };
        }
        return result;
    }
    // eslint-disable-next-line complexity
    constructor(input, options = {}) {
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "abortController", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_retryCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_input", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._input = input;
        this._options = {
            // TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208
            credentials: this._input.credentials || 'same-origin',
            ...options,
            headers: (0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_2__.mergeHeaders)(this._input.headers, options.headers),
            hooks: (0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_2__.deepMerge)({
                beforeRequest: [],
                beforeRetry: [],
                beforeError: [],
                afterResponse: [],
            }, options.hooks),
            method: (0,_utils_normalize_js__WEBPACK_IMPORTED_MODULE_3__.normalizeRequestMethod)(options.method ?? this._input.method),
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            prefixUrl: String(options.prefixUrl || ''),
            retry: (0,_utils_normalize_js__WEBPACK_IMPORTED_MODULE_3__.normalizeRetryOptions)(options.retry),
            throwHttpErrors: options.throwHttpErrors !== false,
            timeout: typeof options.timeout === 'undefined' ? 10000 : options.timeout,
            fetch: options.fetch ?? globalThis.fetch.bind(globalThis),
        };
        if (typeof this._input !== 'string' && !(this._input instanceof URL || this._input instanceof globalThis.Request)) {
            throw new TypeError('`input` must be a string, URL, or Request');
        }
        if (this._options.prefixUrl && typeof this._input === 'string') {
            if (this._input.startsWith('/')) {
                throw new Error('`input` must not begin with a slash when using `prefixUrl`');
            }
            if (!this._options.prefixUrl.endsWith('/')) {
                this._options.prefixUrl += '/';
            }
            this._input = this._options.prefixUrl + this._input;
        }
        if (_constants_js__WEBPACK_IMPORTED_MODULE_0__.supportsAbortController) {
            this.abortController = new globalThis.AbortController();
            if (this._options.signal) {
                const originalSignal = this._options.signal;
                this._options.signal.addEventListener('abort', () => {
                    this.abortController.abort(originalSignal.reason);
                });
            }
            this._options.signal = this.abortController.signal;
        }
        if (_constants_js__WEBPACK_IMPORTED_MODULE_0__.supportsRequestStreams) {
            // @ts-expect-error - Types are outdated.
            this._options.duplex = 'half';
        }
        this.request = new globalThis.Request(this._input, this._options);
        if (this._options.searchParams) {
            // eslint-disable-next-line unicorn/prevent-abbreviations
            const textSearchParams = typeof this._options.searchParams === 'string'
                ? this._options.searchParams.replace(/^\?/, '')
                : new URLSearchParams(this._options.searchParams).toString();
            // eslint-disable-next-line unicorn/prevent-abbreviations
            const searchParams = '?' + textSearchParams;
            const url = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, searchParams);
            // To provide correct form boundary, Content-Type header should be deleted each time when new Request instantiated from another one
            if (((_constants_js__WEBPACK_IMPORTED_MODULE_0__.supportsFormData && this._options.body instanceof globalThis.FormData)
                || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers['content-type'])) {
                this.request.headers.delete('content-type');
            }
            // The spread of `this.request` is required as otherwise it misses the `duplex` option for some reason and throws.
            this.request = new globalThis.Request(new globalThis.Request(url, { ...this.request }), this._options);
        }
        if (this._options.json !== undefined) {
            this._options.body = JSON.stringify(this._options.json);
            this.request.headers.set('content-type', this._options.headers.get('content-type') ?? 'application/json');
            this.request = new globalThis.Request(this.request, { body: this._options.body });
        }
    }
    _calculateRetryDelay(error) {
        this._retryCount++;
        if (this._retryCount < this._options.retry.limit && !(error instanceof _errors_TimeoutError_js__WEBPACK_IMPORTED_MODULE_4__.TimeoutError)) {
            if (error instanceof _errors_HTTPError_js__WEBPACK_IMPORTED_MODULE_1__.HTTPError) {
                if (!this._options.retry.statusCodes.includes(error.response.status)) {
                    return 0;
                }
                const retryAfter = error.response.headers.get('Retry-After');
                if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {
                    let after = Number(retryAfter);
                    if (Number.isNaN(after)) {
                        after = Date.parse(retryAfter) - Date.now();
                    }
                    else {
                        after *= 1000;
                    }
                    if (typeof this._options.retry.maxRetryAfter !== 'undefined' && after > this._options.retry.maxRetryAfter) {
                        return 0;
                    }
                    return after;
                }
                if (error.response.status === 413) {
                    return 0;
                }
            }
            const BACKOFF_FACTOR = 0.3;
            return Math.min(this._options.retry.backoffLimit, BACKOFF_FACTOR * (2 ** (this._retryCount - 1)) * 1000);
        }
        return 0;
    }
    _decorateResponse(response) {
        if (this._options.parseJson) {
            response.json = async () => this._options.parseJson(await response.text());
        }
        return response;
    }
    async _retry(fn) {
        try {
            return await fn();
            // eslint-disable-next-line @typescript-eslint/no-implicit-any-catch
        }
        catch (error) {
            const ms = Math.min(this._calculateRetryDelay(error), _constants_js__WEBPACK_IMPORTED_MODULE_0__.maxSafeTimeout);
            if (ms !== 0 && this._retryCount > 0) {
                await (0,_utils_delay_js__WEBPACK_IMPORTED_MODULE_5__["default"])(ms, { signal: this._options.signal });
                for (const hook of this._options.hooks.beforeRetry) {
                    // eslint-disable-next-line no-await-in-loop
                    const hookResult = await hook({
                        request: this.request,
                        options: this._options,
                        error: error,
                        retryCount: this._retryCount,
                    });
                    // If `stop` is returned from the hook, the retry process is stopped
                    if (hookResult === _constants_js__WEBPACK_IMPORTED_MODULE_0__.stop) {
                        return;
                    }
                }
                return this._retry(fn);
            }
            throw error;
        }
    }
    async _fetch() {
        for (const hook of this._options.hooks.beforeRequest) {
            // eslint-disable-next-line no-await-in-loop
            const result = await hook(this.request, this._options);
            if (result instanceof Request) {
                this.request = result;
                break;
            }
            if (result instanceof Response) {
                return result;
            }
        }
        if (this._options.timeout === false) {
            return this._options.fetch(this.request.clone());
        }
        return (0,_utils_timeout_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this.request.clone(), this.abortController, this._options);
    }
    /* istanbul ignore next */
    _stream(response, onDownloadProgress) {
        const totalBytes = Number(response.headers.get('content-length')) || 0;
        let transferredBytes = 0;
        if (response.status === 204) {
            if (onDownloadProgress) {
                onDownloadProgress({ percent: 1, totalBytes, transferredBytes }, new Uint8Array());
            }
            return new globalThis.Response(null, {
                status: response.status,
                statusText: response.statusText,
                headers: response.headers,
            });
        }
        return new globalThis.Response(new globalThis.ReadableStream({
            async start(controller) {
                const reader = response.body.getReader();
                if (onDownloadProgress) {
                    onDownloadProgress({ percent: 0, transferredBytes: 0, totalBytes }, new Uint8Array());
                }
                async function read() {
                    const { done, value } = await reader.read();
                    if (done) {
                        controller.close();
                        return;
                    }
                    if (onDownloadProgress) {
                        transferredBytes += value.byteLength;
                        const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
                        onDownloadProgress({ percent, transferredBytes, totalBytes }, value);
                    }
                    controller.enqueue(value);
                    await read();
                }
                await read();
            },
        }), {
            status: response.status,
            statusText: response.statusText,
            headers: response.headers,
        });
    }
}
//# sourceMappingURL=Ky.js.map

/***/ }),

/***/ "./node_modules/ky/distribution/core/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/ky/distribution/core/constants.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "maxSafeTimeout": () => (/* binding */ maxSafeTimeout),
/* harmony export */   "requestMethods": () => (/* binding */ requestMethods),
/* harmony export */   "responseTypes": () => (/* binding */ responseTypes),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "supportsAbortController": () => (/* binding */ supportsAbortController),
/* harmony export */   "supportsFormData": () => (/* binding */ supportsFormData),
/* harmony export */   "supportsRequestStreams": () => (/* binding */ supportsRequestStreams),
/* harmony export */   "supportsResponseStreams": () => (/* binding */ supportsResponseStreams)
/* harmony export */ });
const supportsRequestStreams = (() => {
    let duplexAccessed = false;
    let hasContentType = false;
    const supportsReadableStream = typeof globalThis.ReadableStream === 'function';
    const supportsRequest = typeof globalThis.Request === 'function';
    if (supportsReadableStream && supportsRequest) {
        hasContentType = new globalThis.Request('https://a.com', {
            body: new globalThis.ReadableStream(),
            method: 'POST',
            // @ts-expect-error - Types are outdated.
            get duplex() {
                duplexAccessed = true;
                return 'half';
            },
        }).headers.has('Content-Type');
    }
    return duplexAccessed && !hasContentType;
})();
const supportsAbortController = typeof globalThis.AbortController === 'function';
const supportsResponseStreams = typeof globalThis.ReadableStream === 'function';
const supportsFormData = typeof globalThis.FormData === 'function';
const requestMethods = ['get', 'post', 'put', 'patch', 'head', 'delete'];
const validate = () => undefined;
validate();
const responseTypes = {
    json: 'application/json',
    text: 'text/*',
    formData: 'multipart/form-data',
    arrayBuffer: '*/*',
    blob: '*/*',
};
// The maximum value of a 32bit int (see issue #117)
const maxSafeTimeout = 2147483647;
const stop = Symbol('stop');
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/ky/distribution/errors/DOMException.js":
/*!*************************************************************!*\
  !*** ./node_modules/ky/distribution/errors/DOMException.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "composeAbortError": () => (/* binding */ composeAbortError)
/* harmony export */ });
// DOMException is supported on most modern browsers and Node.js 18+.
// @see https://developer.mozilla.org/en-US/docs/Web/API/DOMException#browser_compatibility
const isDomExceptionSupported = Boolean(globalThis.DOMException);
// TODO: When targeting Node.js 18, use `signal.throwIfAborted()` (https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted)
function composeAbortError(signal) {
    /*
    NOTE: Use DomException with AbortError name as specified in MDN docs (https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort)
    > When abort() is called, the fetch() promise rejects with an Error of type DOMException, with name AbortError.
    */
    if (isDomExceptionSupported) {
        return new DOMException(signal?.reason ?? 'The operation was aborted.', 'AbortError');
    }
    // DOMException not supported. Fall back to use of error and override name.
    const error = new Error(signal?.reason ?? 'The operation was aborted.');
    error.name = 'AbortError';
    return error;
}
//# sourceMappingURL=DOMException.js.map

/***/ }),

/***/ "./node_modules/ky/distribution/errors/HTTPError.js":
/*!**********************************************************!*\
  !*** ./node_modules/ky/distribution/errors/HTTPError.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HTTPError": () => (/* binding */ HTTPError)
/* harmony export */ });
// eslint-lint-disable-next-line @typescript-eslint/naming-convention
class HTTPError extends Error {
    constructor(response, request, options) {
        const code = (response.status || response.status === 0) ? response.status : '';
        const title = response.statusText || '';
        const status = `${code} ${title}`.trim();
        const reason = status ? `status code ${status}` : 'an unknown error';
        super(`Request failed with ${reason}`);
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'HTTPError';
        this.response = response;
        this.request = request;
        this.options = options;
    }
}
//# sourceMappingURL=HTTPError.js.map

/***/ }),

/***/ "./node_modules/ky/distribution/errors/TimeoutError.js":
/*!*************************************************************!*\
  !*** ./node_modules/ky/distribution/errors/TimeoutError.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TimeoutError": () => (/* binding */ TimeoutError)
/* harmony export */ });
class TimeoutError extends Error {
    constructor(request) {
        super('Request timed out');
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'TimeoutError';
        this.request = request;
    }
}
//# sourceMappingURL=TimeoutError.js.map

/***/ }),

/***/ "./node_modules/ky/distribution/index.js":
/*!***********************************************!*\
  !*** ./node_modules/ky/distribution/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HTTPError": () => (/* reexport safe */ _errors_HTTPError_js__WEBPACK_IMPORTED_MODULE_3__.HTTPError),
/* harmony export */   "TimeoutError": () => (/* reexport safe */ _errors_TimeoutError_js__WEBPACK_IMPORTED_MODULE_4__.TimeoutError),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Ky_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Ky.js */ "./node_modules/ky/distribution/core/Ky.js");
/* harmony import */ var _core_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/constants.js */ "./node_modules/ky/distribution/core/constants.js");
/* harmony import */ var _utils_merge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/merge.js */ "./node_modules/ky/distribution/utils/merge.js");
/* harmony import */ var _errors_HTTPError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors/HTTPError.js */ "./node_modules/ky/distribution/errors/HTTPError.js");
/* harmony import */ var _errors_TimeoutError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors/TimeoutError.js */ "./node_modules/ky/distribution/errors/TimeoutError.js");
/*! MIT License © Sindre Sorhus */



const createInstance = (defaults) => {
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    const ky = (input, options) => _core_Ky_js__WEBPACK_IMPORTED_MODULE_0__.Ky.create(input, (0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_1__.validateAndMerge)(defaults, options));
    for (const method of _core_constants_js__WEBPACK_IMPORTED_MODULE_2__.requestMethods) {
        // eslint-disable-next-line @typescript-eslint/promise-function-async
        ky[method] = (input, options) => _core_Ky_js__WEBPACK_IMPORTED_MODULE_0__.Ky.create(input, (0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_1__.validateAndMerge)(defaults, options, { method }));
    }
    ky.create = (newDefaults) => createInstance((0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_1__.validateAndMerge)(newDefaults));
    ky.extend = (newDefaults) => createInstance((0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_1__.validateAndMerge)(defaults, newDefaults));
    ky.stop = _core_constants_js__WEBPACK_IMPORTED_MODULE_2__.stop;
    return ky;
};
const ky = createInstance();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ky);


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/ky/distribution/utils/delay.js":
/*!*****************************************************!*\
  !*** ./node_modules/ky/distribution/utils/delay.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ delay)
/* harmony export */ });
/* harmony import */ var _errors_DOMException_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors/DOMException.js */ "./node_modules/ky/distribution/errors/DOMException.js");
// https://github.com/sindresorhus/delay/tree/ab98ae8dfcb38e1593286c94d934e70d14a4e111

async function delay(ms, { signal }) {
    return new Promise((resolve, reject) => {
        if (signal) {
            if (signal.aborted) {
                reject((0,_errors_DOMException_js__WEBPACK_IMPORTED_MODULE_0__.composeAbortError)(signal));
                return;
            }
            signal.addEventListener('abort', handleAbort, { once: true });
        }
        function handleAbort() {
            reject((0,_errors_DOMException_js__WEBPACK_IMPORTED_MODULE_0__.composeAbortError)(signal));
            clearTimeout(timeoutId);
        }
        const timeoutId = setTimeout(() => {
            signal?.removeEventListener('abort', handleAbort);
            resolve();
        }, ms);
    });
}
//# sourceMappingURL=delay.js.map

/***/ }),

/***/ "./node_modules/ky/distribution/utils/is.js":
/*!**************************************************!*\
  !*** ./node_modules/ky/distribution/utils/is.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isObject": () => (/* binding */ isObject)
/* harmony export */ });
// eslint-disable-next-line @typescript-eslint/ban-types
const isObject = (value) => value !== null && typeof value === 'object';
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "./node_modules/ky/distribution/utils/merge.js":
/*!*****************************************************!*\
  !*** ./node_modules/ky/distribution/utils/merge.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deepMerge": () => (/* binding */ deepMerge),
/* harmony export */   "mergeHeaders": () => (/* binding */ mergeHeaders),
/* harmony export */   "validateAndMerge": () => (/* binding */ validateAndMerge)
/* harmony export */ });
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ "./node_modules/ky/distribution/utils/is.js");

const validateAndMerge = (...sources) => {
    for (const source of sources) {
        if ((!(0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(source) || Array.isArray(source)) && typeof source !== 'undefined') {
            throw new TypeError('The `options` argument must be an object');
        }
    }
    return deepMerge({}, ...sources);
};
const mergeHeaders = (source1 = {}, source2 = {}) => {
    const result = new globalThis.Headers(source1);
    const isHeadersInstance = source2 instanceof globalThis.Headers;
    const source = new globalThis.Headers(source2);
    for (const [key, value] of source.entries()) {
        if ((isHeadersInstance && value === 'undefined') || value === undefined) {
            result.delete(key);
        }
        else {
            result.set(key, value);
        }
    }
    return result;
};
// TODO: Make this strongly-typed (no `any`).
const deepMerge = (...sources) => {
    let returnValue = {};
    let headers = {};
    for (const source of sources) {
        if (Array.isArray(source)) {
            if (!Array.isArray(returnValue)) {
                returnValue = [];
            }
            returnValue = [...returnValue, ...source];
        }
        else if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(source)) {
            for (let [key, value] of Object.entries(source)) {
                if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && key in returnValue) {
                    value = deepMerge(returnValue[key], value);
                }
                returnValue = { ...returnValue, [key]: value };
            }
            if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(source.headers)) {
                headers = mergeHeaders(headers, source.headers);
                returnValue.headers = headers;
            }
        }
    }
    return returnValue;
};
//# sourceMappingURL=merge.js.map

/***/ }),

/***/ "./node_modules/ky/distribution/utils/normalize.js":
/*!*********************************************************!*\
  !*** ./node_modules/ky/distribution/utils/normalize.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normalizeRequestMethod": () => (/* binding */ normalizeRequestMethod),
/* harmony export */   "normalizeRetryOptions": () => (/* binding */ normalizeRetryOptions)
/* harmony export */ });
/* harmony import */ var _core_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/constants.js */ "./node_modules/ky/distribution/core/constants.js");

const normalizeRequestMethod = (input) => _core_constants_js__WEBPACK_IMPORTED_MODULE_0__.requestMethods.includes(input) ? input.toUpperCase() : input;
const retryMethods = ['get', 'put', 'head', 'delete', 'options', 'trace'];
const retryStatusCodes = [408, 413, 429, 500, 502, 503, 504];
const retryAfterStatusCodes = [413, 429, 503];
const defaultRetryOptions = {
    limit: 2,
    methods: retryMethods,
    statusCodes: retryStatusCodes,
    afterStatusCodes: retryAfterStatusCodes,
    maxRetryAfter: Number.POSITIVE_INFINITY,
    backoffLimit: Number.POSITIVE_INFINITY,
};
const normalizeRetryOptions = (retry = {}) => {
    if (typeof retry === 'number') {
        return {
            ...defaultRetryOptions,
            limit: retry,
        };
    }
    if (retry.methods && !Array.isArray(retry.methods)) {
        throw new Error('retry.methods must be an array');
    }
    if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {
        throw new Error('retry.statusCodes must be an array');
    }
    return {
        ...defaultRetryOptions,
        ...retry,
        afterStatusCodes: retryAfterStatusCodes,
    };
};
//# sourceMappingURL=normalize.js.map

/***/ }),

/***/ "./node_modules/ky/distribution/utils/timeout.js":
/*!*******************************************************!*\
  !*** ./node_modules/ky/distribution/utils/timeout.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ timeout)
/* harmony export */ });
/* harmony import */ var _errors_TimeoutError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors/TimeoutError.js */ "./node_modules/ky/distribution/errors/TimeoutError.js");

// `Promise.race()` workaround (#91)
async function timeout(request, abortController, options) {
    return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
            if (abortController) {
                abortController.abort();
            }
            reject(new _errors_TimeoutError_js__WEBPACK_IMPORTED_MODULE_0__.TimeoutError(request));
        }, options.timeout);
        void options
            .fetch(request)
            .then(resolve)
            .catch(reject)
            .then(() => {
            clearTimeout(timeoutId);
        });
    });
}
//# sourceMappingURL=timeout.js.map

/***/ }),

/***/ "./node_modules/webdriver/build/request/browser.js":
/*!*********************************************************!*\
  !*** ./node_modules/webdriver/build/request/browser.js ***!
  \*********************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BrowserRequest)
/* harmony export */ });
/* harmony import */ var ky__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ky */ "./node_modules/ky/distribution/index.js");
/* harmony import */ var _wdio_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wdio/logger */ "./node_modules/@wdio/logger/build/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/webdriver/build/request/index.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_wdio_logger__WEBPACK_IMPORTED_MODULE_0__, _index_js__WEBPACK_IMPORTED_MODULE_1__]);
([_wdio_logger__WEBPACK_IMPORTED_MODULE_0__, _index_js__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);



const log = (0,_wdio_logger__WEBPACK_IMPORTED_MODULE_0__["default"])('webdriver');
const UNSUPPORTED_OPTS = [
    'agent',
    'responseType',
    'searchParams',
];
class BrowserRequest extends _index_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(method, endpoint, body, isHubCommand = false) {
        super(method, endpoint, body, isHubCommand);
    }
    async _createOptions(options, sessionId) {
        return super._createOptions(options, sessionId, true);
    }
    async _libRequest(url, options) {
        const kyOptions = {};
        for (const opt of Object.keys(options)) {
            if (typeof options[opt] !== 'undefined' &&
                UNSUPPORTED_OPTS.includes(opt) &&
                options[opt] !== this.defaultOptions[opt]) {
                log.info(`Browser-based webdriver does not support the '${String(opt)}' option; behavior may be unexpected`);
                continue;
            }
            // @ts-expect-error
            kyOptions[opt] = options[opt];
        }
        if (options.username && options.password) {
            const encodedAuth = Buffer.from(`${options.username}:${options.password}`, 'utf8').toString('base64');
            kyOptions.headers = {
                ...kyOptions.headers,
                Authorization: `Basic ${encodedAuth}`
            };
        }
        const res = await (0,ky__WEBPACK_IMPORTED_MODULE_2__["default"])(url, kyOptions);
        return {
            statusCode: res.status,
            body: await res.json(),
        };
    }
    _libPerformanceNow() {
        return performance.now();
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/webdriver/build/request/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/webdriver/build/request/index.js ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RequestLibError": () => (/* binding */ RequestLibError),
/* harmony export */   "default": () => (/* binding */ WebDriverRequest)
/* harmony export */ });
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ "node:path");
/* harmony import */ var node_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:events */ "node:events");
/* harmony import */ var node_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:module */ "node:module");
/* harmony import */ var _wdio_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @wdio/logger */ "./node_modules/@wdio/logger/build/index.js");
/* harmony import */ var _wdio_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wdio/utils */ "./node_modules/@wdio/utils/build/index.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./factory.js */ "./node_modules/webdriver/build/request/factory.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/webdriver/build/utils.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_wdio_logger__WEBPACK_IMPORTED_MODULE_3__, _wdio_utils__WEBPACK_IMPORTED_MODULE_4__, _utils_js__WEBPACK_IMPORTED_MODULE_6__]);
([_wdio_logger__WEBPACK_IMPORTED_MODULE_3__, _wdio_utils__WEBPACK_IMPORTED_MODULE_4__, _utils_js__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);







const require = (0,node_module__WEBPACK_IMPORTED_MODULE_2__.createRequire)("file:///C:/Users/jortw/Documents/Development/23feb-JortW/cli-test/node_modules/webdriver/build/request/index.js");
const pkg = require('../../package.json');
class RequestLibError extends Error {
    statusCode;
    body;
    code;
}
const DEFAULT_HEADERS = {
    'Content-Type': 'application/json; charset=utf-8',
    'Connection': 'keep-alive',
    'Accept': 'application/json',
    'User-Agent': 'webdriver/' + pkg.version
};
const log = (0,_wdio_logger__WEBPACK_IMPORTED_MODULE_3__["default"])('webdriver');
class WebDriverRequest extends node_events__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {
    body;
    method;
    endpoint;
    isHubCommand;
    requiresSessionId;
    defaultAgents;
    defaultOptions = {
        followRedirect: true,
        responseType: 'json',
        throwHttpErrors: false
    };
    constructor(method, endpoint, body, isHubCommand = false) {
        super();
        this.body = body;
        this.method = method;
        this.endpoint = endpoint;
        this.isHubCommand = isHubCommand;
        this.requiresSessionId = Boolean(this.endpoint.match(/:sessionId/));
    }
    async makeRequest(options, sessionId) {
        let fullRequestOptions = Object.assign({ method: this.method }, this.defaultOptions, await this._createOptions(options, sessionId));
        if (typeof options.transformRequest === 'function') {
            fullRequestOptions = options.transformRequest(fullRequestOptions);
        }
        this.emit('request', fullRequestOptions);
        return this._request(fullRequestOptions, options.transformResponse, options.connectionRetryCount, 0);
    }
    async _createOptions(options, sessionId, isBrowser = false) {
        const agent = isBrowser ? undefined : (options.agent || this.defaultAgents);
        const searchParams = isBrowser ?
            undefined :
            (typeof options.queryParams === 'object' ? options.queryParams : {});
        const requestOptions = {
            https: {},
            agent,
            headers: {
                ...DEFAULT_HEADERS,
                ...(typeof options.headers === 'object' ? options.headers : {})
            },
            searchParams,
            retry: { limit: options.connectionRetryCount },
            timeout: { response: options.connectionRetryTimeout }
        };
        /**
         * only apply body property if existing
         */
        if (this.body && (Object.keys(this.body).length || this.method === 'POST')) {
            const contentLength = Buffer.byteLength(JSON.stringify(this.body), 'utf8');
            requestOptions.json = this.body;
            requestOptions.headers['Content-Length'] = `${contentLength}`;
        }
        /**
         * if we don't have a session id we set it here, unless we call commands that don't require session ids, for
         * example /sessions. The call to /sessions is not connected to a session itself and it therefore doesn't
         * require it
         */
        let endpoint = this.endpoint;
        if (this.requiresSessionId) {
            if (!sessionId) {
                throw new Error('A sessionId is required for this command');
            }
            endpoint = endpoint.replace(':sessionId', sessionId);
        }
        requestOptions.url = await _factory_js__WEBPACK_IMPORTED_MODULE_5__.URLFactory.getInstance(`${options.protocol}://` +
            `${options.hostname}:${options.port}` +
            (this.isHubCommand ? this.endpoint : node_path__WEBPACK_IMPORTED_MODULE_0__.join(options.path || '', endpoint)));
        /**
         * send authentication credentials only when creating new session
         */
        if (this.endpoint === '/session' && options.user && options.key) {
            requestOptions.username = options.user;
            requestOptions.password = options.key;
        }
        /**
         * if the environment variable "STRICT_SSL" is defined as "false", it doesn't require SSL certificates to be valid.
         * Or the requestOptions has strictSSL for an environment which cannot get the environment variable correctly like on an Electron app.
         */
        requestOptions.https.rejectUnauthorized = !(options.strictSSL === false ||
            process.env.STRICT_SSL === 'false' ||
            process.env.strict_ssl === 'false');
        return requestOptions;
    }
    async _libRequest(url, options) {
        throw new Error('This function must be implemented');
    }
    _libPerformanceNow() {
        throw new Error('This function must be implemented');
    }
    async _request(fullRequestOptions, transformResponse, totalRetryCount = 0, retryCount = 0) {
        log.info(`[${fullRequestOptions.method}] ${fullRequestOptions.url.href}`);
        if (fullRequestOptions.json && Object.keys(fullRequestOptions.json).length) {
            log.info('DATA', (0,_wdio_utils__WEBPACK_IMPORTED_MODULE_4__.transformCommandLogResult)(fullRequestOptions.json));
        }
        const { url, ...requestLibOptions } = fullRequestOptions;
        const startTime = this._libPerformanceNow();
        let response = await this._libRequest(url, requestLibOptions)
            .catch((err) => err);
        const durationMillisecond = this._libPerformanceNow() - startTime;
        /**
         * handle retries for requests
         * @param {Error} error  error object that causes the retry
         * @param {String} msg   message that is being shown as warning to user
         */
        const retry = (error, msg) => {
            /**
             * stop retrying if totalRetryCount was exceeded or there is no reason to
             * retry, e.g. if sessionId is invalid
             */
            if (retryCount >= totalRetryCount || error.message.includes('invalid session id')) {
                log.error(`Request failed with status ${response.statusCode} due to ${error}`);
                this.emit('response', { error });
                this.emit('performance', { request: fullRequestOptions, durationMillisecond, success: false, error, retryCount });
                throw error;
            }
            ++retryCount;
            this.emit('retry', { error, retryCount });
            this.emit('performance', { request: fullRequestOptions, durationMillisecond, success: false, error, retryCount });
            log.warn(msg);
            log.info(`Retrying ${retryCount}/${totalRetryCount}`);
            return this._request(fullRequestOptions, transformResponse, totalRetryCount, retryCount);
        };
        /**
         * handle request errors
         */
        if (response instanceof Error) {
            /**
             * handle timeouts
             */
            if (response.code === 'ETIMEDOUT') {
                const error = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getTimeoutError)(response, fullRequestOptions);
                return retry(error, 'Request timed out! Consider increasing the "connectionRetryTimeout" option.');
            }
            /**
             * throw if request error is unknown
             */
            this.emit('performance', { request: fullRequestOptions, durationMillisecond, success: false, error: response, retryCount });
            throw response;
        }
        if (typeof transformResponse === 'function') {
            response = transformResponse(response, fullRequestOptions);
        }
        const error = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getErrorFromResponseBody)(response.body, fullRequestOptions.json);
        /**
         * retry connection refused errors
         */
        if (error.message === 'java.net.ConnectException: Connection refused: connect') {
            return retry(error, 'Connection to Selenium Standalone server was refused.');
        }
        /**
         * hub commands don't follow standard response formats
         * and can have empty bodies
         */
        if (this.isHubCommand) {
            /**
             * if body contains HTML the command was called on a node
             * directly without using a hub, therefore throw
             */
            if (typeof response.body === 'string' && response.body.startsWith('<!DOCTYPE html>')) {
                this.emit('performance', { request: fullRequestOptions, durationMillisecond, success: false, error, retryCount });
                return Promise.reject(new Error('Command can only be called to a Selenium Hub'));
            }
            return { value: response.body || null };
        }
        /**
         * Resolve only if successful response
         */
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.isSuccessfulResponse)(response.statusCode, response.body)) {
            this.emit('response', { result: response.body });
            this.emit('performance', { request: fullRequestOptions, durationMillisecond, success: true, retryCount });
            return response.body;
        }
        /**
         *  stop retrying as this will never be successful.
         *  we will handle this at the elementErrorHandler
         */
        if (error.name === 'stale element reference') {
            log.warn('Request encountered a stale element - terminating request');
            this.emit('response', { error });
            this.emit('performance', { request: fullRequestOptions, durationMillisecond, success: false, error, retryCount });
            throw error;
        }
        return retry(error, `Request failed with status ${response.statusCode} due to ${error.message}`);
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ })

};
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfd2ViZHJpdmVyX2J1aWxkX3JlcXVlc3RfYnJvd3Nlcl9qcy5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtRDtBQUNNO0FBQ0c7QUFDMEI7QUFDNUM7QUFDSjtBQUM0SDtBQUMzSjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlEQUFjO0FBQ3BELHNGQUFzRix5REFBYyxDQUFDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJEQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrRUFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3REFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQVk7QUFDakMsbUJBQW1CLDBEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG9CQUFvQiwyRUFBc0I7QUFDMUM7QUFDQTtBQUNBLG1CQUFtQiwwRUFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUVBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsMEJBQTBCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGlFQUFZO0FBQzNGLGlDQUFpQywyREFBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHlEQUFjO0FBQ2hGO0FBQ0Esc0JBQXNCLDJEQUFLLE9BQU8sOEJBQThCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsdUNBQXVDLCtDQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZEQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBDQUEwQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNkNBQTZDO0FBQ3RGO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1Q0FBdUM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDelNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7Ozs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLEVBQUUsTUFBTTtBQUN4QywrQ0FBK0MsT0FBTztBQUN0RCxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNoQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNrQztBQUN5QjtBQUNQO0FBQ3BEO0FBQ0E7QUFDQSxtQ0FBbUMsa0RBQVMsUUFBUSxpRUFBZ0I7QUFDcEUseUJBQXlCLDhEQUFjO0FBQ3ZDO0FBQ0EseUNBQXlDLGtEQUFTLFFBQVEsaUVBQWdCLHNCQUFzQixRQUFRO0FBQ3hHO0FBQ0EsZ0RBQWdELGlFQUFnQjtBQUNoRSxnREFBZ0QsaUVBQWdCO0FBQ2hFLGNBQWMsb0RBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsRUFBRSxFQUFDO0FBQ2dDO0FBQ007QUFDeEQ7Ozs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUM4RDtBQUMvQywyQkFBMkIsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMEVBQWlCO0FBQ3hDO0FBQ0E7QUFDQSw0REFBNEQsWUFBWTtBQUN4RTtBQUNBO0FBQ0EsbUJBQW1CLDBFQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUNPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRm1DO0FBQzVCO0FBQ1A7QUFDQSxjQUFjLGdEQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNPLGtDQUFrQyxjQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnREFBUTtBQUN6QjtBQUNBLG9CQUFvQixnREFBUTtBQUM1QjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsZ0JBQWdCLGdEQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRHNEO0FBQy9DLDBDQUEwQyx1RUFBdUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDaEN5RDtBQUN6RDtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpRUFBWTtBQUNuQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25Cb0I7QUFDYztBQUNRO0FBQzFDLFlBQVksd0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLDZCQUE2QixpREFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFlBQVksVUFBVTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQ3BGO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVDNkI7QUFDYztBQUNDO0FBQ1Y7QUFDc0I7QUFDZDtBQUNvRDtBQUM5RixnQkFBZ0IsMERBQWEsQ0FBQyxpSEFBZTtBQUM3QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQU07QUFDSCwrQkFBK0IscURBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxxQkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFLGFBQWE7QUFDYjtBQUNBLHFCQUFxQixxQ0FBcUM7QUFDMUQsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0RBQXNCLElBQUksaUJBQWlCO0FBQzlFLGVBQWUsaUJBQWlCLEdBQUcsYUFBYTtBQUNoRCxpREFBaUQsMkNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEIsSUFBSSw0QkFBNEI7QUFDL0U7QUFDQSw2QkFBNkIsc0VBQXlCO0FBQ3REO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxxQkFBcUIsU0FBUyxNQUFNO0FBQzVGLHdDQUF3QyxPQUFPO0FBQy9DLDJDQUEyQyxxRkFBcUY7QUFDaEk7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1CQUFtQjtBQUNwRCx1Q0FBdUMscUZBQXFGO0FBQzVIO0FBQ0EsaUNBQWlDLFdBQVcsR0FBRyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMERBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrRkFBK0Y7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtRUFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUZBQXFGO0FBQ2hJO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFvQjtBQUNoQyxvQ0FBb0MsdUJBQXVCO0FBQzNELHVDQUF1Qyw2RUFBNkU7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDLHVDQUF1QyxxRkFBcUY7QUFDNUg7QUFDQTtBQUNBLDBEQUEwRCxxQkFBcUIsU0FBUyxjQUFjO0FBQ3RHO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMva3kvZGlzdHJpYnV0aW9uL2NvcmUvS3kuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2t5L2Rpc3RyaWJ1dGlvbi9jb3JlL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMva3kvZGlzdHJpYnV0aW9uL2Vycm9ycy9ET01FeGNlcHRpb24uanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2t5L2Rpc3RyaWJ1dGlvbi9lcnJvcnMvSFRUUEVycm9yLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9reS9kaXN0cmlidXRpb24vZXJyb3JzL1RpbWVvdXRFcnJvci5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMva3kvZGlzdHJpYnV0aW9uL2luZGV4LmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9reS9kaXN0cmlidXRpb24vdXRpbHMvZGVsYXkuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2t5L2Rpc3RyaWJ1dGlvbi91dGlscy9pcy5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMva3kvZGlzdHJpYnV0aW9uL3V0aWxzL21lcmdlLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9reS9kaXN0cmlidXRpb24vdXRpbHMvbm9ybWFsaXplLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9reS9kaXN0cmlidXRpb24vdXRpbHMvdGltZW91dC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvd2ViZHJpdmVyL2J1aWxkL3JlcXVlc3QvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvd2ViZHJpdmVyL2J1aWxkL3JlcXVlc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSFRUUEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL0hUVFBFcnJvci5qcyc7XG5pbXBvcnQgeyBUaW1lb3V0RXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvVGltZW91dEVycm9yLmpzJztcbmltcG9ydCB7IGRlZXBNZXJnZSwgbWVyZ2VIZWFkZXJzIH0gZnJvbSAnLi4vdXRpbHMvbWVyZ2UuanMnO1xuaW1wb3J0IHsgbm9ybWFsaXplUmVxdWVzdE1ldGhvZCwgbm9ybWFsaXplUmV0cnlPcHRpb25zIH0gZnJvbSAnLi4vdXRpbHMvbm9ybWFsaXplLmpzJztcbmltcG9ydCB0aW1lb3V0IGZyb20gJy4uL3V0aWxzL3RpbWVvdXQuanMnO1xuaW1wb3J0IGRlbGF5IGZyb20gJy4uL3V0aWxzL2RlbGF5LmpzJztcbmltcG9ydCB7IG1heFNhZmVUaW1lb3V0LCByZXNwb25zZVR5cGVzLCBzdG9wLCBzdXBwb3J0c0Fib3J0Q29udHJvbGxlciwgc3VwcG9ydHNGb3JtRGF0YSwgc3VwcG9ydHNSZXNwb25zZVN0cmVhbXMsIHN1cHBvcnRzUmVxdWVzdFN0cmVhbXMsIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuZXhwb3J0IGNsYXNzIEt5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmNcbiAgICBzdGF0aWMgY3JlYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGt5ID0gbmV3IEt5KGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZm4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoa3kuX29wdGlvbnMudGltZW91dCA+IG1heFNhZmVUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZSBcXGB0aW1lb3V0XFxgIG9wdGlvbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuICR7bWF4U2FmZVRpbWVvdXR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWxheSB0aGUgZmV0Y2ggc28gdGhhdCBib2R5IG1ldGhvZCBzaG9ydGN1dHMgY2FuIHNldCB0aGUgQWNjZXB0IGhlYWRlclxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBreS5fZmV0Y2goKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaG9vayBvZiBreS5fb3B0aW9ucy5ob29rcy5hZnRlclJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZFJlc3BvbnNlID0gYXdhaXQgaG9vayhreS5yZXF1ZXN0LCBreS5fb3B0aW9ucywga3kuX2RlY29yYXRlUmVzcG9uc2UocmVzcG9uc2UuY2xvbmUoKSkpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZFJlc3BvbnNlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IG1vZGlmaWVkUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAga3kuX2RlY29yYXRlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vayAmJiBreS5fb3B0aW9ucy50aHJvd0h0dHBFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgSFRUUEVycm9yKHJlc3BvbnNlLCBreS5yZXF1ZXN0LCBreS5fb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBob29rIG9mIGt5Ll9vcHRpb25zLmhvb2tzLmJlZm9yZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gYXdhaXQgaG9vayhlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYG9uRG93bmxvYWRQcm9ncmVzc2AgaXMgcGFzc2VkLCBpdCB1c2VzIHRoZSBzdHJlYW0gQVBJIGludGVybmFsbHlcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoa3kuX29wdGlvbnMub25Eb3dubG9hZFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBreS5fb3B0aW9ucy5vbkRvd25sb2FkUHJvZ3Jlc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGBvbkRvd25sb2FkUHJvZ3Jlc3NgIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBlbnZpcm9ubWVudC4gYFJlYWRhYmxlU3RyZWFtYCBpcyBtaXNzaW5nLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga3kuX3N0cmVhbShyZXNwb25zZS5jbG9uZSgpLCBreS5fb3B0aW9ucy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpc1JldHJpYWJsZU1ldGhvZCA9IGt5Ll9vcHRpb25zLnJldHJ5Lm1ldGhvZHMuaW5jbHVkZXMoa3kucmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChpc1JldHJpYWJsZU1ldGhvZCA/IGt5Ll9yZXRyeShmbikgOiBmbigpKTtcbiAgICAgICAgZm9yIChjb25zdCBbdHlwZSwgbWltZVR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3BvbnNlVHlwZXMpKSB7XG4gICAgICAgICAgICByZXN1bHRbdHlwZV0gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICAgICAgICAgICAga3kucmVxdWVzdC5oZWFkZXJzLnNldCgnYWNjZXB0Jywga3kucmVxdWVzdC5oZWFkZXJzLmdldCgnYWNjZXB0JykgfHwgbWltZVR5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF3YWl0ZWRSZXN1bHQgPSBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdGVkUmVzdWx0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdqc29uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmNsb25lKCkuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VTaXplID0gYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlSnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucGFyc2VKc29uKGF3YWl0IHJlc3BvbnNlLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlW3R5cGVdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgY29uc3RydWN0b3IoaW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXF1ZXN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFib3J0Q29udHJvbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcmV0cnlDb3VudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2lucHV0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vcHRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBjcmVkZW50aWFscyBjYW4gYmUgcmVtb3ZlZCB3aGVuIHRoZSBzcGVjIGNoYW5nZSBpcyBpbXBsZW1lbnRlZCBpbiBhbGwgYnJvd3NlcnMuIENvbnRleHQ6IGh0dHBzOi8vd3d3LmNocm9tZXN0YXR1cy5jb20vZmVhdHVyZS80NTM5NDczMzEyMzUwMjA4XG4gICAgICAgICAgICBjcmVkZW50aWFsczogdGhpcy5faW5wdXQuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiBtZXJnZUhlYWRlcnModGhpcy5faW5wdXQuaGVhZGVycywgb3B0aW9ucy5oZWFkZXJzKSxcbiAgICAgICAgICAgIGhvb2tzOiBkZWVwTWVyZ2Uoe1xuICAgICAgICAgICAgICAgIGJlZm9yZVJlcXVlc3Q6IFtdLFxuICAgICAgICAgICAgICAgIGJlZm9yZVJldHJ5OiBbXSxcbiAgICAgICAgICAgICAgICBiZWZvcmVFcnJvcjogW10sXG4gICAgICAgICAgICAgICAgYWZ0ZXJSZXNwb25zZTogW10sXG4gICAgICAgICAgICB9LCBvcHRpb25zLmhvb2tzKSxcbiAgICAgICAgICAgIG1ldGhvZDogbm9ybWFsaXplUmVxdWVzdE1ldGhvZChvcHRpb25zLm1ldGhvZCA/PyB0aGlzLl9pbnB1dC5tZXRob2QpLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICAgICAgICBwcmVmaXhVcmw6IFN0cmluZyhvcHRpb25zLnByZWZpeFVybCB8fCAnJyksXG4gICAgICAgICAgICByZXRyeTogbm9ybWFsaXplUmV0cnlPcHRpb25zKG9wdGlvbnMucmV0cnkpLFxuICAgICAgICAgICAgdGhyb3dIdHRwRXJyb3JzOiBvcHRpb25zLnRocm93SHR0cEVycm9ycyAhPT0gZmFsc2UsXG4gICAgICAgICAgICB0aW1lb3V0OiB0eXBlb2Ygb3B0aW9ucy50aW1lb3V0ID09PSAndW5kZWZpbmVkJyA/IDEwMDAwIDogb3B0aW9ucy50aW1lb3V0LFxuICAgICAgICAgICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2ggPz8gZ2xvYmFsVGhpcy5mZXRjaC5iaW5kKGdsb2JhbFRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2lucHV0ICE9PSAnc3RyaW5nJyAmJiAhKHRoaXMuX2lucHV0IGluc3RhbmNlb2YgVVJMIHx8IHRoaXMuX2lucHV0IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5SZXF1ZXN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGlucHV0YCBtdXN0IGJlIGEgc3RyaW5nLCBVUkwsIG9yIFJlcXVlc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5wcmVmaXhVcmwgJiYgdHlwZW9mIHRoaXMuX2lucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0LnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYGlucHV0YCBtdXN0IG5vdCBiZWdpbiB3aXRoIGEgc2xhc2ggd2hlbiB1c2luZyBgcHJlZml4VXJsYCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLnByZWZpeFVybC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5wcmVmaXhVcmwgKz0gJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9vcHRpb25zLnByZWZpeFVybCArIHRoaXMuX2lucHV0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdXBwb3J0c0Fib3J0Q29udHJvbGxlcikge1xuICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2lnbmFsID0gdGhpcy5fb3B0aW9ucy5zaWduYWw7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KG9yaWdpbmFsU2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLnNpZ25hbCA9IHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VwcG9ydHNSZXF1ZXN0U3RyZWFtcykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIFR5cGVzIGFyZSBvdXRkYXRlZC5cbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuZHVwbGV4ID0gJ2hhbGYnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IG5ldyBnbG9iYWxUaGlzLlJlcXVlc3QodGhpcy5faW5wdXQsIHRoaXMuX29wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5zZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZXZlbnQtYWJicmV2aWF0aW9uc1xuICAgICAgICAgICAgY29uc3QgdGV4dFNlYXJjaFBhcmFtcyA9IHR5cGVvZiB0aGlzLl9vcHRpb25zLnNlYXJjaFBhcmFtcyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuc2VhcmNoUGFyYW1zLnJlcGxhY2UoL15cXD8vLCAnJylcbiAgICAgICAgICAgICAgICA6IG5ldyBVUkxTZWFyY2hQYXJhbXModGhpcy5fb3B0aW9ucy5zZWFyY2hQYXJhbXMpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmV2ZW50LWFiYnJldmlhdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9ICc/JyArIHRleHRTZWFyY2hQYXJhbXM7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB0aGlzLnJlcXVlc3QudXJsLnJlcGxhY2UoLyg/OlxcPy4qPyk/KD89I3wkKS8sIHNlYXJjaFBhcmFtcyk7XG4gICAgICAgICAgICAvLyBUbyBwcm92aWRlIGNvcnJlY3QgZm9ybSBib3VuZGFyeSwgQ29udGVudC1UeXBlIGhlYWRlciBzaG91bGQgYmUgZGVsZXRlZCBlYWNoIHRpbWUgd2hlbiBuZXcgUmVxdWVzdCBpbnN0YW50aWF0ZWQgZnJvbSBhbm90aGVyIG9uZVxuICAgICAgICAgICAgaWYgKCgoc3VwcG9ydHNGb3JtRGF0YSAmJiB0aGlzLl9vcHRpb25zLmJvZHkgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkZvcm1EYXRhKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX29wdGlvbnMuYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykgJiYgISh0aGlzLl9vcHRpb25zLmhlYWRlcnMgJiYgdGhpcy5fb3B0aW9ucy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3QuaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIHNwcmVhZCBvZiBgdGhpcy5yZXF1ZXN0YCBpcyByZXF1aXJlZCBhcyBvdGhlcndpc2UgaXQgbWlzc2VzIHRoZSBgZHVwbGV4YCBvcHRpb24gZm9yIHNvbWUgcmVhc29uIGFuZCB0aHJvd3MuXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QgPSBuZXcgZ2xvYmFsVGhpcy5SZXF1ZXN0KG5ldyBnbG9iYWxUaGlzLlJlcXVlc3QodXJsLCB7IC4uLnRoaXMucmVxdWVzdCB9KSwgdGhpcy5fb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuanNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeSh0aGlzLl9vcHRpb25zLmpzb24pO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9vcHRpb25zLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSA/PyAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ID0gbmV3IGdsb2JhbFRoaXMuUmVxdWVzdCh0aGlzLnJlcXVlc3QsIHsgYm9keTogdGhpcy5fb3B0aW9ucy5ib2R5IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jYWxjdWxhdGVSZXRyeURlbGF5KGVycm9yKSB7XG4gICAgICAgIHRoaXMuX3JldHJ5Q291bnQrKztcbiAgICAgICAgaWYgKHRoaXMuX3JldHJ5Q291bnQgPCB0aGlzLl9vcHRpb25zLnJldHJ5LmxpbWl0ICYmICEoZXJyb3IgaW5zdGFuY2VvZiBUaW1lb3V0RXJyb3IpKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBIVFRQRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMucmV0cnkuc3RhdHVzQ29kZXMuaW5jbHVkZXMoZXJyb3IucmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IGVycm9yLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdSZXRyeS1BZnRlcicpO1xuICAgICAgICAgICAgICAgIGlmIChyZXRyeUFmdGVyICYmIHRoaXMuX29wdGlvbnMucmV0cnkuYWZ0ZXJTdGF0dXNDb2Rlcy5pbmNsdWRlcyhlcnJvci5yZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IE51bWJlcihyZXRyeUFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTihhZnRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyID0gRGF0ZS5wYXJzZShyZXRyeUFmdGVyKSAtIERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlciAqPSAxMDAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5yZXRyeS5tYXhSZXRyeUFmdGVyICE9PSAndW5kZWZpbmVkJyAmJiBhZnRlciA+IHRoaXMuX29wdGlvbnMucmV0cnkubWF4UmV0cnlBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzID09PSA0MTMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgQkFDS09GRl9GQUNUT1IgPSAwLjM7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5fb3B0aW9ucy5yZXRyeS5iYWNrb2ZmTGltaXQsIEJBQ0tPRkZfRkFDVE9SICogKDIgKiogKHRoaXMuX3JldHJ5Q291bnQgLSAxKSkgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2RlY29yYXRlUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMucGFyc2VKc29uKSB7XG4gICAgICAgICAgICByZXNwb25zZS5qc29uID0gYXN5bmMgKCkgPT4gdGhpcy5fb3B0aW9ucy5wYXJzZUpzb24oYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIF9yZXRyeShmbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWltcGxpY2l0LWFueS1jYXRjaFxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgbXMgPSBNYXRoLm1pbih0aGlzLl9jYWxjdWxhdGVSZXRyeURlbGF5KGVycm9yKSwgbWF4U2FmZVRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKG1zICE9PSAwICYmIHRoaXMuX3JldHJ5Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkobXMsIHsgc2lnbmFsOiB0aGlzLl9vcHRpb25zLnNpZ25hbCB9KTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhvb2sgb2YgdGhpcy5fb3B0aW9ucy5ob29rcy5iZWZvcmVSZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBob29rUmVzdWx0ID0gYXdhaXQgaG9vayh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLnJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGlzLl9vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudDogdGhpcy5fcmV0cnlDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGBzdG9wYCBpcyByZXR1cm5lZCBmcm9tIHRoZSBob29rLCB0aGUgcmV0cnkgcHJvY2VzcyBpcyBzdG9wcGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChob29rUmVzdWx0ID09PSBzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHJ5KGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9mZXRjaCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBob29rIG9mIHRoaXMuX29wdGlvbnMuaG9va3MuYmVmb3JlUmVxdWVzdCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhvb2sodGhpcy5yZXF1ZXN0LCB0aGlzLl9vcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy50aW1lb3V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZmV0Y2godGhpcy5yZXF1ZXN0LmNsb25lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lb3V0KHRoaXMucmVxdWVzdC5jbG9uZSgpLCB0aGlzLmFib3J0Q29udHJvbGxlciwgdGhpcy5fb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgX3N0cmVhbShyZXNwb25zZSwgb25Eb3dubG9hZFByb2dyZXNzKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsQnl0ZXMgPSBOdW1iZXIocmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJykpIHx8IDA7XG4gICAgICAgIGxldCB0cmFuc2ZlcnJlZEJ5dGVzID0gMDtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICAgICAgICBpZiAob25Eb3dubG9hZFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgb25Eb3dubG9hZFByb2dyZXNzKHsgcGVyY2VudDogMSwgdG90YWxCeXRlcywgdHJhbnNmZXJyZWRCeXRlcyB9LCBuZXcgVWludDhBcnJheSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgZ2xvYmFsVGhpcy5SZXNwb25zZShudWxsLCB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLlJlc3BvbnNlKG5ldyBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgICAgICAgICAgIGlmIChvbkRvd25sb2FkUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Eb3dubG9hZFByb2dyZXNzKHsgcGVyY2VudDogMCwgdHJhbnNmZXJyZWRCeXRlczogMCwgdG90YWxCeXRlcyB9LCBuZXcgVWludDhBcnJheSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob25Eb3dubG9hZFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2ZlcnJlZEJ5dGVzICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50ID0gdG90YWxCeXRlcyA9PT0gMCA/IDAgOiB0cmFuc2ZlcnJlZEJ5dGVzIC8gdG90YWxCeXRlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRG93bmxvYWRQcm9ncmVzcyh7IHBlcmNlbnQsIHRyYW5zZmVycmVkQnl0ZXMsIHRvdGFsQnl0ZXMgfSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVhZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUt5LmpzLm1hcCIsImV4cG9ydCBjb25zdCBzdXBwb3J0c1JlcXVlc3RTdHJlYW1zID0gKCgpID0+IHtcbiAgICBsZXQgZHVwbGV4QWNjZXNzZWQgPSBmYWxzZTtcbiAgICBsZXQgaGFzQ29udGVudFR5cGUgPSBmYWxzZTtcbiAgICBjb25zdCBzdXBwb3J0c1JlYWRhYmxlU3RyZWFtID0gdHlwZW9mIGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0gPT09ICdmdW5jdGlvbic7XG4gICAgY29uc3Qgc3VwcG9ydHNSZXF1ZXN0ID0gdHlwZW9mIGdsb2JhbFRoaXMuUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAoc3VwcG9ydHNSZWFkYWJsZVN0cmVhbSAmJiBzdXBwb3J0c1JlcXVlc3QpIHtcbiAgICAgICAgaGFzQ29udGVudFR5cGUgPSBuZXcgZ2xvYmFsVGhpcy5SZXF1ZXN0KCdodHRwczovL2EuY29tJywge1xuICAgICAgICAgICAgYm9keTogbmV3IGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0oKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIFR5cGVzIGFyZSBvdXRkYXRlZC5cbiAgICAgICAgICAgIGdldCBkdXBsZXgoKSB7XG4gICAgICAgICAgICAgICAgZHVwbGV4QWNjZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAnaGFsZic7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KS5oZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJyk7XG4gICAgfVxuICAgIHJldHVybiBkdXBsZXhBY2Nlc3NlZCAmJiAhaGFzQ29udGVudFR5cGU7XG59KSgpO1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzQWJvcnRDb250cm9sbGVyID0gdHlwZW9mIGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzUmVzcG9uc2VTdHJlYW1zID0gdHlwZW9mIGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0gPT09ICdmdW5jdGlvbic7XG5leHBvcnQgY29uc3Qgc3VwcG9ydHNGb3JtRGF0YSA9IHR5cGVvZiBnbG9iYWxUaGlzLkZvcm1EYXRhID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0IGNvbnN0IHJlcXVlc3RNZXRob2RzID0gWydnZXQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnaGVhZCcsICdkZWxldGUnXTtcbmNvbnN0IHZhbGlkYXRlID0gKCkgPT4gdW5kZWZpbmVkO1xudmFsaWRhdGUoKTtcbmV4cG9ydCBjb25zdCByZXNwb25zZVR5cGVzID0ge1xuICAgIGpzb246ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICB0ZXh0OiAndGV4dC8qJyxcbiAgICBmb3JtRGF0YTogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgIGFycmF5QnVmZmVyOiAnKi8qJyxcbiAgICBibG9iOiAnKi8qJyxcbn07XG4vLyBUaGUgbWF4aW11bSB2YWx1ZSBvZiBhIDMyYml0IGludCAoc2VlIGlzc3VlICMxMTcpXG5leHBvcnQgY29uc3QgbWF4U2FmZVRpbWVvdXQgPSAyMTQ3NDgzNjQ3O1xuZXhwb3J0IGNvbnN0IHN0b3AgPSBTeW1ib2woJ3N0b3AnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiLCIvLyBET01FeGNlcHRpb24gaXMgc3VwcG9ydGVkIG9uIG1vc3QgbW9kZXJuIGJyb3dzZXJzIGFuZCBOb2RlLmpzIDE4Ky5cbi8vIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RPTUV4Y2VwdGlvbiNicm93c2VyX2NvbXBhdGliaWxpdHlcbmNvbnN0IGlzRG9tRXhjZXB0aW9uU3VwcG9ydGVkID0gQm9vbGVhbihnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbik7XG4vLyBUT0RPOiBXaGVuIHRhcmdldGluZyBOb2RlLmpzIDE4LCB1c2UgYHNpZ25hbC50aHJvd0lmQWJvcnRlZCgpYCAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0U2lnbmFsL3Rocm93SWZBYm9ydGVkKVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvc2VBYm9ydEVycm9yKHNpZ25hbCkge1xuICAgIC8qXG4gICAgTk9URTogVXNlIERvbUV4Y2VwdGlvbiB3aXRoIEFib3J0RXJyb3IgbmFtZSBhcyBzcGVjaWZpZWQgaW4gTUROIGRvY3MgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BYm9ydENvbnRyb2xsZXIvYWJvcnQpXG4gICAgPiBXaGVuIGFib3J0KCkgaXMgY2FsbGVkLCB0aGUgZmV0Y2goKSBwcm9taXNlIHJlamVjdHMgd2l0aCBhbiBFcnJvciBvZiB0eXBlIERPTUV4Y2VwdGlvbiwgd2l0aCBuYW1lIEFib3J0RXJyb3IuXG4gICAgKi9cbiAgICBpZiAoaXNEb21FeGNlcHRpb25TdXBwb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24oc2lnbmFsPy5yZWFzb24gPz8gJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKTtcbiAgICB9XG4gICAgLy8gRE9NRXhjZXB0aW9uIG5vdCBzdXBwb3J0ZWQuIEZhbGwgYmFjayB0byB1c2Ugb2YgZXJyb3IgYW5kIG92ZXJyaWRlIG5hbWUuXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3Ioc2lnbmFsPy5yZWFzb24gPz8gJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJyk7XG4gICAgZXJyb3IubmFtZSA9ICdBYm9ydEVycm9yJztcbiAgICByZXR1cm4gZXJyb3I7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ET01FeGNlcHRpb24uanMubWFwIiwiLy8gZXNsaW50LWxpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY2xhc3MgSFRUUEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlLCByZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSAocmVzcG9uc2Uuc3RhdHVzIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMCkgPyByZXNwb25zZS5zdGF0dXMgOiAnJztcbiAgICAgICAgY29uc3QgdGl0bGUgPSByZXNwb25zZS5zdGF0dXNUZXh0IHx8ICcnO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBgJHtjb2RlfSAke3RpdGxlfWAudHJpbSgpO1xuICAgICAgICBjb25zdCByZWFzb24gPSBzdGF0dXMgPyBgc3RhdHVzIGNvZGUgJHtzdGF0dXN9YCA6ICdhbiB1bmtub3duIGVycm9yJztcbiAgICAgICAgc3VwZXIoYFJlcXVlc3QgZmFpbGVkIHdpdGggJHtyZWFzb259YCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3BvbnNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcXVlc3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSFRUUEVycm9yJztcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUVFBFcnJvci5qcy5tYXAiLCJleHBvcnQgY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoJ1JlcXVlc3QgdGltZWQgb3V0Jyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcXVlc3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGltZW91dEVycm9yLmpzLm1hcCIsIi8qISBNSVQgTGljZW5zZSDCqSBTaW5kcmUgU29yaHVzICovXG5pbXBvcnQgeyBLeSB9IGZyb20gJy4vY29yZS9LeS5qcyc7XG5pbXBvcnQgeyByZXF1ZXN0TWV0aG9kcywgc3RvcCB9IGZyb20gJy4vY29yZS9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVBbmRNZXJnZSB9IGZyb20gJy4vdXRpbHMvbWVyZ2UuanMnO1xuY29uc3QgY3JlYXRlSW5zdGFuY2UgPSAoZGVmYXVsdHMpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmNcbiAgICBjb25zdCBreSA9IChpbnB1dCwgb3B0aW9ucykgPT4gS3kuY3JlYXRlKGlucHV0LCB2YWxpZGF0ZUFuZE1lcmdlKGRlZmF1bHRzLCBvcHRpb25zKSk7XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgcmVxdWVzdE1ldGhvZHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jXG4gICAgICAgIGt5W21ldGhvZF0gPSAoaW5wdXQsIG9wdGlvbnMpID0+IEt5LmNyZWF0ZShpbnB1dCwgdmFsaWRhdGVBbmRNZXJnZShkZWZhdWx0cywgb3B0aW9ucywgeyBtZXRob2QgfSkpO1xuICAgIH1cbiAgICBreS5jcmVhdGUgPSAobmV3RGVmYXVsdHMpID0+IGNyZWF0ZUluc3RhbmNlKHZhbGlkYXRlQW5kTWVyZ2UobmV3RGVmYXVsdHMpKTtcbiAgICBreS5leHRlbmQgPSAobmV3RGVmYXVsdHMpID0+IGNyZWF0ZUluc3RhbmNlKHZhbGlkYXRlQW5kTWVyZ2UoZGVmYXVsdHMsIG5ld0RlZmF1bHRzKSk7XG4gICAga3kuc3RvcCA9IHN0b3A7XG4gICAgcmV0dXJuIGt5O1xufTtcbmNvbnN0IGt5ID0gY3JlYXRlSW5zdGFuY2UoKTtcbmV4cG9ydCBkZWZhdWx0IGt5O1xuZXhwb3J0IHsgSFRUUEVycm9yIH0gZnJvbSAnLi9lcnJvcnMvSFRUUEVycm9yLmpzJztcbmV4cG9ydCB7IFRpbWVvdXRFcnJvciB9IGZyb20gJy4vZXJyb3JzL1RpbWVvdXRFcnJvci5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2RlbGF5L3RyZWUvYWI5OGFlOGRmY2IzOGUxNTkzMjg2Yzk0ZDkzNGU3MGQxNGE0ZTExMVxuaW1wb3J0IHsgY29tcG9zZUFib3J0RXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvRE9NRXhjZXB0aW9uLmpzJztcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGRlbGF5KG1zLCB7IHNpZ25hbCB9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGNvbXBvc2VBYm9ydEVycm9yKHNpZ25hbCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGhhbmRsZUFib3J0LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICAgICAgICByZWplY3QoY29tcG9zZUFib3J0RXJyb3Ioc2lnbmFsKSk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNpZ25hbD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBoYW5kbGVBYm9ydCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIG1zKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGF5LmpzLm1hcCIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSAodmFsdWUpID0+IHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy5qcy5tYXAiLCJpbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJy4vaXMuanMnO1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQW5kTWVyZ2UgPSAoLi4uc291cmNlcykgPT4ge1xuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgaWYgKCghaXNPYmplY3Qoc291cmNlKSB8fCBBcnJheS5pc0FycmF5KHNvdXJjZSkpICYmIHR5cGVvZiBzb3VyY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYG9wdGlvbnNgIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZXBNZXJnZSh7fSwgLi4uc291cmNlcyk7XG59O1xuZXhwb3J0IGNvbnN0IG1lcmdlSGVhZGVycyA9IChzb3VyY2UxID0ge30sIHNvdXJjZTIgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBnbG9iYWxUaGlzLkhlYWRlcnMoc291cmNlMSk7XG4gICAgY29uc3QgaXNIZWFkZXJzSW5zdGFuY2UgPSBzb3VyY2UyIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5IZWFkZXJzO1xuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBnbG9iYWxUaGlzLkhlYWRlcnMoc291cmNlMik7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc291cmNlLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoKGlzSGVhZGVyc0luc3RhbmNlICYmIHZhbHVlID09PSAndW5kZWZpbmVkJykgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8vIFRPRE86IE1ha2UgdGhpcyBzdHJvbmdseS10eXBlZCAobm8gYGFueWApLlxuZXhwb3J0IGNvbnN0IGRlZXBNZXJnZSA9ICguLi5zb3VyY2VzKSA9PiB7XG4gICAgbGV0IHJldHVyblZhbHVlID0ge307XG4gICAgbGV0IGhlYWRlcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXR1cm5WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBbLi4ucmV0dXJuVmFsdWUsIC4uLnNvdXJjZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpICYmIGtleSBpbiByZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlZXBNZXJnZShyZXR1cm5WYWx1ZVtrZXldLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0geyAuLi5yZXR1cm5WYWx1ZSwgW2tleV06IHZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc291cmNlLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IG1lcmdlSGVhZGVycyhoZWFkZXJzLCBzb3VyY2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcCIsImltcG9ydCB7IHJlcXVlc3RNZXRob2RzIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVJlcXVlc3RNZXRob2QgPSAoaW5wdXQpID0+IHJlcXVlc3RNZXRob2RzLmluY2x1ZGVzKGlucHV0KSA/IGlucHV0LnRvVXBwZXJDYXNlKCkgOiBpbnB1dDtcbmNvbnN0IHJldHJ5TWV0aG9kcyA9IFsnZ2V0JywgJ3B1dCcsICdoZWFkJywgJ2RlbGV0ZScsICdvcHRpb25zJywgJ3RyYWNlJ107XG5jb25zdCByZXRyeVN0YXR1c0NvZGVzID0gWzQwOCwgNDEzLCA0MjksIDUwMCwgNTAyLCA1MDMsIDUwNF07XG5jb25zdCByZXRyeUFmdGVyU3RhdHVzQ29kZXMgPSBbNDEzLCA0MjksIDUwM107XG5jb25zdCBkZWZhdWx0UmV0cnlPcHRpb25zID0ge1xuICAgIGxpbWl0OiAyLFxuICAgIG1ldGhvZHM6IHJldHJ5TWV0aG9kcyxcbiAgICBzdGF0dXNDb2RlczogcmV0cnlTdGF0dXNDb2RlcyxcbiAgICBhZnRlclN0YXR1c0NvZGVzOiByZXRyeUFmdGVyU3RhdHVzQ29kZXMsXG4gICAgbWF4UmV0cnlBZnRlcjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIGJhY2tvZmZMaW1pdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxufTtcbmV4cG9ydCBjb25zdCBub3JtYWxpemVSZXRyeU9wdGlvbnMgPSAocmV0cnkgPSB7fSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcmV0cnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5kZWZhdWx0UmV0cnlPcHRpb25zLFxuICAgICAgICAgICAgbGltaXQ6IHJldHJ5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAocmV0cnkubWV0aG9kcyAmJiAhQXJyYXkuaXNBcnJheShyZXRyeS5tZXRob2RzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJ5Lm1ldGhvZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICBpZiAocmV0cnkuc3RhdHVzQ29kZXMgJiYgIUFycmF5LmlzQXJyYXkocmV0cnkuc3RhdHVzQ29kZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cnkuc3RhdHVzQ29kZXMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZWZhdWx0UmV0cnlPcHRpb25zLFxuICAgICAgICAuLi5yZXRyeSxcbiAgICAgICAgYWZ0ZXJTdGF0dXNDb2RlczogcmV0cnlBZnRlclN0YXR1c0NvZGVzLFxuICAgIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybWFsaXplLmpzLm1hcCIsImltcG9ydCB7IFRpbWVvdXRFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9UaW1lb3V0RXJyb3IuanMnO1xuLy8gYFByb21pc2UucmFjZSgpYCB3b3JrYXJvdW5kICgjOTEpXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB0aW1lb3V0KHJlcXVlc3QsIGFib3J0Q29udHJvbGxlciwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVqZWN0KG5ldyBUaW1lb3V0RXJyb3IocmVxdWVzdCkpO1xuICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICB2b2lkIG9wdGlvbnNcbiAgICAgICAgICAgIC5mZXRjaChyZXF1ZXN0KVxuICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0LmpzLm1hcCIsImltcG9ydCBreSBmcm9tICdreSc7XG5pbXBvcnQgbG9nZ2VyIGZyb20gJ0B3ZGlvL2xvZ2dlcic7XG5pbXBvcnQgV2ViRHJpdmVyUmVxdWVzdCBmcm9tICcuL2luZGV4LmpzJztcbmNvbnN0IGxvZyA9IGxvZ2dlcignd2ViZHJpdmVyJyk7XG5jb25zdCBVTlNVUFBPUlRFRF9PUFRTID0gW1xuICAgICdhZ2VudCcsXG4gICAgJ3Jlc3BvbnNlVHlwZScsXG4gICAgJ3NlYXJjaFBhcmFtcycsXG5dO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJvd3NlclJlcXVlc3QgZXh0ZW5kcyBXZWJEcml2ZXJSZXF1ZXN0IHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIGVuZHBvaW50LCBib2R5LCBpc0h1YkNvbW1hbmQgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcihtZXRob2QsIGVuZHBvaW50LCBib2R5LCBpc0h1YkNvbW1hbmQpO1xuICAgIH1cbiAgICBhc3luYyBfY3JlYXRlT3B0aW9ucyhvcHRpb25zLCBzZXNzaW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9jcmVhdGVPcHRpb25zKG9wdGlvbnMsIHNlc3Npb25JZCwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIF9saWJSZXF1ZXN0KHVybCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBreU9wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBvcHQgb2YgT2JqZWN0LmtleXMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1tvcHRdICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgIFVOU1VQUE9SVEVEX09QVFMuaW5jbHVkZXMob3B0KSAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnNbb3B0XSAhPT0gdGhpcy5kZWZhdWx0T3B0aW9uc1tvcHRdKSB7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oYEJyb3dzZXItYmFzZWQgd2ViZHJpdmVyIGRvZXMgbm90IHN1cHBvcnQgdGhlICcke1N0cmluZyhvcHQpfScgb3B0aW9uOyBiZWhhdmlvciBtYXkgYmUgdW5leHBlY3RlZGApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAga3lPcHRpb25zW29wdF0gPSBvcHRpb25zW29wdF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudXNlcm5hbWUgJiYgb3B0aW9ucy5wYXNzd29yZCkge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZEF1dGggPSBCdWZmZXIuZnJvbShgJHtvcHRpb25zLnVzZXJuYW1lfToke29wdGlvbnMucGFzc3dvcmR9YCwgJ3V0ZjgnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICBreU9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAuLi5reU9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmFzaWMgJHtlbmNvZGVkQXV0aH1gXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGt5KHVybCwga3lPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICBib2R5OiBhd2FpdCByZXMuanNvbigpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfbGliUGVyZm9ybWFuY2VOb3coKSB7XG4gICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnbm9kZTpldmVudHMnO1xuaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gJ25vZGU6bW9kdWxlJztcbmltcG9ydCBsb2dnZXIgZnJvbSAnQHdkaW8vbG9nZ2VyJztcbmltcG9ydCB7IHRyYW5zZm9ybUNvbW1hbmRMb2dSZXN1bHQgfSBmcm9tICdAd2Rpby91dGlscyc7XG5pbXBvcnQgeyBVUkxGYWN0b3J5IH0gZnJvbSAnLi9mYWN0b3J5LmpzJztcbmltcG9ydCB7IGlzU3VjY2Vzc2Z1bFJlc3BvbnNlLCBnZXRFcnJvckZyb21SZXNwb25zZUJvZHksIGdldFRpbWVvdXRFcnJvciB9IGZyb20gJy4uL3V0aWxzLmpzJztcbmNvbnN0IHJlcXVpcmUgPSBjcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybCk7XG5jb25zdCBwa2cgPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKTtcbmV4cG9ydCBjbGFzcyBSZXF1ZXN0TGliRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgc3RhdHVzQ29kZTtcbiAgICBib2R5O1xuICAgIGNvZGU7XG59XG5jb25zdCBERUZBVUxUX0hFQURFUlMgPSB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04JyxcbiAgICAnQ29ubmVjdGlvbic6ICdrZWVwLWFsaXZlJyxcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICdVc2VyLUFnZW50JzogJ3dlYmRyaXZlci8nICsgcGtnLnZlcnNpb25cbn07XG5jb25zdCBsb2cgPSBsb2dnZXIoJ3dlYmRyaXZlcicpO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViRHJpdmVyUmVxdWVzdCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgYm9keTtcbiAgICBtZXRob2Q7XG4gICAgZW5kcG9pbnQ7XG4gICAgaXNIdWJDb21tYW5kO1xuICAgIHJlcXVpcmVzU2Vzc2lvbklkO1xuICAgIGRlZmF1bHRBZ2VudHM7XG4gICAgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGZvbGxvd1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgdGhyb3dIdHRwRXJyb3JzOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBlbmRwb2ludCwgYm9keSwgaXNIdWJDb21tYW5kID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludDtcbiAgICAgICAgdGhpcy5pc0h1YkNvbW1hbmQgPSBpc0h1YkNvbW1hbmQ7XG4gICAgICAgIHRoaXMucmVxdWlyZXNTZXNzaW9uSWQgPSBCb29sZWFuKHRoaXMuZW5kcG9pbnQubWF0Y2goLzpzZXNzaW9uSWQvKSk7XG4gICAgfVxuICAgIGFzeW5jIG1ha2VSZXF1ZXN0KG9wdGlvbnMsIHNlc3Npb25JZCkge1xuICAgICAgICBsZXQgZnVsbFJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogdGhpcy5tZXRob2QgfSwgdGhpcy5kZWZhdWx0T3B0aW9ucywgYXdhaXQgdGhpcy5fY3JlYXRlT3B0aW9ucyhvcHRpb25zLCBzZXNzaW9uSWQpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybVJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGZ1bGxSZXF1ZXN0T3B0aW9ucyA9IG9wdGlvbnMudHJhbnNmb3JtUmVxdWVzdChmdWxsUmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgncmVxdWVzdCcsIGZ1bGxSZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KGZ1bGxSZXF1ZXN0T3B0aW9ucywgb3B0aW9ucy50cmFuc2Zvcm1SZXNwb25zZSwgb3B0aW9ucy5jb25uZWN0aW9uUmV0cnlDb3VudCwgMCk7XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVPcHRpb25zKG9wdGlvbnMsIHNlc3Npb25JZCwgaXNCcm93c2VyID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYWdlbnQgPSBpc0Jyb3dzZXIgPyB1bmRlZmluZWQgOiAob3B0aW9ucy5hZ2VudCB8fCB0aGlzLmRlZmF1bHRBZ2VudHMpO1xuICAgICAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBpc0Jyb3dzZXIgP1xuICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0aW9ucy5xdWVyeVBhcmFtcyA9PT0gJ29iamVjdCcgPyBvcHRpb25zLnF1ZXJ5UGFyYW1zIDoge30pO1xuICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGh0dHBzOiB7fSxcbiAgICAgICAgICAgIGFnZW50LFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIC4uLkRFRkFVTFRfSEVBREVSUyxcbiAgICAgICAgICAgICAgICAuLi4odHlwZW9mIG9wdGlvbnMuaGVhZGVycyA9PT0gJ29iamVjdCcgPyBvcHRpb25zLmhlYWRlcnMgOiB7fSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMsXG4gICAgICAgICAgICByZXRyeTogeyBsaW1pdDogb3B0aW9ucy5jb25uZWN0aW9uUmV0cnlDb3VudCB9LFxuICAgICAgICAgICAgdGltZW91dDogeyByZXNwb25zZTogb3B0aW9ucy5jb25uZWN0aW9uUmV0cnlUaW1lb3V0IH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9ubHkgYXBwbHkgYm9keSBwcm9wZXJ0eSBpZiBleGlzdGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuYm9keSAmJiAoT2JqZWN0LmtleXModGhpcy5ib2R5KS5sZW5ndGggfHwgdGhpcy5tZXRob2QgPT09ICdQT1NUJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpLCAndXRmOCcpO1xuICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuanNvbiA9IHRoaXMuYm9keTtcbiAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSBgJHtjb250ZW50TGVuZ3RofWA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlmIHdlIGRvbid0IGhhdmUgYSBzZXNzaW9uIGlkIHdlIHNldCBpdCBoZXJlLCB1bmxlc3Mgd2UgY2FsbCBjb21tYW5kcyB0aGF0IGRvbid0IHJlcXVpcmUgc2Vzc2lvbiBpZHMsIGZvclxuICAgICAgICAgKiBleGFtcGxlIC9zZXNzaW9ucy4gVGhlIGNhbGwgdG8gL3Nlc3Npb25zIGlzIG5vdCBjb25uZWN0ZWQgdG8gYSBzZXNzaW9uIGl0c2VsZiBhbmQgaXQgdGhlcmVmb3JlIGRvZXNuJ3RcbiAgICAgICAgICogcmVxdWlyZSBpdFxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGVuZHBvaW50ID0gdGhpcy5lbmRwb2ludDtcbiAgICAgICAgaWYgKHRoaXMucmVxdWlyZXNTZXNzaW9uSWQpIHtcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHNlc3Npb25JZCBpcyByZXF1aXJlZCBmb3IgdGhpcyBjb21tYW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRwb2ludCA9IGVuZHBvaW50LnJlcGxhY2UoJzpzZXNzaW9uSWQnLCBzZXNzaW9uSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLnVybCA9IGF3YWl0IFVSTEZhY3RvcnkuZ2V0SW5zdGFuY2UoYCR7b3B0aW9ucy5wcm90b2NvbH06Ly9gICtcbiAgICAgICAgICAgIGAke29wdGlvbnMuaG9zdG5hbWV9OiR7b3B0aW9ucy5wb3J0fWAgK1xuICAgICAgICAgICAgKHRoaXMuaXNIdWJDb21tYW5kID8gdGhpcy5lbmRwb2ludCA6IHBhdGguam9pbihvcHRpb25zLnBhdGggfHwgJycsIGVuZHBvaW50KSkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogc2VuZCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBvbmx5IHdoZW4gY3JlYXRpbmcgbmV3IHNlc3Npb25cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmVuZHBvaW50ID09PSAnL3Nlc3Npb24nICYmIG9wdGlvbnMudXNlciAmJiBvcHRpb25zLmtleSkge1xuICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMudXNlcm5hbWUgPSBvcHRpb25zLnVzZXI7XG4gICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5wYXNzd29yZCA9IG9wdGlvbnMua2V5O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgXCJTVFJJQ1RfU1NMXCIgaXMgZGVmaW5lZCBhcyBcImZhbHNlXCIsIGl0IGRvZXNuJ3QgcmVxdWlyZSBTU0wgY2VydGlmaWNhdGVzIHRvIGJlIHZhbGlkLlxuICAgICAgICAgKiBPciB0aGUgcmVxdWVzdE9wdGlvbnMgaGFzIHN0cmljdFNTTCBmb3IgYW4gZW52aXJvbm1lbnQgd2hpY2ggY2Fubm90IGdldCB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgY29ycmVjdGx5IGxpa2Ugb24gYW4gRWxlY3Ryb24gYXBwLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVxdWVzdE9wdGlvbnMuaHR0cHMucmVqZWN0VW5hdXRob3JpemVkID0gIShvcHRpb25zLnN0cmljdFNTTCA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52LlNUUklDVF9TU0wgPT09ICdmYWxzZScgfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52LnN0cmljdF9zc2wgPT09ICdmYWxzZScpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdE9wdGlvbnM7XG4gICAgfVxuICAgIGFzeW5jIF9saWJSZXF1ZXN0KHVybCwgb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZnVuY3Rpb24gbXVzdCBiZSBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICBfbGliUGVyZm9ybWFuY2VOb3coKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBmdW5jdGlvbiBtdXN0IGJlIGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIF9yZXF1ZXN0KGZ1bGxSZXF1ZXN0T3B0aW9ucywgdHJhbnNmb3JtUmVzcG9uc2UsIHRvdGFsUmV0cnlDb3VudCA9IDAsIHJldHJ5Q291bnQgPSAwKSB7XG4gICAgICAgIGxvZy5pbmZvKGBbJHtmdWxsUmVxdWVzdE9wdGlvbnMubWV0aG9kfV0gJHtmdWxsUmVxdWVzdE9wdGlvbnMudXJsLmhyZWZ9YCk7XG4gICAgICAgIGlmIChmdWxsUmVxdWVzdE9wdGlvbnMuanNvbiAmJiBPYmplY3Qua2V5cyhmdWxsUmVxdWVzdE9wdGlvbnMuanNvbikubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2cuaW5mbygnREFUQScsIHRyYW5zZm9ybUNvbW1hbmRMb2dSZXN1bHQoZnVsbFJlcXVlc3RPcHRpb25zLmpzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHVybCwgLi4ucmVxdWVzdExpYk9wdGlvbnMgfSA9IGZ1bGxSZXF1ZXN0T3B0aW9ucztcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gdGhpcy5fbGliUGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fbGliUmVxdWVzdCh1cmwsIHJlcXVlc3RMaWJPcHRpb25zKVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGVycik7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uTWlsbGlzZWNvbmQgPSB0aGlzLl9saWJQZXJmb3JtYW5jZU5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICAvKipcbiAgICAgICAgICogaGFuZGxlIHJldHJpZXMgZm9yIHJlcXVlc3RzXG4gICAgICAgICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yICBlcnJvciBvYmplY3QgdGhhdCBjYXVzZXMgdGhlIHJldHJ5XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgICBtZXNzYWdlIHRoYXQgaXMgYmVpbmcgc2hvd24gYXMgd2FybmluZyB0byB1c2VyXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXRyeSA9IChlcnJvciwgbXNnKSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHN0b3AgcmV0cnlpbmcgaWYgdG90YWxSZXRyeUNvdW50IHdhcyBleGNlZWRlZCBvciB0aGVyZSBpcyBubyByZWFzb24gdG9cbiAgICAgICAgICAgICAqIHJldHJ5LCBlLmcuIGlmIHNlc3Npb25JZCBpcyBpbnZhbGlkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChyZXRyeUNvdW50ID49IHRvdGFsUmV0cnlDb3VudCB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdpbnZhbGlkIHNlc3Npb24gaWQnKSkge1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXNDb2RlfSBkdWUgdG8gJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3Jlc3BvbnNlJywgeyBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3BlcmZvcm1hbmNlJywgeyByZXF1ZXN0OiBmdWxsUmVxdWVzdE9wdGlvbnMsIGR1cmF0aW9uTWlsbGlzZWNvbmQsIHN1Y2Nlc3M6IGZhbHNlLCBlcnJvciwgcmV0cnlDb3VudCB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsrcmV0cnlDb3VudDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmV0cnknLCB7IGVycm9yLCByZXRyeUNvdW50IH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwZXJmb3JtYW5jZScsIHsgcmVxdWVzdDogZnVsbFJlcXVlc3RPcHRpb25zLCBkdXJhdGlvbk1pbGxpc2Vjb25kLCBzdWNjZXNzOiBmYWxzZSwgZXJyb3IsIHJldHJ5Q291bnQgfSk7XG4gICAgICAgICAgICBsb2cud2Fybihtc2cpO1xuICAgICAgICAgICAgbG9nLmluZm8oYFJldHJ5aW5nICR7cmV0cnlDb3VudH0vJHt0b3RhbFJldHJ5Q291bnR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChmdWxsUmVxdWVzdE9wdGlvbnMsIHRyYW5zZm9ybVJlc3BvbnNlLCB0b3RhbFJldHJ5Q291bnQsIHJldHJ5Q291bnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogaGFuZGxlIHJlcXVlc3QgZXJyb3JzXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBoYW5kbGUgdGltZW91dHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmNvZGUgPT09ICdFVElNRURPVVQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBnZXRUaW1lb3V0RXJyb3IocmVzcG9uc2UsIGZ1bGxSZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHJ5KGVycm9yLCAnUmVxdWVzdCB0aW1lZCBvdXQhIENvbnNpZGVyIGluY3JlYXNpbmcgdGhlIFwiY29ubmVjdGlvblJldHJ5VGltZW91dFwiIG9wdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogdGhyb3cgaWYgcmVxdWVzdCBlcnJvciBpcyB1bmtub3duXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZW1pdCgncGVyZm9ybWFuY2UnLCB7IHJlcXVlc3Q6IGZ1bGxSZXF1ZXN0T3B0aW9ucywgZHVyYXRpb25NaWxsaXNlY29uZCwgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXNwb25zZSwgcmV0cnlDb3VudCB9KTtcbiAgICAgICAgICAgIHRocm93IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtUmVzcG9uc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdHJhbnNmb3JtUmVzcG9uc2UocmVzcG9uc2UsIGZ1bGxSZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3IgPSBnZXRFcnJvckZyb21SZXNwb25zZUJvZHkocmVzcG9uc2UuYm9keSwgZnVsbFJlcXVlc3RPcHRpb25zLmpzb24pO1xuICAgICAgICAvKipcbiAgICAgICAgICogcmV0cnkgY29ubmVjdGlvbiByZWZ1c2VkIGVycm9yc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdqYXZhLm5ldC5Db25uZWN0RXhjZXB0aW9uOiBDb25uZWN0aW9uIHJlZnVzZWQ6IGNvbm5lY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnkoZXJyb3IsICdDb25uZWN0aW9uIHRvIFNlbGVuaXVtIFN0YW5kYWxvbmUgc2VydmVyIHdhcyByZWZ1c2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBodWIgY29tbWFuZHMgZG9uJ3QgZm9sbG93IHN0YW5kYXJkIHJlc3BvbnNlIGZvcm1hdHNcbiAgICAgICAgICogYW5kIGNhbiBoYXZlIGVtcHR5IGJvZGllc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuaXNIdWJDb21tYW5kKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGlmIGJvZHkgY29udGFpbnMgSFRNTCB0aGUgY29tbWFuZCB3YXMgY2FsbGVkIG9uIGEgbm9kZVxuICAgICAgICAgICAgICogZGlyZWN0bHkgd2l0aG91dCB1c2luZyBhIGh1YiwgdGhlcmVmb3JlIHRocm93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuYm9keSA9PT0gJ3N0cmluZycgJiYgcmVzcG9uc2UuYm9keS5zdGFydHNXaXRoKCc8IURPQ1RZUEUgaHRtbD4nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGVyZm9ybWFuY2UnLCB7IHJlcXVlc3Q6IGZ1bGxSZXF1ZXN0T3B0aW9ucywgZHVyYXRpb25NaWxsaXNlY29uZCwgc3VjY2VzczogZmFsc2UsIGVycm9yLCByZXRyeUNvdW50IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0NvbW1hbmQgY2FuIG9ubHkgYmUgY2FsbGVkIHRvIGEgU2VsZW5pdW0gSHViJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJlc3BvbnNlLmJvZHkgfHwgbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNvbHZlIG9ubHkgaWYgc3VjY2Vzc2Z1bCByZXNwb25zZVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzU3VjY2Vzc2Z1bFJlc3BvbnNlKHJlc3BvbnNlLnN0YXR1c0NvZGUsIHJlc3BvbnNlLmJvZHkpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Jlc3BvbnNlJywgeyByZXN1bHQ6IHJlc3BvbnNlLmJvZHkgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3BlcmZvcm1hbmNlJywgeyByZXF1ZXN0OiBmdWxsUmVxdWVzdE9wdGlvbnMsIGR1cmF0aW9uTWlsbGlzZWNvbmQsIHN1Y2Nlc3M6IHRydWUsIHJldHJ5Q291bnQgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogIHN0b3AgcmV0cnlpbmcgYXMgdGhpcyB3aWxsIG5ldmVyIGJlIHN1Y2Nlc3NmdWwuXG4gICAgICAgICAqICB3ZSB3aWxsIGhhbmRsZSB0aGlzIGF0IHRoZSBlbGVtZW50RXJyb3JIYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ3N0YWxlIGVsZW1lbnQgcmVmZXJlbmNlJykge1xuICAgICAgICAgICAgbG9nLndhcm4oJ1JlcXVlc3QgZW5jb3VudGVyZWQgYSBzdGFsZSBlbGVtZW50IC0gdGVybWluYXRpbmcgcmVxdWVzdCcpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXNwb25zZScsIHsgZXJyb3IgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3BlcmZvcm1hbmNlJywgeyByZXF1ZXN0OiBmdWxsUmVxdWVzdE9wdGlvbnMsIGR1cmF0aW9uTWlsbGlzZWNvbmQsIHN1Y2Nlc3M6IGZhbHNlLCBlcnJvciwgcmV0cnlDb3VudCB9KTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRyeShlcnJvciwgYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzQ29kZX0gZHVlIHRvICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=