exports.id = "vendors-node_modules_webdriver_build_request_node_js";
exports.ids = ["vendors-node_modules_webdriver_build_request_node_js"];
exports.modules = {

/***/ "./node_modules/decompress-response/index.js":
/*!***************************************************!*\
  !*** ./node_modules/decompress-response/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {Transform, PassThrough} = __webpack_require__(/*! stream */ "stream");
const zlib = __webpack_require__(/*! zlib */ "zlib");
const mimicResponse = __webpack_require__(/*! mimic-response */ "./node_modules/decompress-response/node_modules/mimic-response/index.js");

module.exports = response => {
	const contentEncoding = (response.headers['content-encoding'] || '').toLowerCase();

	if (!['gzip', 'deflate', 'br'].includes(contentEncoding)) {
		return response;
	}

	// TODO: Remove this when targeting Node.js 12.
	const isBrotli = contentEncoding === 'br';
	if (isBrotli && typeof zlib.createBrotliDecompress !== 'function') {
		response.destroy(new Error('Brotli is not supported on Node.js < 12'));
		return response;
	}

	let isEmpty = true;

	const checker = new Transform({
		transform(data, _encoding, callback) {
			isEmpty = false;

			callback(null, data);
		},

		flush(callback) {
			callback();
		}
	});

	const finalStream = new PassThrough({
		autoDestroy: false,
		destroy(error, callback) {
			response.destroy();

			callback(error);
		}
	});

	const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();

	decompressStream.once('error', error => {
		if (isEmpty && !response.readable) {
			finalStream.end();
			return;
		}

		finalStream.destroy(error);
	});

	mimicResponse(response, finalStream);
	response.pipe(checker).pipe(decompressStream).pipe(finalStream);

	return finalStream;
};


/***/ }),

/***/ "./node_modules/decompress-response/node_modules/mimic-response/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/decompress-response/node_modules/mimic-response/index.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";


// We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage
const knownProperties = [
	'aborted',
	'complete',
	'headers',
	'httpVersion',
	'httpVersionMinor',
	'httpVersionMajor',
	'method',
	'rawHeaders',
	'rawTrailers',
	'setTimeout',
	'socket',
	'statusCode',
	'statusMessage',
	'trailers',
	'url'
];

module.exports = (fromStream, toStream) => {
	if (toStream._readableState.autoDestroy) {
		throw new Error('The second stream must have the `autoDestroy` option set to `false`');
	}

	const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));

	const properties = {};

	for (const property of fromProperties) {
		// Don't overwrite existing properties.
		if (property in toStream) {
			continue;
		}

		properties[property] = {
			get() {
				const value = fromStream[property];
				const isFunction = typeof value === 'function';

				return isFunction ? value.bind(fromStream) : value;
			},
			set(value) {
				fromStream[property] = value;
			},
			enumerable: true,
			configurable: false
		};
	}

	Object.defineProperties(toStream, properties);

	fromStream.once('aborted', () => {
		toStream.destroy();

		toStream.emit('aborted');
	});

	fromStream.once('close', () => {
		if (fromStream.complete) {
			if (toStream.readable) {
				toStream.once('end', () => {
					toStream.emit('close');
				});
			} else {
				toStream.emit('close');
			}
		} else {
			toStream.emit('close');
		}
	});

	return toStream;
};


/***/ }),

/***/ "./node_modules/defer-to-connect/dist/source/index.js":
/*!************************************************************!*\
  !*** ./node_modules/defer-to-connect/dist/source/index.js ***!
  \************************************************************/
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isTLSSocket(socket) {
    return socket.encrypted;
}
const deferToConnect = (socket, fn) => {
    let listeners;
    if (typeof fn === 'function') {
        const connect = fn;
        listeners = { connect };
    }
    else {
        listeners = fn;
    }
    const hasConnectListener = typeof listeners.connect === 'function';
    const hasSecureConnectListener = typeof listeners.secureConnect === 'function';
    const hasCloseListener = typeof listeners.close === 'function';
    const onConnect = () => {
        if (hasConnectListener) {
            listeners.connect();
        }
        if (isTLSSocket(socket) && hasSecureConnectListener) {
            if (socket.authorized) {
                listeners.secureConnect();
            }
            else if (!socket.authorizationError) {
                socket.once('secureConnect', listeners.secureConnect);
            }
        }
        if (hasCloseListener) {
            socket.once('close', listeners.close);
        }
    };
    if (socket.writable && !socket.connecting) {
        onConnect();
    }
    else if (socket.connecting) {
        socket.once('connect', onConnect);
    }
    else if (socket.destroyed && hasCloseListener) {
        listeners.close(socket._hadError);
    }
};
exports["default"] = deferToConnect;
// For CommonJS default export support
module.exports = deferToConnect;
module.exports["default"] = deferToConnect;


/***/ }),

/***/ "./node_modules/get-stream/buffer-stream.js":
/*!**************************************************!*\
  !*** ./node_modules/get-stream/buffer-stream.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {PassThrough: PassThroughStream} = __webpack_require__(/*! stream */ "stream");

module.exports = options => {
	options = {...options};

	const {array} = options;
	let {encoding} = options;
	const isBuffer = encoding === 'buffer';
	let objectMode = false;

	if (array) {
		objectMode = !(encoding || isBuffer);
	} else {
		encoding = encoding || 'utf8';
	}

	if (isBuffer) {
		encoding = null;
	}

	const stream = new PassThroughStream({objectMode});

	if (encoding) {
		stream.setEncoding(encoding);
	}

	let length = 0;
	const chunks = [];

	stream.on('data', chunk => {
		chunks.push(chunk);

		if (objectMode) {
			length = chunks.length;
		} else {
			length += chunk.length;
		}
	});

	stream.getBufferedValue = () => {
		if (array) {
			return chunks;
		}

		return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
	};

	stream.getBufferedLength = () => length;

	return stream;
};


/***/ }),

/***/ "./node_modules/get-stream/index.js":
/*!******************************************!*\
  !*** ./node_modules/get-stream/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {constants: BufferConstants} = __webpack_require__(/*! buffer */ "buffer");
const stream = __webpack_require__(/*! stream */ "stream");
const {promisify} = __webpack_require__(/*! util */ "util");
const bufferStream = __webpack_require__(/*! ./buffer-stream */ "./node_modules/get-stream/buffer-stream.js");

const streamPipelinePromisified = promisify(stream.pipeline);

class MaxBufferError extends Error {
	constructor() {
		super('maxBuffer exceeded');
		this.name = 'MaxBufferError';
	}
}

async function getStream(inputStream, options) {
	if (!inputStream) {
		throw new Error('Expected a stream');
	}

	options = {
		maxBuffer: Infinity,
		...options
	};

	const {maxBuffer} = options;
	const stream = bufferStream(options);

	await new Promise((resolve, reject) => {
		const rejectPromise = error => {
			// Don't retrieve an oversized buffer.
			if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
				error.bufferedData = stream.getBufferedValue();
			}

			reject(error);
		};

		(async () => {
			try {
				await streamPipelinePromisified(inputStream, stream);
				resolve();
			} catch (error) {
				rejectPromise(error);
			}
		})();

		stream.on('data', () => {
			if (stream.getBufferedLength() > maxBuffer) {
				rejectPromise(new MaxBufferError());
			}
		});
	});

	return stream.getBufferedValue();
}

module.exports = getStream;
module.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});
module.exports.array = (stream, options) => getStream(stream, {...options, array: true});
module.exports.MaxBufferError = MaxBufferError;


/***/ }),

/***/ "./node_modules/http-cache-semantics/index.js":
/*!****************************************************!*\
  !*** ./node_modules/http-cache-semantics/index.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";

// rfc7231 6.1
const statusCodeCacheableByDefault = new Set([
    200,
    203,
    204,
    206,
    300,
    301,
    308,
    404,
    405,
    410,
    414,
    501,
]);

// This implementation does not understand partial responses (206)
const understoodStatuses = new Set([
    200,
    203,
    204,
    300,
    301,
    302,
    303,
    307,
    308,
    404,
    405,
    410,
    414,
    501,
]);

const errorStatusCodes = new Set([
    500,
    502,
    503, 
    504,
]);

const hopByHopHeaders = {
    date: true, // included, because we add Age update Date
    connection: true,
    'keep-alive': true,
    'proxy-authenticate': true,
    'proxy-authorization': true,
    te: true,
    trailer: true,
    'transfer-encoding': true,
    upgrade: true,
};

const excludedFromRevalidationUpdate = {
    // Since the old body is reused, it doesn't make sense to change properties of the body
    'content-length': true,
    'content-encoding': true,
    'transfer-encoding': true,
    'content-range': true,
};

function toNumberOrZero(s) {
    const n = parseInt(s, 10);
    return isFinite(n) ? n : 0;
}

// RFC 5861
function isErrorResponse(response) {
    // consider undefined response as faulty
    if(!response) {
        return true
    }
    return errorStatusCodes.has(response.status);
}

function parseCacheControl(header) {
    const cc = {};
    if (!header) return cc;

    // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),
    // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale
    const parts = header.trim().split(/,/);
    for (const part of parts) {
        const [k, v] = part.split(/=/, 2);
        cc[k.trim()] = v === undefined ? true : v.trim().replace(/^"|"$/g, '');
    }

    return cc;
}

function formatCacheControl(cc) {
    let parts = [];
    for (const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + '=' + v);
    }
    if (!parts.length) {
        return undefined;
    }
    return parts.join(', ');
}

module.exports = class CachePolicy {
    constructor(
        req,
        res,
        {
            shared,
            cacheHeuristic,
            immutableMinTimeToLive,
            ignoreCargoCult,
            _fromObject,
        } = {}
    ) {
        if (_fromObject) {
            this._fromObject(_fromObject);
            return;
        }

        if (!res || !res.headers) {
            throw Error('Response headers missing');
        }
        this._assertRequestHasHeaders(req);

        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._cacheHeuristic =
            undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE
        this._immutableMinTtl =
            undefined !== immutableMinTimeToLive
                ? immutableMinTimeToLive
                : 24 * 3600 * 1000;

        this._status = 'status' in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers['cache-control']);
        this._method = 'method' in req ? req.method : 'GET';
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used
        this._reqcc = parseCacheControl(req.headers['cache-control']);

        // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,
        // so there's no point stricly adhering to the blindly copy&pasted directives.
        if (
            ignoreCargoCult &&
            'pre-check' in this._rescc &&
            'post-check' in this._rescc
        ) {
            delete this._rescc['pre-check'];
            delete this._rescc['post-check'];
            delete this._rescc['no-cache'];
            delete this._rescc['no-store'];
            delete this._rescc['must-revalidate'];
            this._resHeaders = Object.assign({}, this._resHeaders, {
                'cache-control': formatCacheControl(this._rescc),
            });
            delete this._resHeaders.expires;
            delete this._resHeaders.pragma;
        }

        // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive
        // as having the same effect as if "Cache-Control: no-cache" were present (see Section 5.2.1).
        if (
            res.headers['cache-control'] == null &&
            /no-cache/.test(res.headers.pragma)
        ) {
            this._rescc['no-cache'] = true;
        }
    }

    now() {
        return Date.now();
    }

    storable() {
        // The "no-store" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.
        return !!(
            !this._reqcc['no-store'] &&
            // A cache MUST NOT store a response to any request, unless:
            // The request method is understood by the cache and defined as being cacheable, and
            ('GET' === this._method ||
                'HEAD' === this._method ||
                ('POST' === this._method && this._hasExplicitExpiration())) &&
            // the response status code is understood by the cache, and
            understoodStatuses.has(this._status) &&
            // the "no-store" cache directive does not appear in request or response header fields, and
            !this._rescc['no-store'] &&
            // the "private" response directive does not appear in the response, if the cache is shared, and
            (!this._isShared || !this._rescc.private) &&
            // the Authorization header field does not appear in the request, if the cache is shared,
            (!this._isShared ||
                this._noAuthorization ||
                this._allowsStoringAuthenticated()) &&
            // the response either:
            // contains an Expires header field, or
            (this._resHeaders.expires ||
                // contains a max-age response directive, or
                // contains a s-maxage response directive and the cache is shared, or
                // contains a public response directive.
                this._rescc['max-age'] ||
                (this._isShared && this._rescc['s-maxage']) ||
                this._rescc.public ||
                // has a status code that is defined as cacheable by default
                statusCodeCacheableByDefault.has(this._status))
        );
    }

    _hasExplicitExpiration() {
        // 4.2.1 Calculating Freshness Lifetime
        return (
            (this._isShared && this._rescc['s-maxage']) ||
            this._rescc['max-age'] ||
            this._resHeaders.expires
        );
    }

    _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
            throw Error('Request headers missing');
        }
    }

    satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);

        // When presented with a request, a cache MUST NOT reuse a stored response, unless:
        // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,
        // unless the stored response is successfully validated (Section 4.3), and
        const requestCC = parseCacheControl(req.headers['cache-control']);
        if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {
            return false;
        }

        if (requestCC['max-age'] && this.age() > requestCC['max-age']) {
            return false;
        }

        if (
            requestCC['min-fresh'] &&
            this.timeToLive() < 1000 * requestCC['min-fresh']
        ) {
            return false;
        }

        // the stored response is either:
        // fresh, or allowed to be served stale
        if (this.stale()) {
            const allowsStale =
                requestCC['max-stale'] &&
                !this._rescc['must-revalidate'] &&
                (true === requestCC['max-stale'] ||
                    requestCC['max-stale'] > this.age() - this.maxAge());
            if (!allowsStale) {
                return false;
            }
        }

        return this._requestMatches(req, false);
    }

    _requestMatches(req, allowHeadMethod) {
        // The presented effective request URI and that of the stored response match, and
        return (
            (!this._url || this._url === req.url) &&
            this._host === req.headers.host &&
            // the request method associated with the stored response allows it to be used for the presented request, and
            (!req.method ||
                this._method === req.method ||
                (allowHeadMethod && 'HEAD' === req.method)) &&
            // selecting header fields nominated by the stored response (if any) match those presented, and
            this._varyMatches(req)
        );
    }

    _allowsStoringAuthenticated() {
        //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.
        return (
            this._rescc['must-revalidate'] ||
            this._rescc.public ||
            this._rescc['s-maxage']
        );
    }

    _varyMatches(req) {
        if (!this._resHeaders.vary) {
            return true;
        }

        // A Vary header field-value of "*" always fails to match
        if (this._resHeaders.vary === '*') {
            return false;
        }

        const fields = this._resHeaders.vary
            .trim()
            .toLowerCase()
            .split(/\s*,\s*/);
        for (const name of fields) {
            if (req.headers[name] !== this._reqHeaders[name]) return false;
        }
        return true;
    }

    _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for (const name in inHeaders) {
            if (hopByHopHeaders[name]) continue;
            headers[name] = inHeaders[name];
        }
        // 9.1.  Connection
        if (inHeaders.connection) {
            const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
            for (const name of tokens) {
                delete headers[name];
            }
        }
        if (headers.warning) {
            const warnings = headers.warning.split(/,/).filter(warning => {
                return !/^\s*1[0-9][0-9]/.test(warning);
            });
            if (!warnings.length) {
                delete headers.warning;
            } else {
                headers.warning = warnings.join(',').trim();
            }
        }
        return headers;
    }

    responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();

        // A cache SHOULD generate 113 warning if it heuristically chose a freshness
        // lifetime greater than 24 hours and the response's age is greater than 24 hours.
        if (
            age > 3600 * 24 &&
            !this._hasExplicitExpiration() &&
            this.maxAge() > 3600 * 24
        ) {
            headers.warning =
                (headers.warning ? `${headers.warning}, ` : '') +
                '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
    }

    /**
     * Value of the Date response header or current time if Date was invalid
     * @return timestamp
     */
    date() {
        const serverDate = Date.parse(this._resHeaders.date);
        if (isFinite(serverDate)) {
            return serverDate;
        }
        return this._responseTime;
    }

    /**
     * Value of the Age header, in seconds, updated for the current time.
     * May be fractional.
     *
     * @return Number
     */
    age() {
        let age = this._ageValue();

        const residentTime = (this.now() - this._responseTime) / 1000;
        return age + residentTime;
    }

    _ageValue() {
        return toNumberOrZero(this._resHeaders.age);
    }

    /**
     * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
     *
     * For an up-to-date value, see `timeToLive()`.
     *
     * @return Number
     */
    maxAge() {
        if (!this.storable() || this._rescc['no-cache']) {
            return 0;
        }

        // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default
        // so this implementation requires explicit opt-in via public header
        if (
            this._isShared &&
            (this._resHeaders['set-cookie'] &&
                !this._rescc.public &&
                !this._rescc.immutable)
        ) {
            return 0;
        }

        if (this._resHeaders.vary === '*') {
            return 0;
        }

        if (this._isShared) {
            if (this._rescc['proxy-revalidate']) {
                return 0;
            }
            // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.
            if (this._rescc['s-maxage']) {
                return toNumberOrZero(this._rescc['s-maxage']);
            }
        }

        // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.
        if (this._rescc['max-age']) {
            return toNumberOrZero(this._rescc['max-age']);
        }

        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;

        const serverDate = this.date();
        if (this._resHeaders.expires) {
            const expires = Date.parse(this._resHeaders.expires);
            // A cache recipient MUST interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").
            if (Number.isNaN(expires) || expires < serverDate) {
                return 0;
            }
            return Math.max(defaultMinTtl, (expires - serverDate) / 1000);
        }

        if (this._resHeaders['last-modified']) {
            const lastModified = Date.parse(this._resHeaders['last-modified']);
            if (isFinite(lastModified) && serverDate > lastModified) {
                return Math.max(
                    defaultMinTtl,
                    ((serverDate - lastModified) / 1000) * this._cacheHeuristic
                );
            }
        }

        return defaultMinTtl;
    }

    timeToLive() {
        const age = this.maxAge() - this.age();
        const staleIfErrorAge = age + toNumberOrZero(this._rescc['stale-if-error']);
        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc['stale-while-revalidate']);
        return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000;
    }

    stale() {
        return this.maxAge() <= this.age();
    }

    _useStaleIfError() {
        return this.maxAge() + toNumberOrZero(this._rescc['stale-if-error']) > this.age();
    }

    useStaleWhileRevalidate() {
        return this.maxAge() + toNumberOrZero(this._rescc['stale-while-revalidate']) > this.age();
    }

    static fromObject(obj) {
        return new this(undefined, undefined, { _fromObject: obj });
    }

    _fromObject(obj) {
        if (this._responseTime) throw Error('Reinitialized');
        if (!obj || obj.v !== 1) throw Error('Invalid serialization');

        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl =
            obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
    }

    toObject() {
        return {
            v: 1,
            t: this._responseTime,
            sh: this._isShared,
            ch: this._cacheHeuristic,
            imm: this._immutableMinTtl,
            st: this._status,
            resh: this._resHeaders,
            rescc: this._rescc,
            m: this._method,
            u: this._url,
            h: this._host,
            a: this._noAuthorization,
            reqh: this._reqHeaders,
            reqcc: this._reqcc,
        };
    }

    /**
     * Headers for sending to the origin server to revalidate stale response.
     * Allows server to return 304 to allow reuse of the previous response.
     *
     * Hop by hop headers are always stripped.
     * Revalidation headers may be added or removed, depending on request.
     */
    revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);

        // This implementation does not understand range requests
        delete headers['if-range'];

        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
            // revalidation allowed via HEAD
            // not for the same resource, or wasn't allowed to be cached anyway
            delete headers['if-none-match'];
            delete headers['if-modified-since'];
            return headers;
        }

        /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */
        if (this._resHeaders.etag) {
            headers['if-none-match'] = headers['if-none-match']
                ? `${headers['if-none-match']}, ${this._resHeaders.etag}`
                : this._resHeaders.etag;
        }

        // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.
        const forbidsWeakValidators =
            headers['accept-ranges'] ||
            headers['if-match'] ||
            headers['if-unmodified-since'] ||
            (this._method && this._method != 'GET');

        /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
        Note: This implementation does not understand partial responses (206) */
        if (forbidsWeakValidators) {
            delete headers['if-modified-since'];

            if (headers['if-none-match']) {
                const etags = headers['if-none-match']
                    .split(/,/)
                    .filter(etag => {
                        return !/^\s*W\//.test(etag);
                    });
                if (!etags.length) {
                    delete headers['if-none-match'];
                } else {
                    headers['if-none-match'] = etags.join(',').trim();
                }
            }
        } else if (
            this._resHeaders['last-modified'] &&
            !headers['if-modified-since']
        ) {
            headers['if-modified-since'] = this._resHeaders['last-modified'];
        }

        return headers;
    }

    /**
     * Creates new CachePolicy with information combined from the previews response,
     * and the new revalidation response.
     *
     * Returns {policy, modified} where modified is a boolean indicating
     * whether the response body has been modified, and old cached body can't be used.
     *
     * @return {Object} {policy: CachePolicy, modified: Boolean}
     */
    revalidatedPolicy(request, response) {
        this._assertRequestHasHeaders(request);
        if(this._useStaleIfError() && isErrorResponse(response)) {  // I consider the revalidation request unsuccessful
          return {
            modified: false,
            matches: false,
            policy: this,
          };
        }
        if (!response || !response.headers) {
            throw Error('Response headers missing');
        }

        // These aren't going to be supported exactly, since one CachePolicy object
        // doesn't know about all the other cached objects.
        let matches = false;
        if (response.status !== undefined && response.status != 304) {
            matches = false;
        } else if (
            response.headers.etag &&
            !/^\s*W\//.test(response.headers.etag)
        ) {
            // "All of the stored responses with the same strong validator are selected.
            // If none of the stored responses contain the same strong validator,
            // then the cache MUST NOT use the new response to update any stored responses."
            matches =
                this._resHeaders.etag &&
                this._resHeaders.etag.replace(/^\s*W\//, '') ===
                    response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
            // "If the new response contains a weak validator and that validator corresponds
            // to one of the cache's stored responses,
            // then the most recent of those matching stored responses is selected for update."
            matches =
                this._resHeaders.etag.replace(/^\s*W\//, '') ===
                response.headers.etag.replace(/^\s*W\//, '');
        } else if (this._resHeaders['last-modified']) {
            matches =
                this._resHeaders['last-modified'] ===
                response.headers['last-modified'];
        } else {
            // If the new response does not include any form of validator (such as in the case where
            // a client generates an If-Modified-Since request from a source other than the Last-Modified
            // response header field), and there is only one stored response, and that stored response also
            // lacks a validator, then that stored response is selected for update.
            if (
                !this._resHeaders.etag &&
                !this._resHeaders['last-modified'] &&
                !response.headers.etag &&
                !response.headers['last-modified']
            ) {
                matches = true;
            }
        }

        if (!matches) {
            return {
                policy: new this.constructor(request, response),
                // Client receiving 304 without body, even if it's invalid/mismatched has no option
                // but to reuse a cached body. We don't have a good way to tell clients to do
                // error recovery in such case.
                modified: response.status != 304,
                matches: false,
            };
        }

        // use other header fields provided in the 304 (Not Modified) response to replace all instances
        // of the corresponding header fields in the stored response.
        const headers = {};
        for (const k in this._resHeaders) {
            headers[k] =
                k in response.headers && !excludedFromRevalidationUpdate[k]
                    ? response.headers[k]
                    : this._resHeaders[k];
        }

        const newResponse = Object.assign({}, response, {
            status: this._status,
            method: this._method,
            headers,
        });
        return {
            policy: new this.constructor(request, newResponse, {
                shared: this._isShared,
                cacheHeuristic: this._cacheHeuristic,
                immutableMinTimeToLive: this._immutableMinTtl,
            }),
            modified: false,
            matches: true,
        };
    }
};


/***/ }),

/***/ "./node_modules/http2-wrapper/source/agent.js":
/*!****************************************************!*\
  !*** ./node_modules/http2-wrapper/source/agent.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// See https://github.com/facebook/jest/issues/2549
// eslint-disable-next-line node/prefer-global/url
const {URL} = __webpack_require__(/*! url */ "url");
const EventEmitter = __webpack_require__(/*! events */ "events");
const tls = __webpack_require__(/*! tls */ "tls");
const http2 = __webpack_require__(/*! http2 */ "http2");
const QuickLRU = __webpack_require__(/*! quick-lru */ "./node_modules/quick-lru/index.js");
const delayAsyncDestroy = __webpack_require__(/*! ./utils/delay-async-destroy.js */ "./node_modules/http2-wrapper/source/utils/delay-async-destroy.js");

const kCurrentStreamCount = Symbol('currentStreamCount');
const kRequest = Symbol('request');
const kOriginSet = Symbol('cachedOriginSet');
const kGracefullyClosing = Symbol('gracefullyClosing');
const kLength = Symbol('length');

const nameKeys = [
	// Not an Agent option actually
	'createConnection',

	// `http2.connect()` options
	'maxDeflateDynamicTableSize',
	'maxSettings',
	'maxSessionMemory',
	'maxHeaderListPairs',
	'maxOutstandingPings',
	'maxReservedRemoteStreams',
	'maxSendHeaderBlockLength',
	'paddingStrategy',
	'peerMaxConcurrentStreams',
	'settings',

	// `tls.connect()` source options
	'family',
	'localAddress',
	'rejectUnauthorized',

	// `tls.connect()` secure context options
	'pskCallback',
	'minDHSize',

	// `tls.connect()` destination options
	// - `servername` is automatically validated, skip it
	// - `host` and `port` just describe the destination server,
	'path',
	'socket',

	// `tls.createSecureContext()` options
	'ca',
	'cert',
	'sigalgs',
	'ciphers',
	'clientCertEngine',
	'crl',
	'dhparam',
	'ecdhCurve',
	'honorCipherOrder',
	'key',
	'privateKeyEngine',
	'privateKeyIdentifier',
	'maxVersion',
	'minVersion',
	'pfx',
	'secureOptions',
	'secureProtocol',
	'sessionIdContext',
	'ticketKeys'
];

const getSortedIndex = (array, value, compare) => {
	let low = 0;
	let high = array.length;

	while (low < high) {
		const mid = (low + high) >>> 1;

		if (compare(array[mid], value)) {
			low = mid + 1;
		} else {
			high = mid;
		}
	}

	return low;
};

const compareSessions = (a, b) => a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;

// See https://tools.ietf.org/html/rfc8336
const closeCoveredSessions = (where, session) => {
	// Clients SHOULD NOT emit new requests on any connection whose Origin
	// Set is a proper subset of another connection's Origin Set, and they
	// SHOULD close it once all outstanding requests are satisfied.
	for (let index = 0; index < where.length; index++) {
		const coveredSession = where[index];

		if (
			// Unfortunately `.every()` returns true for an empty array
			coveredSession[kOriginSet].length > 0

			// The set is a proper subset when its length is less than the other set.
			&& coveredSession[kOriginSet].length < session[kOriginSet].length

			// And the other set includes all elements of the subset.
			&& coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin))

			// Makes sure that the session can handle all requests from the covered session.
			&& (coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount]) <= session.remoteSettings.maxConcurrentStreams
		) {
			// This allows pending requests to finish and prevents making new requests.
			gracefullyClose(coveredSession);
		}
	}
};

// This is basically inverted `closeCoveredSessions(...)`.
const closeSessionIfCovered = (where, coveredSession) => {
	for (let index = 0; index < where.length; index++) {
		const session = where[index];

		if (
			coveredSession[kOriginSet].length > 0
			&& coveredSession[kOriginSet].length < session[kOriginSet].length
			&& coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin))
			&& (coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount]) <= session.remoteSettings.maxConcurrentStreams
		) {
			gracefullyClose(coveredSession);

			return true;
		}
	}

	return false;
};

const gracefullyClose = session => {
	session[kGracefullyClosing] = true;

	if (session[kCurrentStreamCount] === 0) {
		session.close();
	}
};

class Agent extends EventEmitter {
	constructor({timeout = 0, maxSessions = Number.POSITIVE_INFINITY, maxEmptySessions = 10, maxCachedTlsSessions = 100} = {}) {
		super();

		// SESSIONS[NORMALIZED_OPTIONS] = [];
		this.sessions = {};

		// The queue for creating new sessions. It looks like this:
		// QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION
		//
		// It's faster when there are many origins. If there's only one, then QUEUE[`${options}:${origin}`] is faster.
		// I guess object creation / deletion is causing the slowdown.
		//
		// The entry function has `listeners`, `completed` and `destroyed` properties.
		// `listeners` is an array of objects containing `resolve` and `reject` functions.
		// `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.
		// `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.
		this.queue = {};

		// Each session will use this timeout value.
		this.timeout = timeout;

		// Max sessions in total
		this.maxSessions = maxSessions;

		// Max empty sessions in total
		this.maxEmptySessions = maxEmptySessions;

		this._emptySessionCount = 0;
		this._sessionCount = 0;

		// We don't support push streams by default.
		this.settings = {
			enablePush: false,
			initialWindowSize: 1024 * 1024 * 32 // 32MB, see https://github.com/nodejs/node/issues/38426
		};

		// Reusing TLS sessions increases performance.
		this.tlsSessionCache = new QuickLRU({maxSize: maxCachedTlsSessions});
	}

	get protocol() {
		return 'https:';
	}

	normalizeOptions(options) {
		let normalized = '';

		for (let index = 0; index < nameKeys.length; index++) {
			const key = nameKeys[index];

			normalized += ':';

			if (options && options[key] !== undefined) {
				normalized += options[key];
			}
		}

		return normalized;
	}

	_processQueue() {
		if (this._sessionCount >= this.maxSessions) {
			this.closeEmptySessions(this.maxSessions - this._sessionCount + 1);
			return;
		}

		// eslint-disable-next-line guard-for-in
		for (const normalizedOptions in this.queue) {
			// eslint-disable-next-line guard-for-in
			for (const normalizedOrigin in this.queue[normalizedOptions]) {
				const item = this.queue[normalizedOptions][normalizedOrigin];

				// The entry function can be run only once.
				if (!item.completed) {
					item.completed = true;

					item();
				}
			}
		}
	}

	_isBetterSession(thisStreamCount, thatStreamCount) {
		return thisStreamCount > thatStreamCount;
	}

	_accept(session, listeners, normalizedOrigin, options) {
		let index = 0;

		while (index < listeners.length && session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams) {
			// We assume `resolve(...)` calls `request(...)` *directly*,
			// otherwise the session will get overloaded.
			listeners[index].resolve(session);

			index++;
		}

		listeners.splice(0, index);

		if (listeners.length > 0) {
			this.getSession(normalizedOrigin, options, listeners);
			listeners.length = 0;
		}
	}

	getSession(origin, options, listeners) {
		return new Promise((resolve, reject) => {
			if (Array.isArray(listeners) && listeners.length > 0) {
				listeners = [...listeners];

				// Resolve the current promise ASAP, we're just moving the listeners.
				// They will be executed at a different time.
				resolve();
			} else {
				listeners = [{resolve, reject}];
			}

			try {
				// Parse origin
				if (typeof origin === 'string') {
					origin = new URL(origin);
				} else if (!(origin instanceof URL)) {
					throw new TypeError('The `origin` argument needs to be a string or an URL object');
				}

				if (options) {
					// Validate servername
					const {servername} = options;
					const {hostname} = origin;
					if (servername && hostname !== servername) {
						throw new Error(`Origin ${hostname} differs from servername ${servername}`);
					}
				}
			} catch (error) {
				for (let index = 0; index < listeners.length; index++) {
					listeners[index].reject(error);
				}

				return;
			}

			const normalizedOptions = this.normalizeOptions(options);
			const normalizedOrigin = origin.origin;

			if (normalizedOptions in this.sessions) {
				const sessions = this.sessions[normalizedOptions];

				let maxConcurrentStreams = -1;
				let currentStreamsCount = -1;
				let optimalSession;

				// We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.
				// Additionally, we are looking for session which has biggest current pending streams count.
				//
				// |------------| |------------| |------------| |------------|
				// | Session: A | | Session: B | | Session: C | | Session: D |
				// | Pending: 5 |-| Pending: 8 |-| Pending: 9 |-| Pending: 4 |
				// | Max:    10 | | Max:    10 | | Max:     9 | | Max:     5 |
				// |------------| |------------| |------------| |------------|
				//                     ^
				//                     |
				//     pick this one  --
				//
				for (let index = 0; index < sessions.length; index++) {
					const session = sessions[index];

					const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;

					if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
						break;
					}

					if (!session[kOriginSet].includes(normalizedOrigin)) {
						continue;
					}

					const sessionCurrentStreamsCount = session[kCurrentStreamCount];

					if (
						sessionCurrentStreamsCount >= sessionMaxConcurrentStreams
						|| session[kGracefullyClosing]
						// Unfortunately the `close` event isn't called immediately,
						// so `session.destroyed` is `true`, but `session.closed` is `false`.
						|| session.destroyed
					) {
						continue;
					}

					// We only need set this once.
					if (!optimalSession) {
						maxConcurrentStreams = sessionMaxConcurrentStreams;
					}

					// Either get the session which has biggest current stream count or the lowest.
					if (this._isBetterSession(sessionCurrentStreamsCount, currentStreamsCount)) {
						optimalSession = session;
						currentStreamsCount = sessionCurrentStreamsCount;
					}
				}

				if (optimalSession) {
					this._accept(optimalSession, listeners, normalizedOrigin, options);
					return;
				}
			}

			if (normalizedOptions in this.queue) {
				if (normalizedOrigin in this.queue[normalizedOptions]) {
					// There's already an item in the queue, just attach ourselves to it.
					this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);
					return;
				}
			} else {
				this.queue[normalizedOptions] = {
					[kLength]: 0
				};
			}

			// The entry must be removed from the queue IMMEDIATELY when:
			// 1. the session connects successfully,
			// 2. an error occurs.
			const removeFromQueue = () => {
				// Our entry can be replaced. We cannot remove the new one.
				if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
					delete this.queue[normalizedOptions][normalizedOrigin];

					if (--this.queue[normalizedOptions][kLength] === 0) {
						delete this.queue[normalizedOptions];
					}
				}
			};

			// The main logic is here
			const entry = async () => {
				this._sessionCount++;

				const name = `${normalizedOrigin}:${normalizedOptions}`;
				let receivedSettings = false;
				let socket;

				try {
					const computedOptions = {...options};

					if (computedOptions.settings === undefined) {
						computedOptions.settings = this.settings;
					}

					if (computedOptions.session === undefined) {
						computedOptions.session = this.tlsSessionCache.get(name);
					}

					const createConnection = computedOptions.createConnection || this.createConnection;

					// A hacky workaround to enable async `createConnection`
					socket = await createConnection.call(this, origin, computedOptions);
					computedOptions.createConnection = () => socket;

					const session = http2.connect(origin, computedOptions);
					session[kCurrentStreamCount] = 0;
					session[kGracefullyClosing] = false;

					// Node.js return https://false:443 instead of https://1.1.1.1:443
					const getOriginSet = () => {
						const {socket} = session;

						let originSet;
						if (socket.servername === false) {
							socket.servername = socket.remoteAddress;
							originSet = session.originSet;
							socket.servername = false;
						} else {
							originSet = session.originSet;
						}

						return originSet;
					};

					const isFree = () => session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams;

					session.socket.once('session', tlsSession => {
						this.tlsSessionCache.set(name, tlsSession);
					});

					session.once('error', error => {
						// Listeners are empty when the session successfully connected.
						for (let index = 0; index < listeners.length; index++) {
							listeners[index].reject(error);
						}

						// The connection got broken, purge the cache.
						this.tlsSessionCache.delete(name);
					});

					session.setTimeout(this.timeout, () => {
						// Terminates all streams owned by this session.
						session.destroy();
					});

					session.once('close', () => {
						this._sessionCount--;

						if (receivedSettings) {
							// Assumes session `close` is emitted after request `close`
							this._emptySessionCount--;

							// This cannot be moved to the stream logic,
							// because there may be a session that hadn't made a single request.
							const where = this.sessions[normalizedOptions];

							if (where.length === 1) {
								delete this.sessions[normalizedOptions];
							} else {
								where.splice(where.indexOf(session), 1);
							}
						} else {
							// Broken connection
							removeFromQueue();

							const error = new Error('Session closed without receiving a SETTINGS frame');
							error.code = 'HTTP2WRAPPER_NOSETTINGS';

							for (let index = 0; index < listeners.length; index++) {
								listeners[index].reject(error);
							}
						}

						// There may be another session awaiting.
						this._processQueue();
					});

					// Iterates over the queue and processes listeners.
					const processListeners = () => {
						const queue = this.queue[normalizedOptions];
						if (!queue) {
							return;
						}

						const originSet = session[kOriginSet];

						for (let index = 0; index < originSet.length; index++) {
							const origin = originSet[index];

							if (origin in queue) {
								const {listeners, completed} = queue[origin];

								let index = 0;

								// Prevents session overloading.
								while (index < listeners.length && isFree()) {
									// We assume `resolve(...)` calls `request(...)` *directly*,
									// otherwise the session will get overloaded.
									listeners[index].resolve(session);

									index++;
								}

								queue[origin].listeners.splice(0, index);

								if (queue[origin].listeners.length === 0 && !completed) {
									delete queue[origin];

									if (--queue[kLength] === 0) {
										delete this.queue[normalizedOptions];
										break;
									}
								}

								// We're no longer free, no point in continuing.
								if (!isFree()) {
									break;
								}
							}
						}
					};

					// The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.
					session.on('origin', () => {
						session[kOriginSet] = getOriginSet() || [];
						session[kGracefullyClosing] = false;
						closeSessionIfCovered(this.sessions[normalizedOptions], session);

						if (session[kGracefullyClosing] || !isFree()) {
							return;
						}

						processListeners();

						if (!isFree()) {
							return;
						}

						// Close covered sessions (if possible).
						closeCoveredSessions(this.sessions[normalizedOptions], session);
					});

					session.once('remoteSettings', () => {
						// The Agent could have been destroyed already.
						if (entry.destroyed) {
							const error = new Error('Agent has been destroyed');

							for (let index = 0; index < listeners.length; index++) {
								listeners[index].reject(error);
							}

							session.destroy();
							return;
						}

						// See https://github.com/nodejs/node/issues/38426
						if (session.setLocalWindowSize) {
							session.setLocalWindowSize(1024 * 1024 * 4); // 4 MB
						}

						session[kOriginSet] = getOriginSet() || [];

						if (session.socket.encrypted) {
							const mainOrigin = session[kOriginSet][0];
							if (mainOrigin !== normalizedOrigin) {
								const error = new Error(`Requested origin ${normalizedOrigin} does not match server ${mainOrigin}`);

								for (let index = 0; index < listeners.length; index++) {
									listeners[index].reject(error);
								}

								session.destroy();
								return;
							}
						}

						removeFromQueue();

						{
							const where = this.sessions;

							if (normalizedOptions in where) {
								const sessions = where[normalizedOptions];
								sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
							} else {
								where[normalizedOptions] = [session];
							}
						}

						receivedSettings = true;
						this._emptySessionCount++;

						this.emit('session', session);
						this._accept(session, listeners, normalizedOrigin, options);

						if (session[kCurrentStreamCount] === 0 && this._emptySessionCount > this.maxEmptySessions) {
							this.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions);
						}

						// `session.remoteSettings.maxConcurrentStreams` might get increased
						session.on('remoteSettings', () => {
							if (!isFree()) {
								return;
							}

							processListeners();

							if (!isFree()) {
								return;
							}

							// In case the Origin Set changes
							closeCoveredSessions(this.sessions[normalizedOptions], session);
						});
					});

					// Shim `session.request()` in order to catch all streams
					session[kRequest] = session.request;
					session.request = (headers, streamOptions) => {
						if (session[kGracefullyClosing]) {
							throw new Error('The session is gracefully closing. No new streams are allowed.');
						}

						const stream = session[kRequest](headers, streamOptions);

						// The process won't exit until the session is closed or all requests are gone.
						session.ref();

						if (session[kCurrentStreamCount]++ === 0) {
							this._emptySessionCount--;
						}

						stream.once('close', () => {
							if (--session[kCurrentStreamCount] === 0) {
								this._emptySessionCount++;
								session.unref();

								if (this._emptySessionCount > this.maxEmptySessions || session[kGracefullyClosing]) {
									session.close();
									return;
								}
							}

							if (session.destroyed || session.closed) {
								return;
							}

							if (isFree() && !closeSessionIfCovered(this.sessions[normalizedOptions], session)) {
								closeCoveredSessions(this.sessions[normalizedOptions], session);
								processListeners();

								if (session[kCurrentStreamCount] === 0) {
									this._processQueue();
								}
							}
						});

						return stream;
					};
				} catch (error) {
					removeFromQueue();
					this._sessionCount--;

					for (let index = 0; index < listeners.length; index++) {
						listeners[index].reject(error);
					}
				}
			};

			entry.listeners = listeners;
			entry.completed = false;
			entry.destroyed = false;

			this.queue[normalizedOptions][normalizedOrigin] = entry;
			this.queue[normalizedOptions][kLength]++;
			this._processQueue();
		});
	}

	request(origin, options, headers, streamOptions) {
		return new Promise((resolve, reject) => {
			this.getSession(origin, options, [{
				reject,
				resolve: session => {
					try {
						const stream = session.request(headers, streamOptions);

						// Do not throw before `request(...)` has been awaited
						delayAsyncDestroy(stream);

						resolve(stream);
					} catch (error) {
						reject(error);
					}
				}
			}]);
		});
	}

	async createConnection(origin, options) {
		return Agent.connect(origin, options);
	}

	static connect(origin, options) {
		options.ALPNProtocols = ['h2'];

		const port = origin.port || 443;
		const host = origin.hostname;

		if (typeof options.servername === 'undefined') {
			options.servername = host;
		}

		const socket = tls.connect(port, host, options);

		if (options.socket) {
			socket._peername = {
				family: undefined,
				address: undefined,
				port
			};
		}

		return socket;
	}

	closeEmptySessions(maxCount = Number.POSITIVE_INFINITY) {
		let closedCount = 0;

		const {sessions} = this;

		// eslint-disable-next-line guard-for-in
		for (const key in sessions) {
			const thisSessions = sessions[key];

			for (let index = 0; index < thisSessions.length; index++) {
				const session = thisSessions[index];

				if (session[kCurrentStreamCount] === 0) {
					closedCount++;
					session.close();

					if (closedCount >= maxCount) {
						return closedCount;
					}
				}
			}
		}

		return closedCount;
	}

	destroy(reason) {
		const {sessions, queue} = this;

		// eslint-disable-next-line guard-for-in
		for (const key in sessions) {
			const thisSessions = sessions[key];

			for (let index = 0; index < thisSessions.length; index++) {
				thisSessions[index].destroy(reason);
			}
		}

		// eslint-disable-next-line guard-for-in
		for (const normalizedOptions in queue) {
			const entries = queue[normalizedOptions];

			// eslint-disable-next-line guard-for-in
			for (const normalizedOrigin in entries) {
				entries[normalizedOrigin].destroyed = true;
			}
		}

		// New requests should NOT attach to destroyed sessions
		this.queue = {};
		this.tlsSessionCache.clear();
	}

	get emptySessionCount() {
		return this._emptySessionCount;
	}

	get pendingSessionCount() {
		return this._sessionCount - this._emptySessionCount;
	}

	get sessionCount() {
		return this._sessionCount;
	}
}

Agent.kCurrentStreamCount = kCurrentStreamCount;
Agent.kGracefullyClosing = kGracefullyClosing;

module.exports = {
	Agent,
	globalAgent: new Agent()
};


/***/ }),

/***/ "./node_modules/http2-wrapper/source/auto.js":
/*!***************************************************!*\
  !*** ./node_modules/http2-wrapper/source/auto.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// See https://github.com/facebook/jest/issues/2549
// eslint-disable-next-line node/prefer-global/url
const {URL, urlToHttpOptions} = __webpack_require__(/*! url */ "url");
const http = __webpack_require__(/*! http */ "http");
const https = __webpack_require__(/*! https */ "https");
const resolveALPN = __webpack_require__(/*! resolve-alpn */ "./node_modules/resolve-alpn/index.js");
const QuickLRU = __webpack_require__(/*! quick-lru */ "./node_modules/quick-lru/index.js");
const {Agent, globalAgent} = __webpack_require__(/*! ./agent.js */ "./node_modules/http2-wrapper/source/agent.js");
const Http2ClientRequest = __webpack_require__(/*! ./client-request.js */ "./node_modules/http2-wrapper/source/client-request.js");
const calculateServerName = __webpack_require__(/*! ./utils/calculate-server-name.js */ "./node_modules/http2-wrapper/source/utils/calculate-server-name.js");
const delayAsyncDestroy = __webpack_require__(/*! ./utils/delay-async-destroy.js */ "./node_modules/http2-wrapper/source/utils/delay-async-destroy.js");

const cache = new QuickLRU({maxSize: 100});
const queue = new Map();

const installSocket = (agent, socket, options) => {
	socket._httpMessage = {shouldKeepAlive: true};

	const onFree = () => {
		agent.emit('free', socket, options);
	};

	socket.on('free', onFree);

	const onClose = () => {
		agent.removeSocket(socket, options);
	};

	socket.on('close', onClose);

	const onTimeout = () => {
		const {freeSockets} = agent;

		for (const sockets of Object.values(freeSockets)) {
			if (sockets.includes(socket)) {
				socket.destroy();
				return;
			}
		}
	};

	socket.on('timeout', onTimeout);

	const onRemove = () => {
		agent.removeSocket(socket, options);
		socket.off('close', onClose);
		socket.off('free', onFree);
		socket.off('timeout', onTimeout);
		socket.off('agentRemove', onRemove);
	};

	socket.on('agentRemove', onRemove);

	agent.emit('free', socket, options);
};

const createResolveProtocol = (cache, queue = new Map(), connect = undefined) => {
	return async options => {
		const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;

		if (!cache.has(name)) {
			if (queue.has(name)) {
				const result = await queue.get(name);
				return {alpnProtocol: result.alpnProtocol};
			}

			const {path} = options;
			options.path = options.socketPath;

			const resultPromise = resolveALPN(options, connect);
			queue.set(name, resultPromise);

			try {
				const result = await resultPromise;

				cache.set(name, result.alpnProtocol);
				queue.delete(name);

				options.path = path;

				return result;
			} catch (error) {
				queue.delete(name);

				options.path = path;

				throw error;
			}
		}

		return {alpnProtocol: cache.get(name)};
	};
};

const defaultResolveProtocol = createResolveProtocol(cache, queue);

module.exports = async (input, options, callback) => {
	if (typeof input === 'string') {
		input = urlToHttpOptions(new URL(input));
	} else if (input instanceof URL) {
		input = urlToHttpOptions(input);
	} else {
		input = {...input};
	}

	if (typeof options === 'function' || options === undefined) {
		// (options, callback)
		callback = options;
		options = input;
	} else {
		// (input, options, callback)
		options = Object.assign(input, options);
	}

	options.ALPNProtocols = options.ALPNProtocols || ['h2', 'http/1.1'];

	if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
		throw new Error('The `ALPNProtocols` option must be an Array with at least one entry');
	}

	options.protocol = options.protocol || 'https:';
	const isHttps = options.protocol === 'https:';

	options.host = options.hostname || options.host || 'localhost';
	options.session = options.tlsSession;
	options.servername = options.servername || calculateServerName((options.headers && options.headers.host) || options.host);
	options.port = options.port || (isHttps ? 443 : 80);
	options._defaultAgent = isHttps ? https.globalAgent : http.globalAgent;

	const resolveProtocol = options.resolveProtocol || defaultResolveProtocol;

	// Note: We don't support `h2session` here

	let {agent} = options;
	if (agent !== undefined && agent !== false && agent.constructor.name !== 'Object') {
		throw new Error('The `options.agent` can be only an object `http`, `https` or `http2` properties');
	}

	if (isHttps) {
		options.resolveSocket = true;

		let {socket, alpnProtocol, timeout} = await resolveProtocol(options);

		if (timeout) {
			if (socket) {
				socket.destroy();
			}

			const error = new Error(`Timed out resolving ALPN: ${options.timeout} ms`);
			error.code = 'ETIMEDOUT';
			error.ms = options.timeout;

			throw error;
		}

		// We can't accept custom `createConnection` because the API is different for HTTP/2
		if (socket && options.createConnection) {
			socket.destroy();
			socket = undefined;
		}

		delete options.resolveSocket;

		const isHttp2 = alpnProtocol === 'h2';

		if (agent) {
			agent = isHttp2 ? agent.http2 : agent.https;
			options.agent = agent;
		}

		if (agent === undefined) {
			agent = isHttp2 ? globalAgent : https.globalAgent;
		}

		if (socket) {
			if (agent === false) {
				socket.destroy();
			} else {
				const defaultCreateConnection = (isHttp2 ? Agent : https.Agent).prototype.createConnection;

				if (agent.createConnection === defaultCreateConnection) {
					if (isHttp2) {
						options._reuseSocket = socket;
					} else {
						installSocket(agent, socket, options);
					}
				} else {
					socket.destroy();
				}
			}
		}

		if (isHttp2) {
			return delayAsyncDestroy(new Http2ClientRequest(options, callback));
		}
	} else if (agent) {
		options.agent = agent.http;
	}

	return delayAsyncDestroy(http.request(options, callback));
};

module.exports.protocolCache = cache;
module.exports.resolveProtocol = defaultResolveProtocol;
module.exports.createResolveProtocol = createResolveProtocol;


/***/ }),

/***/ "./node_modules/http2-wrapper/source/client-request.js":
/*!*************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/client-request.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// See https://github.com/facebook/jest/issues/2549
// eslint-disable-next-line node/prefer-global/url
const {URL, urlToHttpOptions} = __webpack_require__(/*! url */ "url");
const http2 = __webpack_require__(/*! http2 */ "http2");
const {Writable} = __webpack_require__(/*! stream */ "stream");
const {Agent, globalAgent} = __webpack_require__(/*! ./agent.js */ "./node_modules/http2-wrapper/source/agent.js");
const IncomingMessage = __webpack_require__(/*! ./incoming-message.js */ "./node_modules/http2-wrapper/source/incoming-message.js");
const proxyEvents = __webpack_require__(/*! ./utils/proxy-events.js */ "./node_modules/http2-wrapper/source/utils/proxy-events.js");
const {
	ERR_INVALID_ARG_TYPE,
	ERR_INVALID_PROTOCOL,
	ERR_HTTP_HEADERS_SENT
} = __webpack_require__(/*! ./utils/errors.js */ "./node_modules/http2-wrapper/source/utils/errors.js");
const validateHeaderName = __webpack_require__(/*! ./utils/validate-header-name.js */ "./node_modules/http2-wrapper/source/utils/validate-header-name.js");
const validateHeaderValue = __webpack_require__(/*! ./utils/validate-header-value.js */ "./node_modules/http2-wrapper/source/utils/validate-header-value.js");
const proxySocketHandler = __webpack_require__(/*! ./utils/proxy-socket-handler.js */ "./node_modules/http2-wrapper/source/utils/proxy-socket-handler.js");

const {
	HTTP2_HEADER_STATUS,
	HTTP2_HEADER_METHOD,
	HTTP2_HEADER_PATH,
	HTTP2_HEADER_AUTHORITY,
	HTTP2_METHOD_CONNECT
} = http2.constants;

const kHeaders = Symbol('headers');
const kOrigin = Symbol('origin');
const kSession = Symbol('session');
const kOptions = Symbol('options');
const kFlushedHeaders = Symbol('flushedHeaders');
const kJobs = Symbol('jobs');
const kPendingAgentPromise = Symbol('pendingAgentPromise');

class ClientRequest extends Writable {
	constructor(input, options, callback) {
		super({
			autoDestroy: false,
			emitClose: false
		});

		if (typeof input === 'string') {
			input = urlToHttpOptions(new URL(input));
		} else if (input instanceof URL) {
			input = urlToHttpOptions(input);
		} else {
			input = {...input};
		}

		if (typeof options === 'function' || options === undefined) {
			// (options, callback)
			callback = options;
			options = input;
		} else {
			// (input, options, callback)
			options = Object.assign(input, options);
		}

		if (options.h2session) {
			this[kSession] = options.h2session;

			if (this[kSession].destroyed) {
				throw new Error('The session has been closed already');
			}

			this.protocol = this[kSession].socket.encrypted ? 'https:' : 'http:';
		} else if (options.agent === false) {
			this.agent = new Agent({maxEmptySessions: 0});
		} else if (typeof options.agent === 'undefined' || options.agent === null) {
			this.agent = globalAgent;
		} else if (typeof options.agent.request === 'function') {
			this.agent = options.agent;
		} else {
			throw new ERR_INVALID_ARG_TYPE('options.agent', ['http2wrapper.Agent-like Object', 'undefined', 'false'], options.agent);
		}

		if (this.agent) {
			this.protocol = this.agent.protocol;
		}

		if (options.protocol && options.protocol !== this.protocol) {
			throw new ERR_INVALID_PROTOCOL(options.protocol, this.protocol);
		}

		if (!options.port) {
			options.port = options.defaultPort || (this.agent && this.agent.defaultPort) || 443;
		}

		options.host = options.hostname || options.host || 'localhost';

		// Unused
		delete options.hostname;

		const {timeout} = options;
		options.timeout = undefined;

		this[kHeaders] = Object.create(null);
		this[kJobs] = [];

		this[kPendingAgentPromise] = undefined;

		this.socket = null;
		this.connection = null;

		this.method = options.method || 'GET';

		if (!(this.method === 'CONNECT' && (options.path === '/' || options.path === undefined))) {
			this.path = options.path;
		}

		this.res = null;
		this.aborted = false;
		this.reusedSocket = false;

		const {headers} = options;
		if (headers) {
			// eslint-disable-next-line guard-for-in
			for (const header in headers) {
				this.setHeader(header, headers[header]);
			}
		}

		if (options.auth && !('authorization' in this[kHeaders])) {
			this[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');
		}

		options.session = options.tlsSession;
		options.path = options.socketPath;

		this[kOptions] = options;

		// Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.
		this[kOrigin] = new URL(`${this.protocol}//${options.servername || options.host}:${options.port}`);

		// A socket is being reused
		const reuseSocket = options._reuseSocket;
		if (reuseSocket) {
			options.createConnection = (...args) => {
				if (reuseSocket.destroyed) {
					return this.agent.createConnection(...args);
				}

				return reuseSocket;
			};

			// eslint-disable-next-line promise/prefer-await-to-then
			this.agent.getSession(this[kOrigin], this[kOptions]).catch(() => {});
		}

		if (timeout) {
			this.setTimeout(timeout);
		}

		if (callback) {
			this.once('response', callback);
		}

		this[kFlushedHeaders] = false;
	}

	get method() {
		return this[kHeaders][HTTP2_HEADER_METHOD];
	}

	set method(value) {
		if (value) {
			this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
		}
	}

	get path() {
		const header = this.method === 'CONNECT' ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;

		return this[kHeaders][header];
	}

	set path(value) {
		if (value) {
			const header = this.method === 'CONNECT' ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;

			this[kHeaders][header] = value;
		}
	}

	get host() {
		return this[kOrigin].hostname;
	}

	set host(_value) {
		// Do nothing as this is read only.
	}

	get _mustNotHaveABody() {
		return this.method === 'GET' || this.method === 'HEAD' || this.method === 'DELETE';
	}

	_write(chunk, encoding, callback) {
		// https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156
		if (this._mustNotHaveABody) {
			callback(new Error('The GET, HEAD and DELETE methods must NOT have a body'));
			/* istanbul ignore next: Node.js 12 throws directly */
			return;
		}

		this.flushHeaders();

		const callWrite = () => this._request.write(chunk, encoding, callback);
		if (this._request) {
			callWrite();
		} else {
			this[kJobs].push(callWrite);
		}
	}

	_final(callback) {
		this.flushHeaders();

		const callEnd = () => {
			// For GET, HEAD and DELETE and CONNECT
			if (this._mustNotHaveABody || this.method === 'CONNECT') {
				callback();
				return;
			}

			this._request.end(callback);
		};

		if (this._request) {
			callEnd();
		} else {
			this[kJobs].push(callEnd);
		}
	}

	abort() {
		if (this.res && this.res.complete) {
			return;
		}

		if (!this.aborted) {
			process.nextTick(() => this.emit('abort'));
		}

		this.aborted = true;

		this.destroy();
	}

	async _destroy(error, callback) {
		if (this.res) {
			this.res._dump();
		}

		if (this._request) {
			this._request.destroy();
		} else {
			process.nextTick(() => {
				this.emit('close');
			});
		}

		try {
			await this[kPendingAgentPromise];
		} catch (internalError) {
			if (this.aborted) {
				error = internalError;
			}
		}

		callback(error);
	}

	async flushHeaders() {
		if (this[kFlushedHeaders] || this.destroyed) {
			return;
		}

		this[kFlushedHeaders] = true;

		const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;

		// The real magic is here
		const onStream = stream => {
			this._request = stream;

			if (this.destroyed) {
				stream.destroy();
				return;
			}

			// Forwards `timeout`, `continue`, `close` and `error` events to this instance.
			if (!isConnectMethod) {
				// TODO: Should we proxy `close` here?
				proxyEvents(stream, this, ['timeout', 'continue']);
			}

			stream.once('error', error => {
				this.destroy(error);
			});

			stream.once('aborted', () => {
				const {res} = this;
				if (res) {
					res.aborted = true;
					res.emit('aborted');
					res.destroy();
				} else {
					this.destroy(new Error('The server aborted the HTTP/2 stream'));
				}
			});

			const onResponse = (headers, flags, rawHeaders) => {
				// If we were to emit raw request stream, it would be as fast as the native approach.
				// Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).
				const response = new IncomingMessage(this.socket, stream.readableHighWaterMark);
				this.res = response;

				// Undocumented, but it is used by `cacheable-request`
				response.url = `${this[kOrigin].origin}${this.path}`;

				response.req = this;
				response.statusCode = headers[HTTP2_HEADER_STATUS];
				response.headers = headers;
				response.rawHeaders = rawHeaders;

				response.once('end', () => {
					response.complete = true;

					// Has no effect, just be consistent with the Node.js behavior
					response.socket = null;
					response.connection = null;
				});

				if (isConnectMethod) {
					response.upgrade = true;

					// The HTTP1 API says the socket is detached here,
					// but we can't do that so we pass the original HTTP2 request.
					if (this.emit('connect', response, stream, Buffer.alloc(0))) {
						this.emit('close');
					} else {
						// No listeners attached, destroy the original request.
						stream.destroy();
					}
				} else {
					// Forwards data
					stream.on('data', chunk => {
						if (!response._dumped && !response.push(chunk)) {
							stream.pause();
						}
					});

					stream.once('end', () => {
						if (!this.aborted) {
							response.push(null);
						}
					});

					if (!this.emit('response', response)) {
						// No listeners attached, dump the response.
						response._dump();
					}
				}
			};

			// This event tells we are ready to listen for the data.
			stream.once('response', onResponse);

			// Emits `information` event
			stream.once('headers', headers => this.emit('information', {statusCode: headers[HTTP2_HEADER_STATUS]}));

			stream.once('trailers', (trailers, flags, rawTrailers) => {
				const {res} = this;

				// https://github.com/nodejs/node/issues/41251
				if (res === null) {
					onResponse(trailers, flags, rawTrailers);
					return;
				}

				// Assigns trailers to the response object.
				res.trailers = trailers;
				res.rawTrailers = rawTrailers;
			});

			stream.once('close', () => {
				const {aborted, res} = this;
				if (res) {
					if (aborted) {
						res.aborted = true;
						res.emit('aborted');
						res.destroy();
					}

					const finish = () => {
						res.emit('close');

						this.destroy();
						this.emit('close');
					};

					if (res.readable) {
						res.once('end', finish);
					} else {
						finish();
					}

					return;
				}

				if (!this.destroyed) {
					this.destroy(new Error('The HTTP/2 stream has been early terminated'));
					this.emit('close');
					return;
				}

				this.destroy();
				this.emit('close');
			});

			this.socket = new Proxy(stream, proxySocketHandler);

			for (const job of this[kJobs]) {
				job();
			}

			this[kJobs].length = 0;

			this.emit('socket', this.socket);
		};

		if (!(HTTP2_HEADER_AUTHORITY in this[kHeaders]) && !isConnectMethod) {
			this[kHeaders][HTTP2_HEADER_AUTHORITY] = this[kOrigin].host;
		}

		// Makes a HTTP2 request
		if (this[kSession]) {
			try {
				onStream(this[kSession].request(this[kHeaders]));
			} catch (error) {
				this.destroy(error);
			}
		} else {
			this.reusedSocket = true;

			try {
				const promise = this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]);
				this[kPendingAgentPromise] = promise;

				onStream(await promise);

				this[kPendingAgentPromise] = false;
			} catch (error) {
				this[kPendingAgentPromise] = false;

				this.destroy(error);
			}
		}
	}

	get connection() {
		return this.socket;
	}

	set connection(value) {
		this.socket = value;
	}

	getHeaderNames() {
		return Object.keys(this[kHeaders]);
	}

	hasHeader(name) {
		if (typeof name !== 'string') {
			throw new ERR_INVALID_ARG_TYPE('name', 'string', name);
		}

		return Boolean(this[kHeaders][name.toLowerCase()]);
	}

	getHeader(name) {
		if (typeof name !== 'string') {
			throw new ERR_INVALID_ARG_TYPE('name', 'string', name);
		}

		return this[kHeaders][name.toLowerCase()];
	}

	get headersSent() {
		return this[kFlushedHeaders];
	}

	removeHeader(name) {
		if (typeof name !== 'string') {
			throw new ERR_INVALID_ARG_TYPE('name', 'string', name);
		}

		if (this.headersSent) {
			throw new ERR_HTTP_HEADERS_SENT('remove');
		}

		delete this[kHeaders][name.toLowerCase()];
	}

	setHeader(name, value) {
		if (this.headersSent) {
			throw new ERR_HTTP_HEADERS_SENT('set');
		}

		validateHeaderName(name);
		validateHeaderValue(name, value);

		const lowercased = name.toLowerCase();

		if (lowercased === 'connection') {
			if (value.toLowerCase() === 'keep-alive') {
				return;
			}

			throw new Error(`Invalid 'connection' header: ${value}`);
		}

		if (lowercased === 'host' && this.method === 'CONNECT') {
			this[kHeaders][HTTP2_HEADER_AUTHORITY] = value;
		} else {
			this[kHeaders][lowercased] = value;
		}
	}

	setNoDelay() {
		// HTTP2 sockets cannot be malformed, do nothing.
	}

	setSocketKeepAlive() {
		// HTTP2 sockets cannot be malformed, do nothing.
	}

	setTimeout(ms, callback) {
		const applyTimeout = () => this._request.setTimeout(ms, callback);

		if (this._request) {
			applyTimeout();
		} else {
			this[kJobs].push(applyTimeout);
		}

		return this;
	}

	get maxHeadersCount() {
		if (!this.destroyed && this._request) {
			return this._request.session.localSettings.maxHeaderListSize;
		}

		return undefined;
	}

	set maxHeadersCount(_value) {
		// Updating HTTP2 settings would affect all requests, do nothing.
	}
}

module.exports = ClientRequest;


/***/ }),

/***/ "./node_modules/http2-wrapper/source/incoming-message.js":
/*!***************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/incoming-message.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {Readable} = __webpack_require__(/*! stream */ "stream");

class IncomingMessage extends Readable {
	constructor(socket, highWaterMark) {
		super({
			emitClose: false,
			autoDestroy: true,
			highWaterMark
		});

		this.statusCode = null;
		this.statusMessage = '';
		this.httpVersion = '2.0';
		this.httpVersionMajor = 2;
		this.httpVersionMinor = 0;
		this.headers = {};
		this.trailers = {};
		this.req = null;

		this.aborted = false;
		this.complete = false;
		this.upgrade = null;

		this.rawHeaders = [];
		this.rawTrailers = [];

		this.socket = socket;

		this._dumped = false;
	}

	get connection() {
		return this.socket;
	}

	set connection(value) {
		this.socket = value;
	}

	_destroy(error, callback) {
		if (!this.readableEnded) {
			this.aborted = true;
		}

		// See https://github.com/nodejs/node/issues/35303
		callback();

		this.req._request.destroy(error);
	}

	setTimeout(ms, callback) {
		this.req.setTimeout(ms, callback);
		return this;
	}

	_dump() {
		if (!this._dumped) {
			this._dumped = true;

			this.removeAllListeners('data');
			this.resume();
		}
	}

	_read() {
		if (this.req) {
			this.req._request.resume();
		}
	}
}

module.exports = IncomingMessage;


/***/ }),

/***/ "./node_modules/http2-wrapper/source/index.js":
/*!****************************************************!*\
  !*** ./node_modules/http2-wrapper/source/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const http2 = __webpack_require__(/*! http2 */ "http2");
const {
	Agent,
	globalAgent
} = __webpack_require__(/*! ./agent.js */ "./node_modules/http2-wrapper/source/agent.js");
const ClientRequest = __webpack_require__(/*! ./client-request.js */ "./node_modules/http2-wrapper/source/client-request.js");
const IncomingMessage = __webpack_require__(/*! ./incoming-message.js */ "./node_modules/http2-wrapper/source/incoming-message.js");
const auto = __webpack_require__(/*! ./auto.js */ "./node_modules/http2-wrapper/source/auto.js");
const {
	HttpOverHttp2,
	HttpsOverHttp2
} = __webpack_require__(/*! ./proxies/h1-over-h2.js */ "./node_modules/http2-wrapper/source/proxies/h1-over-h2.js");
const Http2OverHttp2 = __webpack_require__(/*! ./proxies/h2-over-h2.js */ "./node_modules/http2-wrapper/source/proxies/h2-over-h2.js");
const {
	Http2OverHttp,
	Http2OverHttps
} = __webpack_require__(/*! ./proxies/h2-over-h1.js */ "./node_modules/http2-wrapper/source/proxies/h2-over-h1.js");
const validateHeaderName = __webpack_require__(/*! ./utils/validate-header-name.js */ "./node_modules/http2-wrapper/source/utils/validate-header-name.js");
const validateHeaderValue = __webpack_require__(/*! ./utils/validate-header-value.js */ "./node_modules/http2-wrapper/source/utils/validate-header-value.js");

const request = (url, options, callback) => new ClientRequest(url, options, callback);

const get = (url, options, callback) => {
	// eslint-disable-next-line unicorn/prevent-abbreviations
	const req = new ClientRequest(url, options, callback);
	req.end();

	return req;
};

module.exports = {
	...http2,
	ClientRequest,
	IncomingMessage,
	Agent,
	globalAgent,
	request,
	get,
	auto,
	proxies: {
		HttpOverHttp2,
		HttpsOverHttp2,
		Http2OverHttp2,
		Http2OverHttp,
		Http2OverHttps
	},
	validateHeaderName,
	validateHeaderValue
};


/***/ }),

/***/ "./node_modules/http2-wrapper/source/proxies/get-auth-headers.js":
/*!***********************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/proxies/get-auth-headers.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";


module.exports = self => {
	const {username, password} = self.proxyOptions.url;

	if (username || password) {
		const data = `${username}:${password}`;
		const authorization = `Basic ${Buffer.from(data).toString('base64')}`;

		return {
			'proxy-authorization': authorization,
			authorization
		};
	}

	return {};
};


/***/ }),

/***/ "./node_modules/http2-wrapper/source/proxies/h1-over-h2.js":
/*!*****************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/proxies/h1-over-h2.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const tls = __webpack_require__(/*! tls */ "tls");
const http = __webpack_require__(/*! http */ "http");
const https = __webpack_require__(/*! https */ "https");
const JSStreamSocket = __webpack_require__(/*! ../utils/js-stream-socket.js */ "./node_modules/http2-wrapper/source/utils/js-stream-socket.js");
const {globalAgent} = __webpack_require__(/*! ../agent.js */ "./node_modules/http2-wrapper/source/agent.js");
const UnexpectedStatusCodeError = __webpack_require__(/*! ./unexpected-status-code-error.js */ "./node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js");
const initialize = __webpack_require__(/*! ./initialize.js */ "./node_modules/http2-wrapper/source/proxies/initialize.js");
const getAuthorizationHeaders = __webpack_require__(/*! ./get-auth-headers.js */ "./node_modules/http2-wrapper/source/proxies/get-auth-headers.js");

const createConnection = (self, options, callback) => {
	(async () => {
		try {
			const {proxyOptions} = self;
			const {url, headers, raw} = proxyOptions;

			const stream = await globalAgent.request(url, proxyOptions, {
				...getAuthorizationHeaders(self),
				...headers,
				':method': 'CONNECT',
				':authority': `${options.host}:${options.port}`
			});

			stream.once('error', callback);
			stream.once('response', headers => {
				const statusCode = headers[':status'];

				if (statusCode !== 200) {
					callback(new UnexpectedStatusCodeError(statusCode, ''));
					return;
				}

				const encrypted = self instanceof https.Agent;

				if (raw && encrypted) {
					options.socket = stream;
					const secureStream = tls.connect(options);

					secureStream.once('close', () => {
						stream.destroy();
					});

					callback(null, secureStream);
					return;
				}

				const socket = new JSStreamSocket(stream);
				socket.encrypted = false;
				socket._handle.getpeername = out => {
					out.family = undefined;
					out.address = undefined;
					out.port = undefined;
				};

				callback(null, socket);
			});
		} catch (error) {
			callback(error);
		}
	})();
};

class HttpOverHttp2 extends http.Agent {
	constructor(options) {
		super(options);

		initialize(this, options.proxyOptions);
	}

	createConnection(options, callback) {
		createConnection(this, options, callback);
	}
}

class HttpsOverHttp2 extends https.Agent {
	constructor(options) {
		super(options);

		initialize(this, options.proxyOptions);
	}

	createConnection(options, callback) {
		createConnection(this, options, callback);
	}
}

module.exports = {
	HttpOverHttp2,
	HttpsOverHttp2
};


/***/ }),

/***/ "./node_modules/http2-wrapper/source/proxies/h2-over-h1.js":
/*!*****************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/proxies/h2-over-h1.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const http = __webpack_require__(/*! http */ "http");
const https = __webpack_require__(/*! https */ "https");
const Http2OverHttpX = __webpack_require__(/*! ./h2-over-hx.js */ "./node_modules/http2-wrapper/source/proxies/h2-over-hx.js");
const getAuthorizationHeaders = __webpack_require__(/*! ./get-auth-headers.js */ "./node_modules/http2-wrapper/source/proxies/get-auth-headers.js");

const getStream = request => new Promise((resolve, reject) => {
	const onConnect = (response, socket, head) => {
		socket.unshift(head);

		request.off('error', reject);
		resolve([socket, response.statusCode, response.statusMessage]);
	};

	request.once('error', reject);
	request.once('connect', onConnect);
});

class Http2OverHttp extends Http2OverHttpX {
	async _getProxyStream(authority) {
		const {proxyOptions} = this;
		const {url, headers} = this.proxyOptions;

		const network = url.protocol === 'https:' ? https : http;

		// `new URL('https://localhost/httpbin.org:443')` results in
		// a `/httpbin.org:443` path, which has an invalid leading slash.
		const request = network.request({
			...proxyOptions,
			hostname: url.hostname,
			port: url.port,
			path: authority,
			headers: {
				...getAuthorizationHeaders(this),
				...headers,
				host: authority
			},
			method: 'CONNECT'
		}).end();

		return getStream(request);
	}
}

module.exports = {
	Http2OverHttp,
	Http2OverHttps: Http2OverHttp
};


/***/ }),

/***/ "./node_modules/http2-wrapper/source/proxies/h2-over-h2.js":
/*!*****************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/proxies/h2-over-h2.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {globalAgent} = __webpack_require__(/*! ../agent.js */ "./node_modules/http2-wrapper/source/agent.js");
const Http2OverHttpX = __webpack_require__(/*! ./h2-over-hx.js */ "./node_modules/http2-wrapper/source/proxies/h2-over-hx.js");
const getAuthorizationHeaders = __webpack_require__(/*! ./get-auth-headers.js */ "./node_modules/http2-wrapper/source/proxies/get-auth-headers.js");

const getStatusCode = stream => new Promise((resolve, reject) => {
	stream.once('error', reject);
	stream.once('response', headers => {
		stream.off('error', reject);
		resolve(headers[':status']);
	});
});

class Http2OverHttp2 extends Http2OverHttpX {
	async _getProxyStream(authority) {
		const {proxyOptions} = this;

		const headers = {
			...getAuthorizationHeaders(this),
			...proxyOptions.headers,
			':method': 'CONNECT',
			':authority': authority
		};

		const stream = await globalAgent.request(proxyOptions.url, proxyOptions, headers);
		const statusCode = await getStatusCode(stream);

		return [stream, statusCode, ''];
	}
}

module.exports = Http2OverHttp2;


/***/ }),

/***/ "./node_modules/http2-wrapper/source/proxies/h2-over-hx.js":
/*!*****************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/proxies/h2-over-hx.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {Agent} = __webpack_require__(/*! ../agent.js */ "./node_modules/http2-wrapper/source/agent.js");
const JSStreamSocket = __webpack_require__(/*! ../utils/js-stream-socket.js */ "./node_modules/http2-wrapper/source/utils/js-stream-socket.js");
const UnexpectedStatusCodeError = __webpack_require__(/*! ./unexpected-status-code-error.js */ "./node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js");
const initialize = __webpack_require__(/*! ./initialize.js */ "./node_modules/http2-wrapper/source/proxies/initialize.js");

class Http2OverHttpX extends Agent {
	constructor(options) {
		super(options);

		initialize(this, options.proxyOptions);
	}

	async createConnection(origin, options) {
		const authority = `${origin.hostname}:${origin.port || 443}`;

		const [stream, statusCode, statusMessage] = await this._getProxyStream(authority);
		if (statusCode !== 200) {
			throw new UnexpectedStatusCodeError(statusCode, statusMessage);
		}

		if (this.proxyOptions.raw) {
			options.socket = stream;
		} else {
			const socket = new JSStreamSocket(stream);
			socket.encrypted = false;
			socket._handle.getpeername = out => {
				out.family = undefined;
				out.address = undefined;
				out.port = undefined;
			};

			return socket;
		}

		return super.createConnection(origin, options);
	}
}

module.exports = Http2OverHttpX;


/***/ }),

/***/ "./node_modules/http2-wrapper/source/proxies/initialize.js":
/*!*****************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/proxies/initialize.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// See https://github.com/facebook/jest/issues/2549
// eslint-disable-next-line node/prefer-global/url
const {URL} = __webpack_require__(/*! url */ "url");
const checkType = __webpack_require__(/*! ../utils/check-type.js */ "./node_modules/http2-wrapper/source/utils/check-type.js");

module.exports = (self, proxyOptions) => {
	checkType('proxyOptions', proxyOptions, ['object']);
	checkType('proxyOptions.headers', proxyOptions.headers, ['object', 'undefined']);
	checkType('proxyOptions.raw', proxyOptions.raw, ['boolean', 'undefined']);
	checkType('proxyOptions.url', proxyOptions.url, [URL, 'string']);

	const url = new URL(proxyOptions.url);

	self.proxyOptions = {
		raw: true,
		...proxyOptions,
		headers: {...proxyOptions.headers},
		url
	};
};


/***/ }),

/***/ "./node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";


class UnexpectedStatusCodeError extends Error {
	constructor(statusCode, statusMessage = '') {
		super(`The proxy server rejected the request with status code ${statusCode} (${statusMessage || 'empty status message'})`);
		this.statusCode = statusCode;
		this.statusMessage = statusMessage;
	}
}

module.exports = UnexpectedStatusCodeError;


/***/ }),

/***/ "./node_modules/http2-wrapper/source/utils/calculate-server-name.js":
/*!**************************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/utils/calculate-server-name.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {isIP} = __webpack_require__(/*! net */ "net");
const assert = __webpack_require__(/*! assert */ "assert");

const getHost = host => {
	if (host[0] === '[') {
		const idx = host.indexOf(']');

		assert(idx !== -1);
		return host.slice(1, idx);
	}

	const idx = host.indexOf(':');
	if (idx === -1) {
		return host;
	}

	return host.slice(0, idx);
};

module.exports = host => {
	const servername = getHost(host);

	if (isIP(servername)) {
		return '';
	}

	return servername;
};


/***/ }),

/***/ "./node_modules/http2-wrapper/source/utils/check-type.js":
/*!***************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/utils/check-type.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


const checkType = (name, value, types) => {
	const valid = types.some(type => {
		const typeofType = typeof type;
		if (typeofType === 'string') {
			return typeof value === type;
		}

		return value instanceof type;
	});

	if (!valid) {
		const names = types.map(type => typeof type === 'string' ? type : type.name);

		throw new TypeError(`Expected '${name}' to be a type of ${names.join(' or ')}, got ${typeof value}`);
	}
};

module.exports = checkType;


/***/ }),

/***/ "./node_modules/http2-wrapper/source/utils/delay-async-destroy.js":
/*!************************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/utils/delay-async-destroy.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = stream => {
	if (stream.listenerCount('error') !== 0) {
		return stream;
	}

	stream.__destroy = stream._destroy;
	stream._destroy = (...args) => {
		const callback = args.pop();

		stream.__destroy(...args, async error => {
			await Promise.resolve();
			callback(error);
		});
	};

	const onError = error => {
		// eslint-disable-next-line promise/prefer-await-to-then
		Promise.resolve().then(() => {
			stream.emit('error', error);
		});
	};

	stream.once('error', onError);

	// eslint-disable-next-line promise/prefer-await-to-then
	Promise.resolve().then(() => {
		stream.off('error', onError);
	});

	return stream;
};


/***/ }),

/***/ "./node_modules/http2-wrapper/source/utils/errors.js":
/*!***********************************************************!*\
  !*** ./node_modules/http2-wrapper/source/utils/errors.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";

/* istanbul ignore file: https://github.com/nodejs/node/blob/master/lib/internal/errors.js */

const makeError = (Base, key, getMessage) => {
	module.exports[key] = class NodeError extends Base {
		constructor(...args) {
			super(typeof getMessage === 'string' ? getMessage : getMessage(args));
			this.name = `${super.name} [${key}]`;
			this.code = key;
		}
	};
};

makeError(TypeError, 'ERR_INVALID_ARG_TYPE', args => {
	const type = args[0].includes('.') ? 'property' : 'argument';

	let valid = args[1];
	const isManyTypes = Array.isArray(valid);

	if (isManyTypes) {
		valid = `${valid.slice(0, -1).join(', ')} or ${valid.slice(-1)}`;
	}

	return `The "${args[0]}" ${type} must be ${isManyTypes ? 'one of' : 'of'} type ${valid}. Received ${typeof args[2]}`;
});

makeError(TypeError, 'ERR_INVALID_PROTOCOL', args =>
	`Protocol "${args[0]}" not supported. Expected "${args[1]}"`
);

makeError(Error, 'ERR_HTTP_HEADERS_SENT', args =>
	`Cannot ${args[0]} headers after they are sent to the client`
);

makeError(TypeError, 'ERR_INVALID_HTTP_TOKEN', args =>
	`${args[0]} must be a valid HTTP token [${args[1]}]`
);

makeError(TypeError, 'ERR_HTTP_INVALID_HEADER_VALUE', args =>
	`Invalid value "${args[0]} for header "${args[1]}"`
);

makeError(TypeError, 'ERR_INVALID_CHAR', args =>
	`Invalid character in ${args[0]} [${args[1]}]`
);

makeError(
	Error,
	'ERR_HTTP2_NO_SOCKET_MANIPULATION',
	'HTTP/2 sockets should not be directly manipulated (e.g. read and written)'
);


/***/ }),

/***/ "./node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = header => {
	switch (header) {
		case ':method':
		case ':scheme':
		case ':authority':
		case ':path':
			return true;
		default:
			return false;
	}
};


/***/ }),

/***/ "./node_modules/http2-wrapper/source/utils/js-stream-socket.js":
/*!*********************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/utils/js-stream-socket.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stream = __webpack_require__(/*! stream */ "stream");
const tls = __webpack_require__(/*! tls */ "tls");

// Really awesome hack.
const JSStreamSocket = (new tls.TLSSocket(new stream.PassThrough()))._handle._parentWrap.constructor;

module.exports = JSStreamSocket;


/***/ }),

/***/ "./node_modules/http2-wrapper/source/utils/proxy-events.js":
/*!*****************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/utils/proxy-events.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (from, to, events) => {
	for (const event of events) {
		from.on(event, (...args) => to.emit(event, ...args));
	}
};


/***/ }),

/***/ "./node_modules/http2-wrapper/source/utils/proxy-socket-handler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/utils/proxy-socket-handler.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {ERR_HTTP2_NO_SOCKET_MANIPULATION} = __webpack_require__(/*! ./errors.js */ "./node_modules/http2-wrapper/source/utils/errors.js");

/* istanbul ignore file */
/* https://github.com/nodejs/node/blob/6eec858f34a40ffa489c1ec54bb24da72a28c781/lib/internal/http2/compat.js#L195-L272 */

const proxySocketHandler = {
	has(stream, property) {
		// Replaced [kSocket] with .socket
		const reference = stream.session === undefined ? stream : stream.session.socket;
		return (property in stream) || (property in reference);
	},

	get(stream, property) {
		switch (property) {
			case 'on':
			case 'once':
			case 'end':
			case 'emit':
			case 'destroy':
				return stream[property].bind(stream);
			case 'writable':
			case 'destroyed':
				return stream[property];
			case 'readable':
				if (stream.destroyed) {
					return false;
				}

				return stream.readable;
			case 'setTimeout': {
				const {session} = stream;
				if (session !== undefined) {
					return session.setTimeout.bind(session);
				}

				return stream.setTimeout.bind(stream);
			}

			case 'write':
			case 'read':
			case 'pause':
			case 'resume':
				throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();
			default: {
				// Replaced [kSocket] with .socket
				const reference = stream.session === undefined ? stream : stream.session.socket;
				const value = reference[property];

				return typeof value === 'function' ? value.bind(reference) : value;
			}
		}
	},

	getPrototypeOf(stream) {
		if (stream.session !== undefined) {
			// Replaced [kSocket] with .socket
			return Reflect.getPrototypeOf(stream.session.socket);
		}

		return Reflect.getPrototypeOf(stream);
	},

	set(stream, property, value) {
		switch (property) {
			case 'writable':
			case 'readable':
			case 'destroyed':
			case 'on':
			case 'once':
			case 'end':
			case 'emit':
			case 'destroy':
				stream[property] = value;
				return true;
			case 'setTimeout': {
				const {session} = stream;
				if (session === undefined) {
					stream.setTimeout = value;
				} else {
					session.setTimeout = value;
				}

				return true;
			}

			case 'write':
			case 'read':
			case 'pause':
			case 'resume':
				throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();
			default: {
				// Replaced [kSocket] with .socket
				const reference = stream.session === undefined ? stream : stream.session.socket;
				reference[property] = value;
				return true;
			}
		}
	}
};

module.exports = proxySocketHandler;


/***/ }),

/***/ "./node_modules/http2-wrapper/source/utils/validate-header-name.js":
/*!*************************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/utils/validate-header-name.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {ERR_INVALID_HTTP_TOKEN} = __webpack_require__(/*! ./errors.js */ "./node_modules/http2-wrapper/source/utils/errors.js");
const isRequestPseudoHeader = __webpack_require__(/*! ./is-request-pseudo-header.js */ "./node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js");

const isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;

module.exports = name => {
	if (typeof name !== 'string' || (!isValidHttpToken.test(name) && !isRequestPseudoHeader(name))) {
		throw new ERR_INVALID_HTTP_TOKEN('Header name', name);
	}
};


/***/ }),

/***/ "./node_modules/http2-wrapper/source/utils/validate-header-value.js":
/*!**************************************************************************!*\
  !*** ./node_modules/http2-wrapper/source/utils/validate-header-value.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {
	ERR_HTTP_INVALID_HEADER_VALUE,
	ERR_INVALID_CHAR
} = __webpack_require__(/*! ./errors.js */ "./node_modules/http2-wrapper/source/utils/errors.js");

const isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;

module.exports = (name, value) => {
	if (typeof value === 'undefined') {
		throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
	}

	if (isInvalidHeaderValue.test(value)) {
		throw new ERR_INVALID_CHAR('header content', name);
	}
};


/***/ }),

/***/ "./node_modules/json-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/json-buffer/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

//TODO: handle reviver/dehydrate function like normal
//and handle indentation, like normal.
//if anyone needs this... please send pull request.

exports.stringify = function stringify (o) {
  if('undefined' == typeof o) return o

  if(o && Buffer.isBuffer(o))
    return JSON.stringify(':base64:' + o.toString('base64'))

  if(o && o.toJSON)
    o =  o.toJSON()

  if(o && 'object' === typeof o) {
    var s = ''
    var array = Array.isArray(o)
    s = array ? '[' : '{'
    var first = true

    for(var k in o) {
      var ignore = 'function' == typeof o[k] || (!array && 'undefined' === typeof o[k])
      if(Object.hasOwnProperty.call(o, k) && !ignore) {
        if(!first)
          s += ','
        first = false
        if (array) {
          if(o[k] == undefined)
            s += 'null'
          else
            s += stringify(o[k])
        } else if (o[k] !== void(0)) {
          s += stringify(k) + ':' + stringify(o[k])
        }
      }
    }

    s += array ? ']' : '}'

    return s
  } else if ('string' === typeof o) {
    return JSON.stringify(/^:/.test(o) ? ':' + o : o)
  } else if ('undefined' === typeof o) {
    return 'null';
  } else
    return JSON.stringify(o)
}

exports.parse = function (s) {
  return JSON.parse(s, function (key, value) {
    if('string' === typeof value) {
      if(/^:base64:/.test(value))
        return Buffer.from(value.substring(8), 'base64')
      else
        return /^:/.test(value) ? value.substring(1) : value 
    }
    return value
  })
}


/***/ }),

/***/ "./node_modules/keyv/src/index.js":
/*!****************************************!*\
  !*** ./node_modules/keyv/src/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "events");
const JSONB = __webpack_require__(/*! json-buffer */ "./node_modules/json-buffer/index.js");

const loadStore = options => {
	const adapters = {
		redis: '@keyv/redis',
		rediss: '@keyv/redis',
		mongodb: '@keyv/mongo',
		mongo: '@keyv/mongo',
		sqlite: '@keyv/sqlite',
		postgresql: '@keyv/postgres',
		postgres: '@keyv/postgres',
		mysql: '@keyv/mysql',
		etcd: '@keyv/etcd',
		offline: '@keyv/offline',
		tiered: '@keyv/tiered',
	};
	if (options.adapter || options.uri) {
		const adapter = options.adapter || /^[^:+]*/.exec(options.uri)[0];
		return new (__webpack_require__("./node_modules/keyv/src sync recursive")(adapters[adapter]))(options);
	}

	return new Map();
};

const iterableAdapters = [
	'sqlite',
	'postgres',
	'mysql',
	'mongo',
	'redis',
	'tiered',
];

class Keyv extends EventEmitter {
	constructor(uri, {emitErrors = true, ...options} = {}) {
		super();
		this.opts = {
			namespace: 'keyv',
			serialize: JSONB.stringify,
			deserialize: JSONB.parse,
			...((typeof uri === 'string') ? {uri} : uri),
			...options,
		};

		if (!this.opts.store) {
			const adapterOptions = {...this.opts};
			this.opts.store = loadStore(adapterOptions);
		}

		if (this.opts.compression) {
			const compression = this.opts.compression;
			this.opts.serialize = compression.serialize.bind(compression);
			this.opts.deserialize = compression.deserialize.bind(compression);
		}

		if (typeof this.opts.store.on === 'function' && emitErrors) {
			this.opts.store.on('error', error => this.emit('error', error));
		}

		this.opts.store.namespace = this.opts.namespace;

		const generateIterator = iterator => async function * () {
			for await (const [key, raw] of typeof iterator === 'function'
				? iterator(this.opts.store.namespace)
				: iterator) {
				const data = this.opts.deserialize(raw);
				if (this.opts.store.namespace && !key.includes(this.opts.store.namespace)) {
					continue;
				}

				if (typeof data.expires === 'number' && Date.now() > data.expires) {
					this.delete(key);
					continue;
				}

				yield [this._getKeyUnprefix(key), data.value];
			}
		};

		// Attach iterators
		if (typeof this.opts.store[Symbol.iterator] === 'function' && this.opts.store instanceof Map) {
			this.iterator = generateIterator(this.opts.store);
		} else if (typeof this.opts.store.iterator === 'function' && this.opts.store.opts
			&& this._checkIterableAdaptar()) {
			this.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store));
		}
	}

	_checkIterableAdaptar() {
		return iterableAdapters.includes(this.opts.store.opts.dialect)
			|| iterableAdapters.findIndex(element => this.opts.store.opts.url.includes(element)) >= 0;
	}

	_getKeyPrefix(key) {
		return `${this.opts.namespace}:${key}`;
	}

	_getKeyPrefixArray(keys) {
		return keys.map(key => `${this.opts.namespace}:${key}`);
	}

	_getKeyUnprefix(key) {
		return key
			.split(':')
			.splice(1)
			.join(':');
	}

	get(key, options) {
		const {store} = this.opts;
		const isArray = Array.isArray(key);
		const keyPrefixed = isArray ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);
		if (isArray && store.getMany === undefined) {
			const promises = [];
			for (const key of keyPrefixed) {
				promises.push(Promise.resolve()
					.then(() => store.get(key))
					.then(data => (typeof data === 'string') ? this.opts.deserialize(data) : (this.opts.compression ? this.opts.deserialize(data) : data))
					.then(data => {
						if (data === undefined || data === null) {
							return undefined;
						}

						if (typeof data.expires === 'number' && Date.now() > data.expires) {
							return this.delete(key).then(() => undefined);
						}

						return (options && options.raw) ? data : data.value;
					}),
				);
			}

			return Promise.allSettled(promises)
				.then(values => {
					const data = [];
					for (const value of values) {
						data.push(value.value);
					}

					return data;
				});
		}

		return Promise.resolve()
			.then(() => isArray ? store.getMany(keyPrefixed) : store.get(keyPrefixed))
			.then(data => (typeof data === 'string') ? this.opts.deserialize(data) : (this.opts.compression ? this.opts.deserialize(data) : data))
			.then(data => {
				if (data === undefined || data === null) {
					return undefined;
				}

				if (isArray) {
					const result = [];

					for (let row of data) {
						if ((typeof row === 'string')) {
							row = this.opts.deserialize(row);
						}

						if (row === undefined || row === null) {
							result.push(undefined);
							continue;
						}

						if (typeof row.expires === 'number' && Date.now() > row.expires) {
							this.delete(key).then(() => undefined);
							result.push(undefined);
						} else {
							result.push((options && options.raw) ? row : row.value);
						}
					}

					return result;
				}

				if (typeof data.expires === 'number' && Date.now() > data.expires) {
					return this.delete(key).then(() => undefined);
				}

				return (options && options.raw) ? data : data.value;
			});
	}

	set(key, value, ttl) {
		const keyPrefixed = this._getKeyPrefix(key);
		if (typeof ttl === 'undefined') {
			ttl = this.opts.ttl;
		}

		if (ttl === 0) {
			ttl = undefined;
		}

		const {store} = this.opts;

		return Promise.resolve()
			.then(() => {
				const expires = (typeof ttl === 'number') ? (Date.now() + ttl) : null;
				if (typeof value === 'symbol') {
					this.emit('error', 'symbol cannot be serialized');
				}

				value = {value, expires};
				return this.opts.serialize(value);
			})
			.then(value => store.set(keyPrefixed, value, ttl))
			.then(() => true);
	}

	delete(key) {
		const {store} = this.opts;
		if (Array.isArray(key)) {
			const keyPrefixed = this._getKeyPrefixArray(key);
			if (store.deleteMany === undefined) {
				const promises = [];
				for (const key of keyPrefixed) {
					promises.push(store.delete(key));
				}

				return Promise.allSettled(promises)
					.then(values => values.every(x => x.value === true));
			}

			return Promise.resolve()
				.then(() => store.deleteMany(keyPrefixed));
		}

		const keyPrefixed = this._getKeyPrefix(key);
		return Promise.resolve()
			.then(() => store.delete(keyPrefixed));
	}

	clear() {
		const {store} = this.opts;
		return Promise.resolve()
			.then(() => store.clear());
	}

	has(key) {
		const keyPrefixed = this._getKeyPrefix(key);
		const {store} = this.opts;
		return Promise.resolve()
			.then(async () => {
				if (typeof store.has === 'function') {
					return store.has(keyPrefixed);
				}

				const value = await store.get(keyPrefixed);
				return value !== undefined;
			});
	}

	disconnect() {
		const {store} = this.opts;
		if (typeof store.disconnect === 'function') {
			return store.disconnect();
		}
	}
}

module.exports = Keyv;


/***/ }),

/***/ "./node_modules/quick-lru/index.js":
/*!*****************************************!*\
  !*** ./node_modules/quick-lru/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


class QuickLRU {
	constructor(options = {}) {
		if (!(options.maxSize && options.maxSize > 0)) {
			throw new TypeError('`maxSize` must be a number greater than 0');
		}

		this.maxSize = options.maxSize;
		this.onEviction = options.onEviction;
		this.cache = new Map();
		this.oldCache = new Map();
		this._size = 0;
	}

	_set(key, value) {
		this.cache.set(key, value);
		this._size++;

		if (this._size >= this.maxSize) {
			this._size = 0;

			if (typeof this.onEviction === 'function') {
				for (const [key, value] of this.oldCache.entries()) {
					this.onEviction(key, value);
				}
			}

			this.oldCache = this.cache;
			this.cache = new Map();
		}
	}

	get(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			const value = this.oldCache.get(key);
			this.oldCache.delete(key);
			this._set(key, value);
			return value;
		}
	}

	set(key, value) {
		if (this.cache.has(key)) {
			this.cache.set(key, value);
		} else {
			this._set(key, value);
		}

		return this;
	}

	has(key) {
		return this.cache.has(key) || this.oldCache.has(key);
	}

	peek(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			return this.oldCache.get(key);
		}
	}

	delete(key) {
		const deleted = this.cache.delete(key);
		if (deleted) {
			this._size--;
		}

		return this.oldCache.delete(key) || deleted;
	}

	clear() {
		this.cache.clear();
		this.oldCache.clear();
		this._size = 0;
	}

	* keys() {
		for (const [key] of this) {
			yield key;
		}
	}

	* values() {
		for (const [, value] of this) {
			yield value;
		}
	}

	* [Symbol.iterator]() {
		for (const item of this.cache) {
			yield item;
		}

		for (const item of this.oldCache) {
			const [key] = item;
			if (!this.cache.has(key)) {
				yield item;
			}
		}
	}

	get size() {
		let oldCacheSize = 0;
		for (const key of this.oldCache.keys()) {
			if (!this.cache.has(key)) {
				oldCacheSize++;
			}
		}

		return Math.min(this._size + oldCacheSize, this.maxSize);
	}
}

module.exports = QuickLRU;


/***/ }),

/***/ "./node_modules/resolve-alpn/index.js":
/*!********************************************!*\
  !*** ./node_modules/resolve-alpn/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const tls = __webpack_require__(/*! tls */ "tls");

module.exports = (options = {}, connect = tls.connect) => new Promise((resolve, reject) => {
	let timeout = false;

	let socket;

	const callback = async () => {
		await socketPromise;

		socket.off('timeout', onTimeout);
		socket.off('error', reject);

		if (options.resolveSocket) {
			resolve({alpnProtocol: socket.alpnProtocol, socket, timeout});

			if (timeout) {
				await Promise.resolve();
				socket.emit('timeout');
			}
		} else {
			socket.destroy();
			resolve({alpnProtocol: socket.alpnProtocol, timeout});
		}
	};

	const onTimeout = async () => {
		timeout = true;
		callback();
	};

	const socketPromise = (async () => {
		try {
			socket = await connect(options, callback);

			socket.on('error', reject);
			socket.once('timeout', onTimeout);
		} catch (error) {
			reject(error);
		}
	})();
});


/***/ }),

/***/ "./node_modules/@sindresorhus/is/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@sindresorhus/is/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const typedArrayTypeNames = [
    'Int8Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Int16Array',
    'Uint16Array',
    'Int32Array',
    'Uint32Array',
    'Float32Array',
    'Float64Array',
    'BigInt64Array',
    'BigUint64Array',
];
function isTypedArrayName(name) {
    return typedArrayTypeNames.includes(name);
}
const objectTypeNames = [
    'Function',
    'Generator',
    'AsyncGenerator',
    'GeneratorFunction',
    'AsyncGeneratorFunction',
    'AsyncFunction',
    'Observable',
    'Array',
    'Buffer',
    'Blob',
    'Object',
    'RegExp',
    'Date',
    'Error',
    'Map',
    'Set',
    'WeakMap',
    'WeakSet',
    'WeakRef',
    'ArrayBuffer',
    'SharedArrayBuffer',
    'DataView',
    'Promise',
    'URL',
    'FormData',
    'URLSearchParams',
    'HTMLElement',
    'NaN',
    ...typedArrayTypeNames,
];
function isObjectTypeName(name) {
    return objectTypeNames.includes(name);
}
const primitiveTypeNames = [
    'null',
    'undefined',
    'string',
    'number',
    'bigint',
    'boolean',
    'symbol',
];
function isPrimitiveTypeName(name) {
    return primitiveTypeNames.includes(name);
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isOfType(type) {
    return (value) => typeof value === type;
}
const { toString } = Object.prototype;
const getObjectType = (value) => {
    const objectTypeName = toString.call(value).slice(8, -1);
    if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
        return 'HTMLElement';
    }
    if (isObjectTypeName(objectTypeName)) {
        return objectTypeName;
    }
    return undefined;
};
const isObjectOfType = (type) => (value) => getObjectType(value) === type;
function is(value) {
    if (value === null) {
        return 'null';
    }
    switch (typeof value) {
        case 'undefined':
            return 'undefined';
        case 'string':
            return 'string';
        case 'number':
            return Number.isNaN(value) ? 'NaN' : 'number';
        case 'boolean':
            return 'boolean';
        case 'function':
            return 'Function';
        case 'bigint':
            return 'bigint';
        case 'symbol':
            return 'symbol';
        default:
    }
    if (is.observable(value)) {
        return 'Observable';
    }
    if (is.array(value)) {
        return 'Array';
    }
    if (is.buffer(value)) {
        return 'Buffer';
    }
    const tagType = getObjectType(value);
    if (tagType) {
        return tagType;
    }
    if (value instanceof String || value instanceof Boolean || value instanceof Number) {
        throw new TypeError('Please don\'t use object wrappers for primitive types');
    }
    return 'Object';
}
is.undefined = isOfType('undefined');
is.string = isOfType('string');
const isNumberType = isOfType('number');
is.number = (value) => isNumberType(value) && !is.nan(value);
is.bigint = isOfType('bigint');
// eslint-disable-next-line @typescript-eslint/ban-types
is.function_ = isOfType('function');
// eslint-disable-next-line @typescript-eslint/ban-types
is.null_ = (value) => value === null;
is.class_ = (value) => is.function_(value) && value.toString().startsWith('class ');
is.boolean = (value) => value === true || value === false;
is.symbol = isOfType('symbol');
is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
is.array = (value, assertion) => {
    if (!Array.isArray(value)) {
        return false;
    }
    if (!is.function_(assertion)) {
        return true;
    }
    return value.every(element => assertion(element));
};
// eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call
is.buffer = (value) => value?.constructor?.isBuffer?.(value) ?? false;
is.blob = (value) => isObjectOfType('Blob')(value);
is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value); // eslint-disable-line @typescript-eslint/ban-types
is.object = (value) => !is.null_(value) && (typeof value === 'object' || is.function_(value)); // eslint-disable-line @typescript-eslint/ban-types
is.iterable = (value) => is.function_(value?.[Symbol.iterator]);
is.asyncIterable = (value) => is.function_(value?.[Symbol.asyncIterator]);
is.generator = (value) => is.iterable(value) && is.function_(value?.next) && is.function_(value?.throw);
is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
is.nativePromise = (value) => isObjectOfType('Promise')(value);
const hasPromiseApi = (value) => is.function_(value?.then)
    && is.function_(value?.catch);
is.promise = (value) => is.nativePromise(value) || hasPromiseApi(value);
is.generatorFunction = isObjectOfType('GeneratorFunction');
is.asyncGeneratorFunction = (value) => getObjectType(value) === 'AsyncGeneratorFunction';
is.asyncFunction = (value) => getObjectType(value) === 'AsyncFunction';
// eslint-disable-next-line no-prototype-builtins, @typescript-eslint/ban-types
is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty('prototype');
is.regExp = isObjectOfType('RegExp');
is.date = isObjectOfType('Date');
is.error = isObjectOfType('Error');
is.map = (value) => isObjectOfType('Map')(value);
is.set = (value) => isObjectOfType('Set')(value);
is.weakMap = (value) => isObjectOfType('WeakMap')(value); // eslint-disable-line @typescript-eslint/ban-types
is.weakSet = (value) => isObjectOfType('WeakSet')(value); // eslint-disable-line @typescript-eslint/ban-types
is.weakRef = (value) => isObjectOfType('WeakRef')(value); // eslint-disable-line @typescript-eslint/ban-types
is.int8Array = isObjectOfType('Int8Array');
is.uint8Array = isObjectOfType('Uint8Array');
is.uint8ClampedArray = isObjectOfType('Uint8ClampedArray');
is.int16Array = isObjectOfType('Int16Array');
is.uint16Array = isObjectOfType('Uint16Array');
is.int32Array = isObjectOfType('Int32Array');
is.uint32Array = isObjectOfType('Uint32Array');
is.float32Array = isObjectOfType('Float32Array');
is.float64Array = isObjectOfType('Float64Array');
is.bigInt64Array = isObjectOfType('BigInt64Array');
is.bigUint64Array = isObjectOfType('BigUint64Array');
is.arrayBuffer = isObjectOfType('ArrayBuffer');
is.sharedArrayBuffer = isObjectOfType('SharedArrayBuffer');
is.dataView = isObjectOfType('DataView');
is.enumCase = (value, targetEnum) => Object.values(targetEnum).includes(value);
is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
is.urlInstance = (value) => isObjectOfType('URL')(value);
is.urlString = (value) => {
    if (!is.string(value)) {
        return false;
    }
    try {
        new URL(value); // eslint-disable-line no-new
        return true;
    }
    catch {
        return false;
    }
};
// Example: `is.truthy = (value: unknown): value is (not false | not 0 | not '' | not undefined | not null) => Boolean(value);`
is.truthy = (value) => Boolean(value); // eslint-disable-line unicorn/prefer-native-coercion-functions
// Example: `is.falsy = (value: unknown): value is (not true | 0 | '' | undefined | null) => Boolean(value);`
is.falsy = (value) => !value;
is.nan = (value) => Number.isNaN(value);
is.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);
is.integer = (value) => Number.isInteger(value);
is.safeInteger = (value) => Number.isSafeInteger(value);
is.plainObject = (value) => {
    // From: https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};
is.typedArray = (value) => isTypedArrayName(getObjectType(value));
const isValidLength = (value) => is.safeInteger(value) && value >= 0;
is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
is.inRange = (value, range) => {
    if (is.number(range)) {
        return value >= Math.min(0, range) && value <= Math.max(range, 0);
    }
    if (is.array(range) && range.length === 2) {
        return value >= Math.min(...range) && value <= Math.max(...range);
    }
    throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
};
// eslint-disable-next-line @typescript-eslint/naming-convention
const NODE_TYPE_ELEMENT = 1;
// eslint-disable-next-line @typescript-eslint/naming-convention
const DOM_PROPERTIES_TO_CHECK = [
    'innerHTML',
    'ownerDocument',
    'style',
    'attributes',
    'nodeValue',
];
is.domElement = (value) => is.object(value)
    && value.nodeType === NODE_TYPE_ELEMENT
    && is.string(value.nodeName)
    && !is.plainObject(value)
    && DOM_PROPERTIES_TO_CHECK.every(property => property in value);
is.observable = (value) => {
    if (!value) {
        return false;
    }
    // eslint-disable-next-line no-use-extend-native/no-use-extend-native, @typescript-eslint/no-unsafe-call
    if (value === value[Symbol.observable]?.()) {
        return true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    if (value === value['@@observable']?.()) {
        return true;
    }
    return false;
};
is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
is.infinite = (value) => value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY;
const isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
is.evenInteger = isAbsoluteMod2(0);
is.oddInteger = isAbsoluteMod2(1);
is.emptyArray = (value) => is.array(value) && value.length === 0;
is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
is.emptyString = (value) => is.string(value) && value.length === 0;
const isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
// TODO: Use `not ''` when the `not` operator is available.
is.nonEmptyString = (value) => is.string(value) && value.length > 0;
// TODO: Use `not ''` when the `not` operator is available.
is.nonEmptyStringAndNotWhitespace = (value) => is.string(value) && !is.emptyStringOrWhitespace(value);
// eslint-disable-next-line unicorn/no-array-callback-reference
is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
// TODO: Use `not` operator here to remove `Map` and `Set` from type guard:
// - https://github.com/Microsoft/TypeScript/pull/29317
// eslint-disable-next-line unicorn/no-array-callback-reference
is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
is.emptySet = (value) => is.set(value) && value.size === 0;
is.nonEmptySet = (value) => is.set(value) && value.size > 0;
// eslint-disable-next-line unicorn/no-array-callback-reference
is.emptyMap = (value) => is.map(value) && value.size === 0;
// eslint-disable-next-line unicorn/no-array-callback-reference
is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
// `PropertyKey` is any value that can be used as an object key (string, number, or symbol)
is.propertyKey = (value) => is.any([is.string, is.number, is.symbol], value);
is.formData = (value) => isObjectOfType('FormData')(value);
is.urlSearchParams = (value) => isObjectOfType('URLSearchParams')(value);
const predicateOnArray = (method, predicate, values) => {
    if (!is.function_(predicate)) {
        throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
    }
    if (values.length === 0) {
        throw new TypeError('Invalid number of values');
    }
    return method.call(values, predicate);
};
is.any = (predicate, ...values) => {
    const predicates = is.array(predicate) ? predicate : [predicate];
    return predicates.some(singlePredicate => predicateOnArray(Array.prototype.some, singlePredicate, values));
};
is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
const assertType = (condition, description, value, options = {}) => {
    if (!condition) {
        const { multipleValues } = options;
        const valuesMessage = multipleValues
            ? `received values of types ${[
                ...new Set(value.map(singleValue => `\`${is(singleValue)}\``)),
            ].join(', ')}`
            : `received value of type \`${is(value)}\``;
        throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
    }
};
/* eslint-disable @typescript-eslint/no-confusing-void-expression */
const assert = {
    // Unknowns.
    undefined: (value) => assertType(is.undefined(value), 'undefined', value),
    string: (value) => assertType(is.string(value), 'string', value),
    number: (value) => assertType(is.number(value), 'number', value),
    bigint: (value) => assertType(is.bigint(value), 'bigint', value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    function_: (value) => assertType(is.function_(value), 'Function', value),
    null_: (value) => assertType(is.null_(value), 'null', value),
    class_: (value) => assertType(is.class_(value), "Class" /* AssertionTypeDescription.class_ */, value),
    boolean: (value) => assertType(is.boolean(value), 'boolean', value),
    symbol: (value) => assertType(is.symbol(value), 'symbol', value),
    numericString: (value) => assertType(is.numericString(value), "string with a number" /* AssertionTypeDescription.numericString */, value),
    array: (value, assertion) => {
        const assert = assertType;
        assert(is.array(value), 'Array', value);
        if (assertion) {
            // eslint-disable-next-line unicorn/no-array-for-each, unicorn/no-array-callback-reference
            value.forEach(assertion);
        }
    },
    buffer: (value) => assertType(is.buffer(value), 'Buffer', value),
    blob: (value) => assertType(is.blob(value), 'Blob', value),
    nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined" /* AssertionTypeDescription.nullOrUndefined */, value),
    object: (value) => assertType(is.object(value), 'Object', value),
    iterable: (value) => assertType(is.iterable(value), "Iterable" /* AssertionTypeDescription.iterable */, value),
    asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable" /* AssertionTypeDescription.asyncIterable */, value),
    generator: (value) => assertType(is.generator(value), 'Generator', value),
    asyncGenerator: (value) => assertType(is.asyncGenerator(value), 'AsyncGenerator', value),
    nativePromise: (value) => assertType(is.nativePromise(value), "native Promise" /* AssertionTypeDescription.nativePromise */, value),
    promise: (value) => assertType(is.promise(value), 'Promise', value),
    generatorFunction: (value) => assertType(is.generatorFunction(value), 'GeneratorFunction', value),
    asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), 'AsyncGeneratorFunction', value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    asyncFunction: (value) => assertType(is.asyncFunction(value), 'AsyncFunction', value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    boundFunction: (value) => assertType(is.boundFunction(value), 'Function', value),
    regExp: (value) => assertType(is.regExp(value), 'RegExp', value),
    date: (value) => assertType(is.date(value), 'Date', value),
    error: (value) => assertType(is.error(value), 'Error', value),
    map: (value) => assertType(is.map(value), 'Map', value),
    set: (value) => assertType(is.set(value), 'Set', value),
    weakMap: (value) => assertType(is.weakMap(value), 'WeakMap', value),
    weakSet: (value) => assertType(is.weakSet(value), 'WeakSet', value),
    weakRef: (value) => assertType(is.weakRef(value), 'WeakRef', value),
    int8Array: (value) => assertType(is.int8Array(value), 'Int8Array', value),
    uint8Array: (value) => assertType(is.uint8Array(value), 'Uint8Array', value),
    uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), 'Uint8ClampedArray', value),
    int16Array: (value) => assertType(is.int16Array(value), 'Int16Array', value),
    uint16Array: (value) => assertType(is.uint16Array(value), 'Uint16Array', value),
    int32Array: (value) => assertType(is.int32Array(value), 'Int32Array', value),
    uint32Array: (value) => assertType(is.uint32Array(value), 'Uint32Array', value),
    float32Array: (value) => assertType(is.float32Array(value), 'Float32Array', value),
    float64Array: (value) => assertType(is.float64Array(value), 'Float64Array', value),
    bigInt64Array: (value) => assertType(is.bigInt64Array(value), 'BigInt64Array', value),
    bigUint64Array: (value) => assertType(is.bigUint64Array(value), 'BigUint64Array', value),
    arrayBuffer: (value) => assertType(is.arrayBuffer(value), 'ArrayBuffer', value),
    sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), 'SharedArrayBuffer', value),
    dataView: (value) => assertType(is.dataView(value), 'DataView', value),
    enumCase: (value, targetEnum) => assertType(is.enumCase(value, targetEnum), 'EnumCase', value),
    urlInstance: (value) => assertType(is.urlInstance(value), 'URL', value),
    urlString: (value) => assertType(is.urlString(value), "string with a URL" /* AssertionTypeDescription.urlString */, value),
    truthy: (value) => assertType(is.truthy(value), "truthy" /* AssertionTypeDescription.truthy */, value),
    falsy: (value) => assertType(is.falsy(value), "falsy" /* AssertionTypeDescription.falsy */, value),
    nan: (value) => assertType(is.nan(value), "NaN" /* AssertionTypeDescription.nan */, value),
    primitive: (value) => assertType(is.primitive(value), "primitive" /* AssertionTypeDescription.primitive */, value),
    integer: (value) => assertType(is.integer(value), "integer" /* AssertionTypeDescription.integer */, value),
    safeInteger: (value) => assertType(is.safeInteger(value), "integer" /* AssertionTypeDescription.safeInteger */, value),
    plainObject: (value) => assertType(is.plainObject(value), "plain object" /* AssertionTypeDescription.plainObject */, value),
    typedArray: (value) => assertType(is.typedArray(value), "TypedArray" /* AssertionTypeDescription.typedArray */, value),
    arrayLike: (value) => assertType(is.arrayLike(value), "array-like" /* AssertionTypeDescription.arrayLike */, value),
    domElement: (value) => assertType(is.domElement(value), "HTMLElement" /* AssertionTypeDescription.domElement */, value),
    observable: (value) => assertType(is.observable(value), 'Observable', value),
    nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream" /* AssertionTypeDescription.nodeStream */, value),
    infinite: (value) => assertType(is.infinite(value), "infinite number" /* AssertionTypeDescription.infinite */, value),
    emptyArray: (value) => assertType(is.emptyArray(value), "empty array" /* AssertionTypeDescription.emptyArray */, value),
    nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array" /* AssertionTypeDescription.nonEmptyArray */, value),
    emptyString: (value) => assertType(is.emptyString(value), "empty string" /* AssertionTypeDescription.emptyString */, value),
    emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace" /* AssertionTypeDescription.emptyStringOrWhitespace */, value),
    nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string" /* AssertionTypeDescription.nonEmptyString */, value),
    nonEmptyStringAndNotWhitespace: (value) => assertType(is.nonEmptyStringAndNotWhitespace(value), "non-empty string and not whitespace" /* AssertionTypeDescription.nonEmptyStringAndNotWhitespace */, value),
    emptyObject: (value) => assertType(is.emptyObject(value), "empty object" /* AssertionTypeDescription.emptyObject */, value),
    nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object" /* AssertionTypeDescription.nonEmptyObject */, value),
    emptySet: (value) => assertType(is.emptySet(value), "empty set" /* AssertionTypeDescription.emptySet */, value),
    nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set" /* AssertionTypeDescription.nonEmptySet */, value),
    emptyMap: (value) => assertType(is.emptyMap(value), "empty map" /* AssertionTypeDescription.emptyMap */, value),
    nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map" /* AssertionTypeDescription.nonEmptyMap */, value),
    propertyKey: (value) => assertType(is.propertyKey(value), 'PropertyKey', value),
    formData: (value) => assertType(is.formData(value), 'FormData', value),
    urlSearchParams: (value) => assertType(is.urlSearchParams(value), 'URLSearchParams', value),
    // Numbers.
    evenInteger: (value) => assertType(is.evenInteger(value), "even integer" /* AssertionTypeDescription.evenInteger */, value),
    oddInteger: (value) => assertType(is.oddInteger(value), "odd integer" /* AssertionTypeDescription.oddInteger */, value),
    // Two arguments.
    directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T" /* AssertionTypeDescription.directInstanceOf */, instance),
    inRange: (value, range) => assertType(is.inRange(value, range), "in range" /* AssertionTypeDescription.inRange */, value),
    // Variadic functions.
    any: (predicate, ...values) => assertType(is.any(predicate, ...values), "predicate returns truthy for any value" /* AssertionTypeDescription.any */, values, { multipleValues: true }),
    all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values" /* AssertionTypeDescription.all */, values, { multipleValues: true }),
};
/* eslint-enable @typescript-eslint/no-confusing-void-expression */
// Some few keywords are reserved, but we'll populate them for Node.js users
// See https://github.com/Microsoft/TypeScript/issues/2536
Object.defineProperties(is, {
    class: {
        value: is.class_,
    },
    function: {
        value: is.function_,
    },
    null: {
        value: is.null_,
    },
});
Object.defineProperties(assert, {
    class: {
        value: assert.class_,
    },
    function: {
        value: assert.function_,
    },
    null: {
        value: assert.null_,
    },
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (is);


/***/ }),

/***/ "./node_modules/@szmarczak/http-timer/dist/source/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@szmarczak/http-timer/dist/source/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "events");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var defer_to_connect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! defer-to-connect */ "./node_modules/defer-to-connect/dist/source/index.js");



const timer = (request) => {
    if (request.timings) {
        return request.timings;
    }
    const timings = {
        start: Date.now(),
        socket: undefined,
        lookup: undefined,
        connect: undefined,
        secureConnect: undefined,
        upload: undefined,
        response: undefined,
        end: undefined,
        error: undefined,
        abort: undefined,
        phases: {
            wait: undefined,
            dns: undefined,
            tcp: undefined,
            tls: undefined,
            request: undefined,
            firstByte: undefined,
            download: undefined,
            total: undefined,
        },
    };
    request.timings = timings;
    const handleError = (origin) => {
        origin.once(events__WEBPACK_IMPORTED_MODULE_0__.errorMonitor, () => {
            timings.error = Date.now();
            timings.phases.total = timings.error - timings.start;
        });
    };
    handleError(request);
    const onAbort = () => {
        timings.abort = Date.now();
        timings.phases.total = timings.abort - timings.start;
    };
    request.prependOnceListener('abort', onAbort);
    const onSocket = (socket) => {
        timings.socket = Date.now();
        timings.phases.wait = timings.socket - timings.start;
        if (util__WEBPACK_IMPORTED_MODULE_1__.types.isProxy(socket)) {
            return;
        }
        const lookupListener = () => {
            timings.lookup = Date.now();
            timings.phases.dns = timings.lookup - timings.socket;
        };
        socket.prependOnceListener('lookup', lookupListener);
        defer_to_connect__WEBPACK_IMPORTED_MODULE_2__(socket, {
            connect: () => {
                timings.connect = Date.now();
                if (timings.lookup === undefined) {
                    socket.removeListener('lookup', lookupListener);
                    timings.lookup = timings.connect;
                    timings.phases.dns = timings.lookup - timings.socket;
                }
                timings.phases.tcp = timings.connect - timings.lookup;
            },
            secureConnect: () => {
                timings.secureConnect = Date.now();
                timings.phases.tls = timings.secureConnect - timings.connect;
            },
        });
    };
    if (request.socket) {
        onSocket(request.socket);
    }
    else {
        request.prependOnceListener('socket', onSocket);
    }
    const onUpload = () => {
        timings.upload = Date.now();
        timings.phases.request = timings.upload - (timings.secureConnect ?? timings.connect);
    };
    if (request.writableFinished) {
        onUpload();
    }
    else {
        request.prependOnceListener('finish', onUpload);
    }
    request.prependOnceListener('response', (response) => {
        timings.response = Date.now();
        timings.phases.firstByte = timings.response - timings.upload;
        response.timings = timings;
        handleError(response);
        response.prependOnceListener('end', () => {
            request.off('abort', onAbort);
            response.off('aborted', onAbort);
            if (timings.phases.total) {
                // Aborted or errored
                return;
            }
            timings.end = Date.now();
            timings.phases.download = timings.end - timings.response;
            timings.phases.total = timings.end - timings.start;
        });
        response.prependOnceListener('aborted', onAbort);
    });
    return timings;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (timer);


/***/ }),

/***/ "./node_modules/cacheable-lookup/source/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/cacheable-lookup/source/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CacheableLookup)
/* harmony export */ });
/* harmony import */ var node_dns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:dns */ "node:dns");
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var node_os__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:os */ "node:os");




const {Resolver: AsyncResolver} = node_dns__WEBPACK_IMPORTED_MODULE_0__.promises;

const kCacheableLookupCreateConnection = Symbol('cacheableLookupCreateConnection');
const kCacheableLookupInstance = Symbol('cacheableLookupInstance');
const kExpires = Symbol('expires');

const supportsALL = typeof node_dns__WEBPACK_IMPORTED_MODULE_0__.ALL === 'number';

const verifyAgent = agent => {
	if (!(agent && typeof agent.createConnection === 'function')) {
		throw new Error('Expected an Agent instance as the first argument');
	}
};

const map4to6 = entries => {
	for (const entry of entries) {
		if (entry.family === 6) {
			continue;
		}

		entry.address = `::ffff:${entry.address}`;
		entry.family = 6;
	}
};

const getIfaceInfo = () => {
	let has4 = false;
	let has6 = false;

	for (const device of Object.values(node_os__WEBPACK_IMPORTED_MODULE_2__.networkInterfaces())) {
		for (const iface of device) {
			if (iface.internal) {
				continue;
			}

			if (iface.family === 'IPv6') {
				has6 = true;
			} else {
				has4 = true;
			}

			if (has4 && has6) {
				return {has4, has6};
			}
		}
	}

	return {has4, has6};
};

const isIterable = map => {
	return Symbol.iterator in map;
};

const ignoreNoResultErrors = dnsPromise => {
	return dnsPromise.catch(error => {
		if (
			error.code === 'ENODATA' ||
			error.code === 'ENOTFOUND' ||
			error.code === 'ENOENT' // Windows: name exists, but not this record type
		) {
			return [];
		}

		throw error;
	});
};

const ttl = {ttl: true};
const all = {all: true};
const all4 = {all: true, family: 4};
const all6 = {all: true, family: 6};

class CacheableLookup {
	constructor({
		cache = new Map(),
		maxTtl = Infinity,
		fallbackDuration = 3600,
		errorTtl = 0.15,
		resolver = new AsyncResolver(),
		lookup = node_dns__WEBPACK_IMPORTED_MODULE_0__.lookup
	} = {}) {
		this.maxTtl = maxTtl;
		this.errorTtl = errorTtl;

		this._cache = cache;
		this._resolver = resolver;
		this._dnsLookup = lookup && (0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(lookup);
		this.stats = {
			cache: 0,
			query: 0
		};

		if (this._resolver instanceof AsyncResolver) {
			this._resolve4 = this._resolver.resolve4.bind(this._resolver);
			this._resolve6 = this._resolver.resolve6.bind(this._resolver);
		} else {
			this._resolve4 = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(this._resolver.resolve4.bind(this._resolver));
			this._resolve6 = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(this._resolver.resolve6.bind(this._resolver));
		}

		this._iface = getIfaceInfo();

		this._pending = {};
		this._nextRemovalTime = false;
		this._hostnamesToFallback = new Set();

		this.fallbackDuration = fallbackDuration;

		if (fallbackDuration > 0) {
			const interval = setInterval(() => {
				this._hostnamesToFallback.clear();
			}, fallbackDuration * 1000);

			/* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */
			if (interval.unref) {
				interval.unref();
			}

			this._fallbackInterval = interval;
		}

		this.lookup = this.lookup.bind(this);
		this.lookupAsync = this.lookupAsync.bind(this);
	}

	set servers(servers) {
		this.clear();

		this._resolver.setServers(servers);
	}

	get servers() {
		return this._resolver.getServers();
	}

	lookup(hostname, options, callback) {
		if (typeof options === 'function') {
			callback = options;
			options = {};
		} else if (typeof options === 'number') {
			options = {
				family: options
			};
		}

		if (!callback) {
			throw new Error('Callback must be a function.');
		}

		// eslint-disable-next-line promise/prefer-await-to-then
		this.lookupAsync(hostname, options).then(result => {
			if (options.all) {
				callback(null, result);
			} else {
				callback(null, result.address, result.family, result.expires, result.ttl, result.source);
			}
		}, callback);
	}

	async lookupAsync(hostname, options = {}) {
		if (typeof options === 'number') {
			options = {
				family: options
			};
		}

		let cached = await this.query(hostname);

		if (options.family === 6) {
			const filtered = cached.filter(entry => entry.family === 6);

			if (options.hints & node_dns__WEBPACK_IMPORTED_MODULE_0__.V4MAPPED) {
				if ((supportsALL && options.hints & node_dns__WEBPACK_IMPORTED_MODULE_0__.ALL) || filtered.length === 0) {
					map4to6(cached);
				} else {
					cached = filtered;
				}
			} else {
				cached = filtered;
			}
		} else if (options.family === 4) {
			cached = cached.filter(entry => entry.family === 4);
		}

		if (options.hints & node_dns__WEBPACK_IMPORTED_MODULE_0__.ADDRCONFIG) {
			const {_iface} = this;
			cached = cached.filter(entry => entry.family === 6 ? _iface.has6 : _iface.has4);
		}

		if (cached.length === 0) {
			const error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
			error.code = 'ENOTFOUND';
			error.hostname = hostname;

			throw error;
		}

		if (options.all) {
			return cached;
		}

		return cached[0];
	}

	async query(hostname) {
		let source = 'cache';
		let cached = await this._cache.get(hostname);

		if (cached) {
			this.stats.cache++;
		}

		if (!cached) {
			const pending = this._pending[hostname];
			if (pending) {
				this.stats.cache++;
				cached = await pending;
			} else {
				source = 'query';
				const newPromise = this.queryAndCache(hostname);
				this._pending[hostname] = newPromise;
				this.stats.query++;
				try {
					cached = await newPromise;
				} finally {
					delete this._pending[hostname];
				}
			}
		}

		cached = cached.map(entry => {
			return {...entry, source};
		});

		return cached;
	}

	async _resolve(hostname) {
		// ANY is unsafe as it doesn't trigger new queries in the underlying server.
		const [A, AAAA] = await Promise.all([
			ignoreNoResultErrors(this._resolve4(hostname, ttl)),
			ignoreNoResultErrors(this._resolve6(hostname, ttl))
		]);

		let aTtl = 0;
		let aaaaTtl = 0;
		let cacheTtl = 0;

		const now = Date.now();

		for (const entry of A) {
			entry.family = 4;
			entry.expires = now + (entry.ttl * 1000);

			aTtl = Math.max(aTtl, entry.ttl);
		}

		for (const entry of AAAA) {
			entry.family = 6;
			entry.expires = now + (entry.ttl * 1000);

			aaaaTtl = Math.max(aaaaTtl, entry.ttl);
		}

		if (A.length > 0) {
			if (AAAA.length > 0) {
				cacheTtl = Math.min(aTtl, aaaaTtl);
			} else {
				cacheTtl = aTtl;
			}
		} else {
			cacheTtl = aaaaTtl;
		}

		return {
			entries: [
				...A,
				...AAAA
			],
			cacheTtl
		};
	}

	async _lookup(hostname) {
		try {
			const [A, AAAA] = await Promise.all([
				// Passing {all: true} doesn't return all IPv4 and IPv6 entries.
				// See https://github.com/szmarczak/cacheable-lookup/issues/42
				ignoreNoResultErrors(this._dnsLookup(hostname, all4)),
				ignoreNoResultErrors(this._dnsLookup(hostname, all6))
			]);

			return {
				entries: [
					...A,
					...AAAA
				],
				cacheTtl: 0
			};
		} catch {
			return {
				entries: [],
				cacheTtl: 0
			};
		}
	}

	async _set(hostname, data, cacheTtl) {
		if (this.maxTtl > 0 && cacheTtl > 0) {
			cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;
			data[kExpires] = Date.now() + cacheTtl;

			try {
				await this._cache.set(hostname, data, cacheTtl);
			} catch (error) {
				this.lookupAsync = async () => {
					const cacheError = new Error('Cache Error. Please recreate the CacheableLookup instance.');
					cacheError.cause = error;

					throw cacheError;
				};
			}

			if (isIterable(this._cache)) {
				this._tick(cacheTtl);
			}
		}
	}

	async queryAndCache(hostname) {
		if (this._hostnamesToFallback.has(hostname)) {
			return this._dnsLookup(hostname, all);
		}

		let query = await this._resolve(hostname);

		if (query.entries.length === 0 && this._dnsLookup) {
			query = await this._lookup(hostname);

			if (query.entries.length !== 0 && this.fallbackDuration > 0) {
				// Use `dns.lookup(...)` for that particular hostname
				this._hostnamesToFallback.add(hostname);
			}
		}

		const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
		await this._set(hostname, query.entries, cacheTtl);

		return query.entries;
	}

	_tick(ms) {
		const nextRemovalTime = this._nextRemovalTime;

		if (!nextRemovalTime || ms < nextRemovalTime) {
			clearTimeout(this._removalTimeout);

			this._nextRemovalTime = ms;

			this._removalTimeout = setTimeout(() => {
				this._nextRemovalTime = false;

				let nextExpiry = Infinity;

				const now = Date.now();

				for (const [hostname, entries] of this._cache) {
					const expires = entries[kExpires];

					if (now >= expires) {
						this._cache.delete(hostname);
					} else if (expires < nextExpiry) {
						nextExpiry = expires;
					}
				}

				if (nextExpiry !== Infinity) {
					this._tick(nextExpiry - now);
				}
			}, ms);

			/* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */
			if (this._removalTimeout.unref) {
				this._removalTimeout.unref();
			}
		}
	}

	install(agent) {
		verifyAgent(agent);

		if (kCacheableLookupCreateConnection in agent) {
			throw new Error('CacheableLookup has been already installed');
		}

		agent[kCacheableLookupCreateConnection] = agent.createConnection;
		agent[kCacheableLookupInstance] = this;

		agent.createConnection = (options, callback) => {
			if (!('lookup' in options)) {
				options.lookup = this.lookup;
			}

			return agent[kCacheableLookupCreateConnection](options, callback);
		};
	}

	uninstall(agent) {
		verifyAgent(agent);

		if (agent[kCacheableLookupCreateConnection]) {
			if (agent[kCacheableLookupInstance] !== this) {
				throw new Error('The agent is not owned by this CacheableLookup instance');
			}

			agent.createConnection = agent[kCacheableLookupCreateConnection];

			delete agent[kCacheableLookupCreateConnection];
			delete agent[kCacheableLookupInstance];
		}
	}

	updateInterfaceInfo() {
		const {_iface} = this;

		this._iface = getIfaceInfo();

		if ((_iface.has4 && !this._iface.has4) || (_iface.has6 && !this._iface.has6)) {
			this._cache.clear();
		}
	}

	clear(hostname) {
		if (hostname) {
			this._cache.delete(hostname);
			return;
		}

		this._cache.clear();
	}
}


/***/ }),

/***/ "./node_modules/cacheable-request/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/cacheable-request/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CacheError": () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_10__.CacheError),
/* harmony export */   "RequestError": () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_10__.RequestError),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "onResponse": () => (/* binding */ onResponse)
/* harmony export */ });
/* harmony import */ var node_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:events */ "node:events");
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:url */ "node:url");
/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:crypto */ "node:crypto");
/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:stream */ "node:stream");
/* harmony import */ var normalize_url__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! normalize-url */ "./node_modules/normalize-url/index.js");
/* harmony import */ var get_stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! get-stream */ "./node_modules/get-stream/index.js");
/* harmony import */ var http_cache_semantics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! http-cache-semantics */ "./node_modules/http-cache-semantics/index.js");
/* harmony import */ var responselike__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! responselike */ "./node_modules/responselike/index.js");
/* harmony import */ var keyv__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! keyv */ "./node_modules/keyv/src/index.js");
/* harmony import */ var mimic_response__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! mimic-response */ "./node_modules/mimic-response/index.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./types.js */ "./node_modules/cacheable-request/dist/types.js");











class CacheableRequest {
    constructor(cacheRequest, cacheAdapter) {
        this.hooks = new Map();
        this.request = () => (options, cb) => {
            let url;
            if (typeof options === 'string') {
                url = normalizeUrlObject(node_url__WEBPACK_IMPORTED_MODULE_1__.parse(options));
                options = {};
            }
            else if (options instanceof node_url__WEBPACK_IMPORTED_MODULE_1__.URL) {
                url = normalizeUrlObject(node_url__WEBPACK_IMPORTED_MODULE_1__.parse(options.toString()));
                options = {};
            }
            else {
                const [pathname, ...searchParts] = (options.path ?? '').split('?');
                const search = searchParts.length > 0
                    ? `?${searchParts.join('?')}`
                    : '';
                url = normalizeUrlObject({ ...options, pathname, search });
            }
            options = {
                headers: {},
                method: 'GET',
                cache: true,
                strictTtl: false,
                automaticFailover: false,
                ...options,
                ...urlObjectToRequestOptions(url),
            };
            options.headers = Object.fromEntries(entries(options.headers).map(([key, value]) => [key.toLowerCase(), value]));
            const ee = new node_events__WEBPACK_IMPORTED_MODULE_0__();
            const normalizedUrlString = (0,normalize_url__WEBPACK_IMPORTED_MODULE_4__["default"])(node_url__WEBPACK_IMPORTED_MODULE_1__.format(url), {
                stripWWW: false,
                removeTrailingSlash: false,
                stripAuthentication: false,
            });
            let key = `${options.method}:${normalizedUrlString}`;
            // POST, PATCH, and PUT requests may be cached, depending on the response
            // cache-control headers. As a result, the body of the request should be
            // added to the cache key in order to avoid collisions.
            if (options.body && options.method !== undefined && ['POST', 'PATCH', 'PUT'].includes(options.method)) {
                if (options.body instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable) {
                    // Streamed bodies should completely skip the cache because they may
                    // or may not be hashable and in either case the stream would need to
                    // close before the cache key could be generated.
                    options.cache = false;
                }
                else {
                    key += `:${node_crypto__WEBPACK_IMPORTED_MODULE_2__.createHash('md5').update(options.body).digest('hex')}`;
                }
            }
            let revalidate = false;
            let madeRequest = false;
            const makeRequest = (options_) => {
                madeRequest = true;
                let requestErrored = false;
                let requestErrorCallback = () => { };
                const requestErrorPromise = new Promise(resolve => {
                    requestErrorCallback = () => {
                        if (!requestErrored) {
                            requestErrored = true;
                            resolve();
                        }
                    };
                });
                const handler = async (response) => {
                    if (revalidate) {
                        response.status = response.statusCode;
                        const revalidatedPolicy = http_cache_semantics__WEBPACK_IMPORTED_MODULE_6__.fromObject(revalidate.cachePolicy).revalidatedPolicy(options_, response);
                        if (!revalidatedPolicy.modified) {
                            response.resume();
                            await new Promise(resolve => {
                                // Skipping 'error' handler cause 'error' event should't be emitted for 304 response
                                response
                                    .once('end', resolve);
                            });
                            const headers = convertHeaders(revalidatedPolicy.policy.responseHeaders());
                            response = new responselike__WEBPACK_IMPORTED_MODULE_7__["default"]({ statusCode: revalidate.statusCode, headers, body: revalidate.body, url: revalidate.url });
                            response.cachePolicy = revalidatedPolicy.policy;
                            response.fromCache = true;
                        }
                    }
                    if (!response.fromCache) {
                        response.cachePolicy = new http_cache_semantics__WEBPACK_IMPORTED_MODULE_6__(options_, response, options_);
                        response.fromCache = false;
                    }
                    let clonedResponse;
                    if (options_.cache && response.cachePolicy.storable()) {
                        clonedResponse = cloneResponse(response);
                        (async () => {
                            try {
                                const bodyPromise = get_stream__WEBPACK_IMPORTED_MODULE_5__.buffer(response);
                                await Promise.race([
                                    requestErrorPromise,
                                    new Promise(resolve => response.once('end', resolve)),
                                    new Promise(resolve => response.once('close', resolve)), // eslint-disable-line no-promise-executor-return
                                ]);
                                const body = await bodyPromise;
                                let value = {
                                    url: response.url,
                                    statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                                    body,
                                    cachePolicy: response.cachePolicy.toObject(),
                                };
                                let ttl = options_.strictTtl ? response.cachePolicy.timeToLive() : undefined;
                                if (options_.maxTtl) {
                                    ttl = ttl ? Math.min(ttl, options_.maxTtl) : options_.maxTtl;
                                }
                                if (this.hooks.size > 0) {
                                    /* eslint-disable no-await-in-loop */
                                    for (const key_ of this.hooks.keys()) {
                                        value = await this.runHook(key_, value, response);
                                    }
                                    /* eslint-enable no-await-in-loop */
                                }
                                await this.cache.set(key, value, ttl);
                            }
                            catch (error) {
                                ee.emit('error', new _types_js__WEBPACK_IMPORTED_MODULE_10__.CacheError(error));
                            }
                        })();
                    }
                    else if (options_.cache && revalidate) {
                        (async () => {
                            try {
                                await this.cache.delete(key);
                            }
                            catch (error) {
                                ee.emit('error', new _types_js__WEBPACK_IMPORTED_MODULE_10__.CacheError(error));
                            }
                        })();
                    }
                    ee.emit('response', clonedResponse ?? response);
                    if (typeof cb === 'function') {
                        cb(clonedResponse ?? response);
                    }
                };
                try {
                    const request_ = this.cacheRequest(options_, handler);
                    request_.once('error', requestErrorCallback);
                    request_.once('abort', requestErrorCallback);
                    request_.once('destroy', requestErrorCallback);
                    ee.emit('request', request_);
                }
                catch (error) {
                    ee.emit('error', new _types_js__WEBPACK_IMPORTED_MODULE_10__.RequestError(error));
                }
            };
            (async () => {
                const get = async (options_) => {
                    await Promise.resolve();
                    const cacheEntry = options_.cache ? await this.cache.get(key) : undefined;
                    if (typeof cacheEntry === 'undefined' && !options_.forceRefresh) {
                        makeRequest(options_);
                        return;
                    }
                    const policy = http_cache_semantics__WEBPACK_IMPORTED_MODULE_6__.fromObject(cacheEntry.cachePolicy);
                    if (policy.satisfiesWithoutRevalidation(options_) && !options_.forceRefresh) {
                        const headers = convertHeaders(policy.responseHeaders());
                        const response = new responselike__WEBPACK_IMPORTED_MODULE_7__["default"]({ statusCode: cacheEntry.statusCode, headers, body: cacheEntry.body, url: cacheEntry.url });
                        response.cachePolicy = policy;
                        response.fromCache = true;
                        ee.emit('response', response);
                        if (typeof cb === 'function') {
                            cb(response);
                        }
                    }
                    else if (policy.satisfiesWithoutRevalidation(options_) && Date.now() >= policy.timeToLive() && options_.forceRefresh) {
                        await this.cache.delete(key);
                        options_.headers = policy.revalidationHeaders(options_);
                        makeRequest(options_);
                    }
                    else {
                        revalidate = cacheEntry;
                        options_.headers = policy.revalidationHeaders(options_);
                        makeRequest(options_);
                    }
                };
                const errorHandler = (error) => ee.emit('error', new _types_js__WEBPACK_IMPORTED_MODULE_10__.CacheError(error));
                if (this.cache instanceof keyv__WEBPACK_IMPORTED_MODULE_8__) {
                    const cachek = this.cache;
                    cachek.once('error', errorHandler);
                    ee.on('error', () => cachek.removeListener('error', errorHandler));
                    ee.on('response', () => cachek.removeListener('error', errorHandler));
                }
                try {
                    await get(options);
                }
                catch (error) {
                    if (options.automaticFailover && !madeRequest) {
                        makeRequest(options);
                    }
                    ee.emit('error', new _types_js__WEBPACK_IMPORTED_MODULE_10__.CacheError(error));
                }
            })();
            return ee;
        };
        this.addHook = (name, fn) => {
            if (!this.hooks.has(name)) {
                this.hooks.set(name, fn);
            }
        };
        this.removeHook = (name) => this.hooks.delete(name);
        this.getHook = (name) => this.hooks.get(name);
        this.runHook = async (name, ...args) => this.hooks.get(name)?.(...args);
        if (cacheAdapter instanceof keyv__WEBPACK_IMPORTED_MODULE_8__) {
            this.cache = cacheAdapter;
        }
        else if (typeof cacheAdapter === 'string') {
            this.cache = new keyv__WEBPACK_IMPORTED_MODULE_8__({
                uri: cacheAdapter,
                namespace: 'cacheable-request',
            });
        }
        else {
            this.cache = new keyv__WEBPACK_IMPORTED_MODULE_8__({
                store: cacheAdapter,
                namespace: 'cacheable-request',
            });
        }
        this.request = this.request.bind(this);
        this.cacheRequest = cacheRequest;
    }
}
const entries = Object.entries;
const cloneResponse = (response) => {
    const clone = new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough({ autoDestroy: false });
    (0,mimic_response__WEBPACK_IMPORTED_MODULE_9__["default"])(response, clone);
    return response.pipe(clone);
};
const urlObjectToRequestOptions = (url) => {
    const options = { ...url };
    options.path = `${url.pathname || '/'}${url.search || ''}`;
    delete options.pathname;
    delete options.search;
    return options;
};
const normalizeUrlObject = (url) => 
// If url was parsed by url.parse or new URL:
// - hostname will be set
// - host will be hostname[:port]
// - port will be set if it was explicit in the parsed string
// Otherwise, url was from request options:
// - hostname or host may be set
// - host shall not have port encoded
({
    protocol: url.protocol,
    auth: url.auth,
    hostname: url.hostname || url.host || 'localhost',
    port: url.port,
    pathname: url.pathname,
    search: url.search,
});
const convertHeaders = (headers) => {
    const result = [];
    for (const name of Object.keys(headers)) {
        result[name.toLowerCase()] = headers[name];
    }
    return result;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CacheableRequest);

const onResponse = 'onResponse';
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/cacheable-request/dist/types.js":
/*!******************************************************!*\
  !*** ./node_modules/cacheable-request/dist/types.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CacheError": () => (/* binding */ CacheError),
/* harmony export */   "RequestError": () => (/* binding */ RequestError)
/* harmony export */ });
// Type definitions for cacheable-request 6.0
// Project: https://github.com/lukechilds/cacheable-request#readme
// Definitions by: BendingBender <https://github.com/BendingBender>
//                 Paul Melnikow <https://github.com/paulmelnikow>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// TypeScript Version: 2.3
class RequestError extends Error {
    constructor(error) {
        super(error.message);
        Object.assign(this, error);
    }
}
class CacheError extends Error {
    constructor(error) {
        super(error.message);
        Object.assign(this, error);
    }
}
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/form-data-encoder/lib/FormDataEncoder.js":
/*!***************************************************************!*\
  !*** ./node_modules/form-data-encoder/lib/FormDataEncoder.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FormDataEncoder": () => (/* binding */ FormDataEncoder)
/* harmony export */ });
/* harmony import */ var _util_getStreamIterator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/getStreamIterator.js */ "./node_modules/form-data-encoder/lib/util/getStreamIterator.js");
/* harmony import */ var _util_createBoundary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/createBoundary.js */ "./node_modules/form-data-encoder/lib/util/createBoundary.js");
/* harmony import */ var _util_normalizeValue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/normalizeValue.js */ "./node_modules/form-data-encoder/lib/util/normalizeValue.js");
/* harmony import */ var _util_isPlainObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/isPlainObject.js */ "./node_modules/form-data-encoder/lib/util/isPlainObject.js");
/* harmony import */ var _util_proxyHeaders_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/proxyHeaders.js */ "./node_modules/form-data-encoder/lib/util/proxyHeaders.js");
/* harmony import */ var _util_isFormData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/isFormData.js */ "./node_modules/form-data-encoder/lib/util/isFormData.js");
/* harmony import */ var _util_escapeName_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util/escapeName.js */ "./node_modules/form-data-encoder/lib/util/escapeName.js");
/* harmony import */ var _util_isFile_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util/isFile.js */ "./node_modules/form-data-encoder/lib/util/isFile.js");
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FormDataEncoder_instances, _FormDataEncoder_CRLF, _FormDataEncoder_CRLF_BYTES, _FormDataEncoder_CRLF_BYTES_LENGTH, _FormDataEncoder_DASHES, _FormDataEncoder_encoder, _FormDataEncoder_footer, _FormDataEncoder_form, _FormDataEncoder_options, _FormDataEncoder_getFieldHeader, _FormDataEncoder_getContentLength;








const defaultOptions = {
    enableAdditionalHeaders: false
};
const readonlyProp = { writable: false, configurable: false };
class FormDataEncoder {
    constructor(form, boundaryOrOptions, options) {
        _FormDataEncoder_instances.add(this);
        _FormDataEncoder_CRLF.set(this, "\r\n");
        _FormDataEncoder_CRLF_BYTES.set(this, void 0);
        _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0);
        _FormDataEncoder_DASHES.set(this, "-".repeat(2));
        _FormDataEncoder_encoder.set(this, new TextEncoder());
        _FormDataEncoder_footer.set(this, void 0);
        _FormDataEncoder_form.set(this, void 0);
        _FormDataEncoder_options.set(this, void 0);
        if (!(0,_util_isFormData_js__WEBPACK_IMPORTED_MODULE_0__.isFormData)(form)) {
            throw new TypeError("Expected first argument to be a FormData instance.");
        }
        let boundary;
        if ((0,_util_isPlainObject_js__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(boundaryOrOptions)) {
            options = boundaryOrOptions;
        }
        else {
            boundary = boundaryOrOptions;
        }
        if (!boundary) {
            boundary = (0,_util_createBoundary_js__WEBPACK_IMPORTED_MODULE_2__.createBoundary)();
        }
        if (typeof boundary !== "string") {
            throw new TypeError("Expected boundary argument to be a string.");
        }
        if (options && !(0,_util_isPlainObject_js__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options)) {
            throw new TypeError("Expected options argument to be an object.");
        }
        __classPrivateFieldSet(this, _FormDataEncoder_form, Array.from(form.entries()), "f");
        __classPrivateFieldSet(this, _FormDataEncoder_options, { ...defaultOptions, ...options }, "f");
        __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")), "f");
        __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f").byteLength, "f");
        this.boundary = `form-data-boundary-${boundary}`;
        this.contentType = `multipart/form-data; boundary=${this.boundary}`;
        __classPrivateFieldSet(this, _FormDataEncoder_footer, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
        const headers = {
            "Content-Type": this.contentType
        };
        const contentLength = __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getContentLength).call(this);
        if (contentLength) {
            this.contentLength = contentLength;
            headers["Content-Length"] = contentLength;
        }
        this.headers = (0,_util_proxyHeaders_js__WEBPACK_IMPORTED_MODULE_3__.proxyHeaders)(Object.freeze(headers));
        Object.defineProperties(this, {
            boundary: readonlyProp,
            contentType: readonlyProp,
            contentLength: readonlyProp,
            headers: readonlyProp
        });
    }
    getContentLength() {
        return this.contentLength == null ? undefined : Number(this.contentLength);
    }
    *values() {
        for (const [name, raw] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f")) {
            const value = (0,_util_isFile_js__WEBPACK_IMPORTED_MODULE_4__.isFile)(raw) ? raw : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode((0,_util_normalizeValue_js__WEBPACK_IMPORTED_MODULE_5__.normalizeValue)(raw));
            yield __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value);
            yield value;
            yield __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f");
        }
        yield __classPrivateFieldGet(this, _FormDataEncoder_footer, "f");
    }
    async *encode() {
        for (const part of this.values()) {
            if ((0,_util_isFile_js__WEBPACK_IMPORTED_MODULE_4__.isFile)(part)) {
                yield* (0,_util_getStreamIterator_js__WEBPACK_IMPORTED_MODULE_6__.getStreamIterator)(part.stream());
            }
            else {
                yield part;
            }
        }
    }
    [(_FormDataEncoder_CRLF = new WeakMap(), _FormDataEncoder_CRLF_BYTES = new WeakMap(), _FormDataEncoder_CRLF_BYTES_LENGTH = new WeakMap(), _FormDataEncoder_DASHES = new WeakMap(), _FormDataEncoder_encoder = new WeakMap(), _FormDataEncoder_footer = new WeakMap(), _FormDataEncoder_form = new WeakMap(), _FormDataEncoder_options = new WeakMap(), _FormDataEncoder_instances = new WeakSet(), _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader(name, value) {
        let header = "";
        header += `${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
        header += `Content-Disposition: form-data; name="${(0,_util_escapeName_js__WEBPACK_IMPORTED_MODULE_7__.escapeName)(name)}"`;
        if ((0,_util_isFile_js__WEBPACK_IMPORTED_MODULE_4__.isFile)(value)) {
            header += `; filename="${(0,_util_escapeName_js__WEBPACK_IMPORTED_MODULE_7__.escapeName)(value.name)}"${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
            header += `Content-Type: ${value.type || "application/octet-stream"}`;
        }
        const size = (0,_util_isFile_js__WEBPACK_IMPORTED_MODULE_4__.isFile)(value) ? value.size : value.byteLength;
        if (__classPrivateFieldGet(this, _FormDataEncoder_options, "f").enableAdditionalHeaders === true
            && size != null
            && !isNaN(size)) {
            header += `${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}Content-Length: ${(0,_util_isFile_js__WEBPACK_IMPORTED_MODULE_4__.isFile)(value) ? value.size : value.byteLength}`;
        }
        return __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${header}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`);
    }, _FormDataEncoder_getContentLength = function _FormDataEncoder_getContentLength() {
        let length = 0;
        for (const [name, raw] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f")) {
            const value = (0,_util_isFile_js__WEBPACK_IMPORTED_MODULE_4__.isFile)(raw) ? raw : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode((0,_util_normalizeValue_js__WEBPACK_IMPORTED_MODULE_5__.normalizeValue)(raw));
            const size = (0,_util_isFile_js__WEBPACK_IMPORTED_MODULE_4__.isFile)(value) ? value.size : value.byteLength;
            if (size == null || isNaN(size)) {
                return undefined;
            }
            length += __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;
            length += size;
            length += __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, "f");
        }
        return String(length + __classPrivateFieldGet(this, _FormDataEncoder_footer, "f").byteLength);
    }, Symbol.iterator)]() {
        return this.values();
    }
    [Symbol.asyncIterator]() {
        return this.encode();
    }
}


/***/ }),

/***/ "./node_modules/form-data-encoder/lib/util/createBoundary.js":
/*!*******************************************************************!*\
  !*** ./node_modules/form-data-encoder/lib/util/createBoundary.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createBoundary": () => (/* binding */ createBoundary)
/* harmony export */ });
const alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
function createBoundary() {
    let size = 16;
    let res = "";
    while (size--) {
        res += alphabet[(Math.random() * alphabet.length) << 0];
    }
    return res;
}


/***/ }),

/***/ "./node_modules/form-data-encoder/lib/util/escapeName.js":
/*!***************************************************************!*\
  !*** ./node_modules/form-data-encoder/lib/util/escapeName.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "escapeName": () => (/* binding */ escapeName)
/* harmony export */ });
const escapeName = (name) => String(name)
    .replace(/\r/g, "%0D")
    .replace(/\n/g, "%0A")
    .replace(/"/g, "%22");


/***/ }),

/***/ "./node_modules/form-data-encoder/lib/util/getStreamIterator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/form-data-encoder/lib/util/getStreamIterator.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getStreamIterator": () => (/* binding */ getStreamIterator)
/* harmony export */ });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/form-data-encoder/lib/util/isFunction.js");

const isAsyncIterable = (value) => ((0,_isFunction_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value[Symbol.asyncIterator]));
async function* readStream(readable) {
    const reader = readable.getReader();
    while (true) {
        const { done, value } = await reader.read();
        if (done) {
            break;
        }
        yield value;
    }
}
const getStreamIterator = (source) => {
    if (isAsyncIterable(source)) {
        return source;
    }
    if ((0,_isFunction_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source.getReader)) {
        return readStream(source);
    }
    throw new TypeError("Unsupported data source: Expected either ReadableStream or async iterable.");
};


/***/ }),

/***/ "./node_modules/form-data-encoder/lib/util/isFile.js":
/*!***********************************************************!*\
  !*** ./node_modules/form-data-encoder/lib/util/isFile.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isFile": () => (/* binding */ isFile),
/* harmony export */   "isFileLike": () => (/* binding */ isFileLike)
/* harmony export */ });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/form-data-encoder/lib/util/isFunction.js");

const isFile = (value) => Boolean(value
    && typeof value === "object"
    && (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value.constructor)
    && value[Symbol.toStringTag] === "File"
    && (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value.stream)
    && value.name != null);
const isFileLike = isFile;


/***/ }),

/***/ "./node_modules/form-data-encoder/lib/util/isFormData.js":
/*!***************************************************************!*\
  !*** ./node_modules/form-data-encoder/lib/util/isFormData.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isFormData": () => (/* binding */ isFormData)
/* harmony export */ });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/form-data-encoder/lib/util/isFunction.js");

const isFormData = (value) => Boolean(value
    && (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value.constructor)
    && value[Symbol.toStringTag] === "FormData"
    && (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value.append)
    && (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value.getAll)
    && (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value.entries)
    && (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value[Symbol.iterator]));


/***/ }),

/***/ "./node_modules/form-data-encoder/lib/util/isFunction.js":
/*!***************************************************************!*\
  !*** ./node_modules/form-data-encoder/lib/util/isFunction.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isFunction": () => (/* binding */ isFunction)
/* harmony export */ });
const isFunction = (value) => (typeof value === "function");


/***/ }),

/***/ "./node_modules/form-data-encoder/lib/util/isPlainObject.js":
/*!******************************************************************!*\
  !*** ./node_modules/form-data-encoder/lib/util/isPlainObject.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject)
/* harmony export */ });
const getType = (value) => (Object.prototype.toString.call(value).slice(8, -1).toLowerCase());
function isPlainObject(value) {
    if (getType(value) !== "object") {
        return false;
    }
    const pp = Object.getPrototypeOf(value);
    if (pp === null || pp === undefined) {
        return true;
    }
    const Ctor = pp.constructor && pp.constructor.toString();
    return Ctor === Object.toString();
}


/***/ }),

/***/ "./node_modules/form-data-encoder/lib/util/normalizeValue.js":
/*!*******************************************************************!*\
  !*** ./node_modules/form-data-encoder/lib/util/normalizeValue.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normalizeValue": () => (/* binding */ normalizeValue)
/* harmony export */ });
const normalizeValue = (value) => String(value)
    .replace(/\r|\n/g, (match, i, str) => {
    if ((match === "\r" && str[i + 1] !== "\n")
        || (match === "\n" && str[i - 1] !== "\r")) {
        return "\r\n";
    }
    return match;
});


/***/ }),

/***/ "./node_modules/form-data-encoder/lib/util/proxyHeaders.js":
/*!*****************************************************************!*\
  !*** ./node_modules/form-data-encoder/lib/util/proxyHeaders.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "proxyHeaders": () => (/* binding */ proxyHeaders)
/* harmony export */ });
function getProperty(target, prop) {
    if (typeof prop === "string") {
        for (const [name, value] of Object.entries(target)) {
            if (prop.toLowerCase() === name.toLowerCase()) {
                return value;
            }
        }
    }
    return undefined;
}
const proxyHeaders = (object) => new Proxy(object, {
    get: (target, prop) => getProperty(target, prop),
    has: (target, prop) => getProperty(target, prop) !== undefined
});


/***/ }),

/***/ "./node_modules/got/dist/source/as-promise/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/got/dist/source/as-promise/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ asPromise)
/* harmony export */ });
/* harmony import */ var node_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:events */ "node:events");
/* harmony import */ var _sindresorhus_is__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sindresorhus/is */ "./node_modules/@sindresorhus/is/dist/index.js");
/* harmony import */ var p_cancelable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-cancelable */ "./node_modules/p-cancelable/index.js");
/* harmony import */ var _core_errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/errors.js */ "./node_modules/got/dist/source/core/errors.js");
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/index.js */ "./node_modules/got/dist/source/core/index.js");
/* harmony import */ var _core_response_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/response.js */ "./node_modules/got/dist/source/core/response.js");
/* harmony import */ var _core_utils_proxy_events_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/utils/proxy-events.js */ "./node_modules/got/dist/source/core/utils/proxy-events.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ "./node_modules/got/dist/source/as-promise/types.js");








const proxiedRequestEvents = [
    'request',
    'response',
    'redirect',
    'uploadProgress',
    'downloadProgress',
];
function asPromise(firstRequest) {
    let globalRequest;
    let globalResponse;
    let normalizedOptions;
    const emitter = new node_events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    const promise = new p_cancelable__WEBPACK_IMPORTED_MODULE_1__["default"]((resolve, reject, onCancel) => {
        onCancel(() => {
            globalRequest.destroy();
        });
        onCancel.shouldReject = false;
        onCancel(() => {
            reject(new _types_js__WEBPACK_IMPORTED_MODULE_2__.CancelError(globalRequest));
        });
        const makeRequest = (retryCount) => {
            // Errors when a new request is made after the promise settles.
            // Used to detect a race condition.
            // See https://github.com/sindresorhus/got/issues/1489
            onCancel(() => { });
            const request = firstRequest ?? new _core_index_js__WEBPACK_IMPORTED_MODULE_3__["default"](undefined, undefined, normalizedOptions);
            request.retryCount = retryCount;
            request._noPipe = true;
            globalRequest = request;
            request.once('response', async (response) => {
                // Parse body
                const contentEncoding = (response.headers['content-encoding'] ?? '').toLowerCase();
                const isCompressed = contentEncoding === 'gzip' || contentEncoding === 'deflate' || contentEncoding === 'br';
                const { options } = request;
                if (isCompressed && !options.decompress) {
                    response.body = response.rawBody;
                }
                else {
                    try {
                        response.body = (0,_core_response_js__WEBPACK_IMPORTED_MODULE_4__.parseBody)(response, options.responseType, options.parseJson, options.encoding);
                    }
                    catch (error) {
                        // Fall back to `utf8`
                        response.body = response.rawBody.toString();
                        if ((0,_core_response_js__WEBPACK_IMPORTED_MODULE_4__.isResponseOk)(response)) {
                            request._beforeError(error);
                            return;
                        }
                    }
                }
                try {
                    const hooks = options.hooks.afterResponse;
                    for (const [index, hook] of hooks.entries()) {
                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise
                        // eslint-disable-next-line no-await-in-loop
                        response = await hook(response, async (updatedOptions) => {
                            options.merge(updatedOptions);
                            options.prefixUrl = '';
                            if (updatedOptions.url) {
                                options.url = updatedOptions.url;
                            }
                            // Remove any further hooks for that request, because we'll call them anyway.
                            // The loop continues. We don't want duplicates (asPromise recursion).
                            options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);
                            throw new _core_errors_js__WEBPACK_IMPORTED_MODULE_5__.RetryError(request);
                        });
                        if (!(_sindresorhus_is__WEBPACK_IMPORTED_MODULE_6__["default"].object(response) && _sindresorhus_is__WEBPACK_IMPORTED_MODULE_6__["default"].number(response.statusCode) && !_sindresorhus_is__WEBPACK_IMPORTED_MODULE_6__["default"].nullOrUndefined(response.body))) {
                            throw new TypeError('The `afterResponse` hook returned an invalid value');
                        }
                    }
                }
                catch (error) {
                    request._beforeError(error);
                    return;
                }
                globalResponse = response;
                if (!(0,_core_response_js__WEBPACK_IMPORTED_MODULE_4__.isResponseOk)(response)) {
                    request._beforeError(new _core_errors_js__WEBPACK_IMPORTED_MODULE_5__.HTTPError(response));
                    return;
                }
                request.destroy();
                resolve(request.options.resolveBodyOnly ? response.body : response);
            });
            const onError = (error) => {
                if (promise.isCanceled) {
                    return;
                }
                const { options } = request;
                if (error instanceof _core_errors_js__WEBPACK_IMPORTED_MODULE_5__.HTTPError && !options.throwHttpErrors) {
                    const { response } = error;
                    request.destroy();
                    resolve(request.options.resolveBodyOnly ? response.body : response);
                    return;
                }
                reject(error);
            };
            request.once('error', onError);
            const previousBody = request.options?.body;
            request.once('retry', (newRetryCount, error) => {
                firstRequest = undefined;
                const newBody = request.options.body;
                if (previousBody === newBody && _sindresorhus_is__WEBPACK_IMPORTED_MODULE_6__["default"].nodeStream(newBody)) {
                    error.message = 'Cannot retry with consumed body stream';
                    onError(error);
                    return;
                }
                // This is needed! We need to reuse `request.options` because they can get modified!
                // For example, by calling `promise.json()`.
                normalizedOptions = request.options;
                makeRequest(newRetryCount);
            });
            (0,_core_utils_proxy_events_js__WEBPACK_IMPORTED_MODULE_7__["default"])(request, emitter, proxiedRequestEvents);
            if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_6__["default"].undefined(firstRequest)) {
                void request.flush();
            }
        };
        makeRequest(0);
    });
    promise.on = (event, fn) => {
        emitter.on(event, fn);
        return promise;
    };
    promise.off = (event, fn) => {
        emitter.off(event, fn);
        return promise;
    };
    const shortcut = (responseType) => {
        const newPromise = (async () => {
            // Wait until downloading has ended
            await promise;
            const { options } = globalResponse.request;
            return (0,_core_response_js__WEBPACK_IMPORTED_MODULE_4__.parseBody)(globalResponse, responseType, options.parseJson, options.encoding);
        })();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
        return newPromise;
    };
    promise.json = () => {
        if (globalRequest.options) {
            const { headers } = globalRequest.options;
            if (!globalRequest.writableFinished && !('accept' in headers)) {
                headers.accept = 'application/json';
            }
        }
        return shortcut('json');
    };
    promise.buffer = () => shortcut('buffer');
    promise.text = () => shortcut('text');
    return promise;
}


/***/ }),

/***/ "./node_modules/got/dist/source/as-promise/types.js":
/*!**********************************************************!*\
  !*** ./node_modules/got/dist/source/as-promise/types.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CancelError": () => (/* binding */ CancelError)
/* harmony export */ });
/* harmony import */ var _core_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/errors.js */ "./node_modules/got/dist/source/core/errors.js");

/**
An error to be thrown when the request is aborted with `.cancel()`.
*/
class CancelError extends _core_errors_js__WEBPACK_IMPORTED_MODULE_0__.RequestError {
    constructor(request) {
        super('Promise was canceled', {}, request);
        this.name = 'CancelError';
        this.code = 'ERR_CANCELED';
    }
    /**
    Whether the promise is canceled.
    */
    get isCanceled() {
        return true;
    }
}


/***/ }),

/***/ "./node_modules/got/dist/source/core/calculate-retry-delay.js":
/*!********************************************************************!*\
  !*** ./node_modules/got/dist/source/core/calculate-retry-delay.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const calculateRetryDelay = ({ attemptCount, retryOptions, error, retryAfter, computedValue, }) => {
    if (error.name === 'RetryError') {
        return 1;
    }
    if (attemptCount > retryOptions.limit) {
        return 0;
    }
    const hasMethod = retryOptions.methods.includes(error.options.method);
    const hasErrorCode = retryOptions.errorCodes.includes(error.code);
    const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
    if (!hasMethod || (!hasErrorCode && !hasStatusCode)) {
        return 0;
    }
    if (error.response) {
        if (retryAfter) {
            // In this case `computedValue` is `options.request.timeout`
            if (retryAfter > computedValue) {
                return 0;
            }
            return retryAfter;
        }
        if (error.response.statusCode === 413) {
            return 0;
        }
    }
    const noise = Math.random() * retryOptions.noise;
    return Math.min(((2 ** (attemptCount - 1)) * 1000), retryOptions.backoffLimit) + noise;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (calculateRetryDelay);


/***/ }),

/***/ "./node_modules/got/dist/source/core/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/got/dist/source/core/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbortError": () => (/* binding */ AbortError),
/* harmony export */   "CacheError": () => (/* binding */ CacheError),
/* harmony export */   "HTTPError": () => (/* binding */ HTTPError),
/* harmony export */   "MaxRedirectsError": () => (/* binding */ MaxRedirectsError),
/* harmony export */   "ReadError": () => (/* binding */ ReadError),
/* harmony export */   "RequestError": () => (/* binding */ RequestError),
/* harmony export */   "RetryError": () => (/* binding */ RetryError),
/* harmony export */   "TimeoutError": () => (/* binding */ TimeoutError),
/* harmony export */   "UploadError": () => (/* binding */ UploadError)
/* harmony export */ });
/* harmony import */ var _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sindresorhus/is */ "./node_modules/@sindresorhus/is/dist/index.js");

// A hacky check to prevent circular references.
function isRequest(x) {
    return _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__["default"].object(x) && '_onResponse' in x;
}
/**
An error to be thrown when a request fails.
Contains a `code` property with error class code, like `ECONNREFUSED`.
*/
class RequestError extends Error {
    constructor(message, error, self) {
        super(message);
        Object.defineProperty(this, "input", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "stack", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "timings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Error.captureStackTrace(this, this.constructor);
        this.name = 'RequestError';
        this.code = error.code ?? 'ERR_GOT_REQUEST_ERROR';
        this.input = error.input;
        if (isRequest(self)) {
            Object.defineProperty(this, 'request', {
                enumerable: false,
                value: self,
            });
            Object.defineProperty(this, 'response', {
                enumerable: false,
                value: self.response,
            });
            this.options = self.options;
        }
        else {
            this.options = self;
        }
        this.timings = this.request?.timings;
        // Recover the original stacktrace
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__["default"].string(error.stack) && _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__["default"].string(this.stack)) {
            const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
            const thisStackTrace = this.stack.slice(indexOfMessage).split('\n').reverse();
            const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split('\n').reverse();
            // Remove duplicated traces
            while (errorStackTrace.length > 0 && errorStackTrace[0] === thisStackTrace[0]) {
                thisStackTrace.shift();
            }
            this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join('\n')}${errorStackTrace.reverse().join('\n')}`;
        }
    }
}
/**
An error to be thrown when the server redirects you more than ten times.
Includes a `response` property.
*/
class MaxRedirectsError extends RequestError {
    constructor(request) {
        super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);
        this.name = 'MaxRedirectsError';
        this.code = 'ERR_TOO_MANY_REDIRECTS';
    }
}
/**
An error to be thrown when the server response code is not 2xx nor 3xx if `options.followRedirect` is `true`, but always except for 304.
Includes a `response` property.
*/
// eslint-disable-next-line @typescript-eslint/naming-convention
class HTTPError extends RequestError {
    constructor(response) {
        super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
        this.name = 'HTTPError';
        this.code = 'ERR_NON_2XX_3XX_RESPONSE';
    }
}
/**
An error to be thrown when a cache method fails.
For example, if the database goes down or there's a filesystem error.
*/
class CacheError extends RequestError {
    constructor(error, request) {
        super(error.message, error, request);
        this.name = 'CacheError';
        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_CACHE_ACCESS' : this.code;
    }
}
/**
An error to be thrown when the request body is a stream and an error occurs while reading from that stream.
*/
class UploadError extends RequestError {
    constructor(error, request) {
        super(error.message, error, request);
        this.name = 'UploadError';
        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_UPLOAD' : this.code;
    }
}
/**
An error to be thrown when the request is aborted due to a timeout.
Includes an `event` and `timings` property.
*/
class TimeoutError extends RequestError {
    constructor(error, timings, request) {
        super(error.message, error, request);
        Object.defineProperty(this, "timings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "event", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'TimeoutError';
        this.event = error.event;
        this.timings = timings;
    }
}
/**
An error to be thrown when reading from response stream fails.
*/
class ReadError extends RequestError {
    constructor(error, request) {
        super(error.message, error, request);
        this.name = 'ReadError';
        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_READING_RESPONSE_STREAM' : this.code;
    }
}
/**
An error which always triggers a new retry when thrown.
*/
class RetryError extends RequestError {
    constructor(request) {
        super('Retrying', {}, request);
        this.name = 'RetryError';
        this.code = 'ERR_RETRYING';
    }
}
/**
An error to be thrown when the request is aborted by AbortController.
*/
class AbortError extends RequestError {
    constructor(request) {
        super('This operation was aborted.', {}, request);
        this.code = 'ERR_ABORTED';
        this.name = 'AbortError';
    }
}


/***/ }),

/***/ "./node_modules/got/dist/source/core/index.js":
/*!****************************************************!*\
  !*** ./node_modules/got/dist/source/core/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Request)
/* harmony export */ });
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ "node:process");
/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:buffer */ "node:buffer");
/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:stream */ "node:stream");
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:url */ "node:url");
/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:http */ "node:http");
/* harmony import */ var _szmarczak_http_timer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @szmarczak/http-timer */ "./node_modules/@szmarczak/http-timer/dist/source/index.js");
/* harmony import */ var cacheable_request__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cacheable-request */ "./node_modules/cacheable-request/dist/index.js");
/* harmony import */ var decompress_response__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! decompress-response */ "./node_modules/decompress-response/index.js");
/* harmony import */ var _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sindresorhus/is */ "./node_modules/@sindresorhus/is/dist/index.js");
/* harmony import */ var get_stream__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! get-stream */ "./node_modules/get-stream/index.js");
/* harmony import */ var form_data_encoder__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! form-data-encoder */ "./node_modules/form-data-encoder/lib/util/isFormData.js");
/* harmony import */ var form_data_encoder__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! form-data-encoder */ "./node_modules/form-data-encoder/lib/FormDataEncoder.js");
/* harmony import */ var _utils_get_body_size_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./utils/get-body-size.js */ "./node_modules/got/dist/source/core/utils/get-body-size.js");
/* harmony import */ var _utils_is_form_data_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/is-form-data.js */ "./node_modules/got/dist/source/core/utils/is-form-data.js");
/* harmony import */ var _utils_proxy_events_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./utils/proxy-events.js */ "./node_modules/got/dist/source/core/utils/proxy-events.js");
/* harmony import */ var _timed_out_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./timed-out.js */ "./node_modules/got/dist/source/core/timed-out.js");
/* harmony import */ var _utils_url_to_options_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./utils/url-to-options.js */ "./node_modules/got/dist/source/core/utils/url-to-options.js");
/* harmony import */ var _utils_weakable_map_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/weakable-map.js */ "./node_modules/got/dist/source/core/utils/weakable-map.js");
/* harmony import */ var _calculate_retry_delay_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./calculate-retry-delay.js */ "./node_modules/got/dist/source/core/calculate-retry-delay.js");
/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./options.js */ "./node_modules/got/dist/source/core/options.js");
/* harmony import */ var _response_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./response.js */ "./node_modules/got/dist/source/core/response.js");
/* harmony import */ var _utils_is_client_request_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./utils/is-client-request.js */ "./node_modules/got/dist/source/core/utils/is-client-request.js");
/* harmony import */ var _utils_is_unix_socket_url_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./utils/is-unix-socket-url.js */ "./node_modules/got/dist/source/core/utils/is-unix-socket-url.js");
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./errors.js */ "./node_modules/got/dist/source/core/errors.js");























const supportsBrotli = _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string(node_process__WEBPACK_IMPORTED_MODULE_0__.versions.brotli);
const methodsWithoutBody = new Set(['GET', 'HEAD']);
const cacheableStore = new _utils_weakable_map_js__WEBPACK_IMPORTED_MODULE_10__["default"]();
const redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);
const proxiedRequestEvents = [
    'socket',
    'connect',
    'continue',
    'information',
    'upgrade',
];
const noop = () => { };
class Request extends node_stream__WEBPACK_IMPORTED_MODULE_2__.Duplex {
    constructor(url, options, defaults) {
        super({
            // Don't destroy immediately, as the error may be emitted on unsuccessful retry
            autoDestroy: false,
            // It needs to be zero because we're just proxying the data to another stream
            highWaterMark: 0,
        });
        // @ts-expect-error - Ignoring for now.
        Object.defineProperty(this, 'constructor', {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_noPipe", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "requestUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "redirectUrls", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "retryCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_stopRetry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downloadedSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_uploadedSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_stopReading", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_pipedServerResponses", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_responseSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_bodySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_unproxyEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_isFromCache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_cannotHaveBody", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_triggerRead", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_cancelTimeouts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_removeListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_nativeResponse", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_flushed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_aborted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // We need this because `this._request` if `undefined` when using cache
        Object.defineProperty(this, "_requestInitialized", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._downloadedSize = 0;
        this._uploadedSize = 0;
        this._stopReading = false;
        this._pipedServerResponses = new Set();
        this._cannotHaveBody = false;
        this._unproxyEvents = noop;
        this._triggerRead = false;
        this._cancelTimeouts = noop;
        this._removeListeners = noop;
        this._jobs = [];
        this._flushed = false;
        this._requestInitialized = false;
        this._aborted = false;
        this.redirectUrls = [];
        this.retryCount = 0;
        this._stopRetry = noop;
        this.on('pipe', source => {
            if (source.headers) {
                Object.assign(this.options.headers, source.headers);
            }
        });
        this.on('newListener', event => {
            if (event === 'retry' && this.listenerCount('retry') > 0) {
                throw new Error('A retry listener has been attached already.');
            }
        });
        try {
            this.options = new _options_js__WEBPACK_IMPORTED_MODULE_11__["default"](url, options, defaults);
            if (!this.options.url) {
                if (this.options.prefixUrl === '') {
                    throw new TypeError('Missing `url` property');
                }
                this.options.url = '';
            }
            this.requestUrl = this.options.url;
        }
        catch (error) {
            const { options } = error;
            if (options) {
                this.options = options;
            }
            this.flush = async () => {
                this.flush = async () => { };
                this.destroy(error);
            };
            return;
        }
        // Important! If you replace `body` in a handler with another stream, make sure it's readable first.
        // The below is run only once.
        const { body } = this.options;
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].nodeStream(body)) {
            body.once('error', error => {
                if (this._flushed) {
                    this._beforeError(new _errors_js__WEBPACK_IMPORTED_MODULE_12__.UploadError(error, this));
                }
                else {
                    this.flush = async () => {
                        this.flush = async () => { };
                        this._beforeError(new _errors_js__WEBPACK_IMPORTED_MODULE_12__.UploadError(error, this));
                    };
                }
            });
        }
        if (this.options.signal) {
            const abort = () => {
                this.destroy(new _errors_js__WEBPACK_IMPORTED_MODULE_12__.AbortError(this));
            };
            if (this.options.signal.aborted) {
                abort();
            }
            else {
                this.options.signal.addEventListener('abort', abort);
                this._removeListeners = () => {
                    this.options.signal.removeEventListener('abort', abort);
                };
            }
        }
    }
    async flush() {
        if (this._flushed) {
            return;
        }
        this._flushed = true;
        try {
            await this._finalizeBody();
            if (this.destroyed) {
                return;
            }
            await this._makeRequest();
            if (this.destroyed) {
                this._request?.destroy();
                return;
            }
            // Queued writes etc.
            for (const job of this._jobs) {
                job();
            }
            // Prevent memory leak
            this._jobs.length = 0;
            this._requestInitialized = true;
        }
        catch (error) {
            this._beforeError(error);
        }
    }
    _beforeError(error) {
        if (this._stopReading) {
            return;
        }
        const { response, options } = this;
        const attemptCount = this.retryCount + (error.name === 'RetryError' ? 0 : 1);
        this._stopReading = true;
        if (!(error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_12__.RequestError)) {
            error = new _errors_js__WEBPACK_IMPORTED_MODULE_12__.RequestError(error.message, error, this);
        }
        const typedError = error;
        void (async () => {
            // Node.js parser is really weird.
            // It emits post-request Parse Errors on the same instance as previous request. WTF.
            // Therefore we need to check if it has been destroyed as well.
            //
            // Furthermore, Node.js 16 `response.destroy()` doesn't immediately destroy the socket,
            // but makes the response unreadable. So we additionally need to check `response.readable`.
            if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {
                // @types/node has incorrect typings. `setEncoding` accepts `null` as well.
                response.setEncoding(this.readableEncoding);
                const success = await this._setRawBody(response);
                if (success) {
                    response.body = response.rawBody.toString();
                }
            }
            if (this.listenerCount('retry') !== 0) {
                let backoff;
                try {
                    let retryAfter;
                    if (response && 'retry-after' in response.headers) {
                        retryAfter = Number(response.headers['retry-after']);
                        if (Number.isNaN(retryAfter)) {
                            retryAfter = Date.parse(response.headers['retry-after']) - Date.now();
                            if (retryAfter <= 0) {
                                retryAfter = 1;
                            }
                        }
                        else {
                            retryAfter *= 1000;
                        }
                    }
                    const retryOptions = options.retry;
                    backoff = await retryOptions.calculateDelay({
                        attemptCount,
                        retryOptions,
                        error: typedError,
                        retryAfter,
                        computedValue: (0,_calculate_retry_delay_js__WEBPACK_IMPORTED_MODULE_13__["default"])({
                            attemptCount,
                            retryOptions,
                            error: typedError,
                            retryAfter,
                            computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY,
                        }),
                    });
                }
                catch (error_) {
                    void this._error(new _errors_js__WEBPACK_IMPORTED_MODULE_12__.RequestError(error_.message, error_, this));
                    return;
                }
                if (backoff) {
                    await new Promise(resolve => {
                        const timeout = setTimeout(resolve, backoff);
                        this._stopRetry = () => {
                            clearTimeout(timeout);
                            resolve();
                        };
                    });
                    // Something forced us to abort the retry
                    if (this.destroyed) {
                        return;
                    }
                    try {
                        for (const hook of this.options.hooks.beforeRetry) {
                            // eslint-disable-next-line no-await-in-loop
                            await hook(typedError, this.retryCount + 1);
                        }
                    }
                    catch (error_) {
                        void this._error(new _errors_js__WEBPACK_IMPORTED_MODULE_12__.RequestError(error_.message, error, this));
                        return;
                    }
                    // Something forced us to abort the retry
                    if (this.destroyed) {
                        return;
                    }
                    this.destroy();
                    this.emit('retry', this.retryCount + 1, error, (updatedOptions) => {
                        const request = new Request(options.url, updatedOptions, options);
                        request.retryCount = this.retryCount + 1;
                        node_process__WEBPACK_IMPORTED_MODULE_0__.nextTick(() => {
                            void request.flush();
                        });
                        return request;
                    });
                    return;
                }
            }
            void this._error(typedError);
        })();
    }
    _read() {
        this._triggerRead = true;
        const { response } = this;
        if (response && !this._stopReading) {
            // We cannot put this in the `if` above
            // because `.read()` also triggers the `end` event
            if (response.readableLength) {
                this._triggerRead = false;
            }
            let data;
            while ((data = response.read()) !== null) {
                this._downloadedSize += data.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands
                const progress = this.downloadProgress;
                if (progress.percent < 1) {
                    this.emit('downloadProgress', progress);
                }
                this.push(data);
            }
        }
    }
    _write(chunk, encoding, callback) {
        const write = () => {
            this._writeRequest(chunk, encoding, callback);
        };
        if (this._requestInitialized) {
            write();
        }
        else {
            this._jobs.push(write);
        }
    }
    _final(callback) {
        const endRequest = () => {
            // We need to check if `this._request` is present,
            // because it isn't when we use cache.
            if (!this._request || this._request.destroyed) {
                callback();
                return;
            }
            this._request.end((error) => {
                // The request has been destroyed before `_final` finished.
                // See https://github.com/nodejs/node/issues/39356
                if (this._request._writableState?.errored) {
                    return;
                }
                if (!error) {
                    this._bodySize = this._uploadedSize;
                    this.emit('uploadProgress', this.uploadProgress);
                    this._request.emit('upload-complete');
                }
                callback(error);
            });
        };
        if (this._requestInitialized) {
            endRequest();
        }
        else {
            this._jobs.push(endRequest);
        }
    }
    _destroy(error, callback) {
        this._stopReading = true;
        this.flush = async () => { };
        // Prevent further retries
        this._stopRetry();
        this._cancelTimeouts();
        this._removeListeners();
        if (this.options) {
            const { body } = this.options;
            if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].nodeStream(body)) {
                body.destroy();
            }
        }
        if (this._request) {
            this._request.destroy();
        }
        if (error !== null && !_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined(error) && !(error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_12__.RequestError)) {
            error = new _errors_js__WEBPACK_IMPORTED_MODULE_12__.RequestError(error.message, error, this);
        }
        callback(error);
    }
    pipe(destination, options) {
        if (destination instanceof node_http__WEBPACK_IMPORTED_MODULE_4__.ServerResponse) {
            this._pipedServerResponses.add(destination);
        }
        return super.pipe(destination, options);
    }
    unpipe(destination) {
        if (destination instanceof node_http__WEBPACK_IMPORTED_MODULE_4__.ServerResponse) {
            this._pipedServerResponses.delete(destination);
        }
        super.unpipe(destination);
        return this;
    }
    async _finalizeBody() {
        const { options } = this;
        const { headers } = options;
        const isForm = !_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined(options.form);
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const isJSON = !_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined(options.json);
        const isBody = !_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined(options.body);
        const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);
        this._cannotHaveBody = cannotHaveBody;
        if (isForm || isJSON || isBody) {
            if (cannotHaveBody) {
                throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
            }
            // Serialize body
            const noContentType = !_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string(headers['content-type']);
            if (isBody) {
                // Body is spec-compliant FormData
                if ((0,form_data_encoder__WEBPACK_IMPORTED_MODULE_14__.isFormData)(options.body)) {
                    const encoder = new form_data_encoder__WEBPACK_IMPORTED_MODULE_15__.FormDataEncoder(options.body);
                    if (noContentType) {
                        headers['content-type'] = encoder.headers['Content-Type'];
                    }
                    if ('Content-Length' in encoder.headers) {
                        headers['content-length'] = encoder.headers['Content-Length'];
                    }
                    options.body = encoder.encode();
                }
                // Special case for https://github.com/form-data/form-data
                if ((0,_utils_is_form_data_js__WEBPACK_IMPORTED_MODULE_16__["default"])(options.body) && noContentType) {
                    headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
                }
            }
            else if (isForm) {
                if (noContentType) {
                    headers['content-type'] = 'application/x-www-form-urlencoded';
                }
                const { form } = options;
                options.form = undefined;
                options.body = (new node_url__WEBPACK_IMPORTED_MODULE_3__.URLSearchParams(form)).toString();
            }
            else {
                if (noContentType) {
                    headers['content-type'] = 'application/json';
                }
                const { json } = options;
                options.json = undefined;
                options.body = options.stringifyJson(json);
            }
            const uploadBodySize = await (0,_utils_get_body_size_js__WEBPACK_IMPORTED_MODULE_17__["default"])(options.body, options.headers);
            // See https://tools.ietf.org/html/rfc7230#section-3.3.2
            // A user agent SHOULD send a Content-Length in a request message when
            // no Transfer-Encoding is sent and the request method defines a meaning
            // for an enclosed payload body.  For example, a Content-Length header
            // field is normally sent in a POST request even when the value is 0
            // (indicating an empty payload body).  A user agent SHOULD NOT send a
            // Content-Length header field when the request message does not contain
            // a payload body and the method semantics do not anticipate such a
            // body.
            if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined(headers['content-length']) && _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined(headers['transfer-encoding']) && !cannotHaveBody && !_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined(uploadBodySize)) {
                headers['content-length'] = String(uploadBodySize);
            }
        }
        if (options.responseType === 'json' && !('accept' in options.headers)) {
            options.headers.accept = 'application/json';
        }
        this._bodySize = Number(headers['content-length']) || undefined;
    }
    async _onResponseBase(response) {
        // This will be called e.g. when using cache so we need to check if this request has been aborted.
        if (this.isAborted) {
            return;
        }
        const { options } = this;
        const { url } = options;
        this._nativeResponse = response;
        if (options.decompress) {
            response = decompress_response__WEBPACK_IMPORTED_MODULE_7__(response);
        }
        const statusCode = response.statusCode;
        const typedResponse = response;
        typedResponse.statusMessage = typedResponse.statusMessage ?? node_http__WEBPACK_IMPORTED_MODULE_4__.STATUS_CODES[statusCode];
        typedResponse.url = options.url.toString();
        typedResponse.requestUrl = this.requestUrl;
        typedResponse.redirectUrls = this.redirectUrls;
        typedResponse.request = this;
        typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;
        typedResponse.ip = this.ip;
        typedResponse.retryCount = this.retryCount;
        typedResponse.ok = (0,_response_js__WEBPACK_IMPORTED_MODULE_18__.isResponseOk)(typedResponse);
        this._isFromCache = typedResponse.isFromCache;
        this._responseSize = Number(response.headers['content-length']) || undefined;
        this.response = typedResponse;
        response.once('end', () => {
            this._responseSize = this._downloadedSize;
            this.emit('downloadProgress', this.downloadProgress);
        });
        response.once('error', (error) => {
            this._aborted = true;
            // Force clean-up, because some packages don't do this.
            // TODO: Fix decompress-response
            response.destroy();
            this._beforeError(new _errors_js__WEBPACK_IMPORTED_MODULE_12__.ReadError(error, this));
        });
        response.once('aborted', () => {
            this._aborted = true;
            this._beforeError(new _errors_js__WEBPACK_IMPORTED_MODULE_12__.ReadError({
                name: 'Error',
                message: 'The server aborted pending request',
                code: 'ECONNRESET',
            }, this));
        });
        this.emit('downloadProgress', this.downloadProgress);
        const rawCookies = response.headers['set-cookie'];
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object(options.cookieJar) && rawCookies) {
            let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));
            if (options.ignoreInvalidCookies) {
                promises = promises.map(async (promise) => {
                    try {
                        await promise;
                    }
                    catch { }
                });
            }
            try {
                await Promise.all(promises);
            }
            catch (error) {
                this._beforeError(error);
                return;
            }
        }
        // The above is running a promise, therefore we need to check if this request has been aborted yet again.
        if (this.isAborted) {
            return;
        }
        if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {
            // We're being redirected, we don't care about the response.
            // It'd be best to abort the request, but we can't because
            // we would have to sacrifice the TCP connection. We don't want that.
            response.resume();
            this._cancelTimeouts();
            this._unproxyEvents();
            if (this.redirectUrls.length >= options.maxRedirects) {
                this._beforeError(new _errors_js__WEBPACK_IMPORTED_MODULE_12__.MaxRedirectsError(this));
                return;
            }
            this._request = undefined;
            const updatedOptions = new _options_js__WEBPACK_IMPORTED_MODULE_11__["default"](undefined, undefined, this.options);
            const serverRequestedGet = statusCode === 303 && updatedOptions.method !== 'GET' && updatedOptions.method !== 'HEAD';
            const canRewrite = statusCode !== 307 && statusCode !== 308;
            const userRequestedGet = updatedOptions.methodRewriting && canRewrite;
            if (serverRequestedGet || userRequestedGet) {
                updatedOptions.method = 'GET';
                updatedOptions.body = undefined;
                updatedOptions.json = undefined;
                updatedOptions.form = undefined;
                delete updatedOptions.headers['content-length'];
            }
            try {
                // We need this in order to support UTF-8
                const redirectBuffer = node_buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(response.headers.location, 'binary').toString();
                const redirectUrl = new node_url__WEBPACK_IMPORTED_MODULE_3__.URL(redirectBuffer, url);
                if (!(0,_utils_is_unix_socket_url_js__WEBPACK_IMPORTED_MODULE_19__["default"])(url) && (0,_utils_is_unix_socket_url_js__WEBPACK_IMPORTED_MODULE_19__["default"])(redirectUrl)) {
                    this._beforeError(new _errors_js__WEBPACK_IMPORTED_MODULE_12__.RequestError('Cannot redirect to UNIX socket', {}, this));
                    return;
                }
                // Redirecting to a different site, clear sensitive data.
                if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
                    if ('host' in updatedOptions.headers) {
                        delete updatedOptions.headers.host;
                    }
                    if ('cookie' in updatedOptions.headers) {
                        delete updatedOptions.headers.cookie;
                    }
                    if ('authorization' in updatedOptions.headers) {
                        delete updatedOptions.headers.authorization;
                    }
                    if (updatedOptions.username || updatedOptions.password) {
                        updatedOptions.username = '';
                        updatedOptions.password = '';
                    }
                }
                else {
                    redirectUrl.username = updatedOptions.username;
                    redirectUrl.password = updatedOptions.password;
                }
                this.redirectUrls.push(redirectUrl);
                updatedOptions.prefixUrl = '';
                updatedOptions.url = redirectUrl;
                for (const hook of updatedOptions.hooks.beforeRedirect) {
                    // eslint-disable-next-line no-await-in-loop
                    await hook(updatedOptions, typedResponse);
                }
                this.emit('redirect', updatedOptions, typedResponse);
                this.options = updatedOptions;
                await this._makeRequest();
            }
            catch (error) {
                this._beforeError(error);
                return;
            }
            return;
        }
        // `HTTPError`s always have `error.response.body` defined.
        // Therefore we cannot retry if `options.throwHttpErrors` is false.
        // On the last retry, if `options.throwHttpErrors` is false, we would need to return the body,
        // but that wouldn't be possible since the body would be already read in `error.response.body`.
        if (options.isStream && options.throwHttpErrors && !(0,_response_js__WEBPACK_IMPORTED_MODULE_18__.isResponseOk)(typedResponse)) {
            this._beforeError(new _errors_js__WEBPACK_IMPORTED_MODULE_12__.HTTPError(typedResponse));
            return;
        }
        response.on('readable', () => {
            if (this._triggerRead) {
                this._read();
            }
        });
        this.on('resume', () => {
            response.resume();
        });
        this.on('pause', () => {
            response.pause();
        });
        response.once('end', () => {
            this.push(null);
        });
        if (this._noPipe) {
            const success = await this._setRawBody();
            if (success) {
                this.emit('response', response);
            }
            return;
        }
        this.emit('response', response);
        for (const destination of this._pipedServerResponses) {
            if (destination.headersSent) {
                continue;
            }
            // eslint-disable-next-line guard-for-in
            for (const key in response.headers) {
                const isAllowed = options.decompress ? key !== 'content-encoding' : true;
                const value = response.headers[key];
                if (isAllowed) {
                    destination.setHeader(key, value);
                }
            }
            destination.statusCode = statusCode;
        }
    }
    async _setRawBody(from = this) {
        if (from.readableEnded) {
            return false;
        }
        try {
            // Errors are emitted via the `error` event
            const rawBody = await (0,get_stream__WEBPACK_IMPORTED_MODULE_8__.buffer)(from);
            // On retry Request is destroyed with no error, therefore the above will successfully resolve.
            // So in order to check if this was really successfull, we need to check if it has been properly ended.
            if (!this.isAborted) {
                this.response.rawBody = rawBody;
                return true;
            }
        }
        catch { }
        return false;
    }
    async _onResponse(response) {
        try {
            await this._onResponseBase(response);
        }
        catch (error) {
            /* istanbul ignore next: better safe than sorry */
            this._beforeError(error);
        }
    }
    _onRequest(request) {
        const { options } = this;
        const { timeout, url } = options;
        (0,_szmarczak_http_timer__WEBPACK_IMPORTED_MODULE_5__["default"])(request);
        if (this.options.http2) {
            // Unset stream timeout, as the `timeout` option was used only for connection timeout.
            request.setTimeout(0);
        }
        this._cancelTimeouts = (0,_timed_out_js__WEBPACK_IMPORTED_MODULE_20__["default"])(request, timeout, url);
        const responseEventName = options.cache ? 'cacheableResponse' : 'response';
        request.once(responseEventName, (response) => {
            void this._onResponse(response);
        });
        request.once('error', (error) => {
            this._aborted = true;
            // Force clean-up, because some packages (e.g. nock) don't do this.
            request.destroy();
            error = error instanceof _timed_out_js__WEBPACK_IMPORTED_MODULE_20__.TimeoutError ? new _errors_js__WEBPACK_IMPORTED_MODULE_12__.TimeoutError(error, this.timings, this) : new _errors_js__WEBPACK_IMPORTED_MODULE_12__.RequestError(error.message, error, this);
            this._beforeError(error);
        });
        this._unproxyEvents = (0,_utils_proxy_events_js__WEBPACK_IMPORTED_MODULE_21__["default"])(request, this, proxiedRequestEvents);
        this._request = request;
        this.emit('uploadProgress', this.uploadProgress);
        this._sendBody();
        this.emit('request', request);
    }
    async _asyncWrite(chunk) {
        return new Promise((resolve, reject) => {
            super.write(chunk, error => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve();
            });
        });
    }
    _sendBody() {
        // Send body
        const { body } = this.options;
        const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].nodeStream(body)) {
            body.pipe(currentRequest);
        }
        else if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].generator(body) || _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].asyncGenerator(body)) {
            (async () => {
                try {
                    for await (const chunk of body) {
                        await this._asyncWrite(chunk);
                    }
                    super.end();
                }
                catch (error) {
                    this._beforeError(error);
                }
            })();
        }
        else if (!_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined(body)) {
            this._writeRequest(body, undefined, () => { });
            currentRequest.end();
        }
        else if (this._cannotHaveBody || this._noPipe) {
            currentRequest.end();
        }
    }
    _prepareCache(cache) {
        if (!cacheableStore.has(cache)) {
            const cacheableRequest = new cacheable_request__WEBPACK_IMPORTED_MODULE_6__["default"](((requestOptions, handler) => {
                const result = requestOptions._request(requestOptions, handler);
                // TODO: remove this when `cacheable-request` supports async request functions.
                if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].promise(result)) {
                    // We only need to implement the error handler in order to support HTTP2 caching.
                    // The result will be a promise anyway.
                    // @ts-expect-error ignore
                    // eslint-disable-next-line @typescript-eslint/promise-function-async
                    result.once = (event, handler) => {
                        if (event === 'error') {
                            (async () => {
                                try {
                                    await result;
                                }
                                catch (error) {
                                    handler(error);
                                }
                            })();
                        }
                        else if (event === 'abort') {
                            // The empty catch is needed here in case when
                            // it rejects before it's `await`ed in `_makeRequest`.
                            (async () => {
                                try {
                                    const request = (await result);
                                    request.once('abort', handler);
                                }
                                catch { }
                            })();
                        }
                        else {
                            /* istanbul ignore next: safety check */
                            throw new Error(`Unknown HTTP2 promise event: ${event}`);
                        }
                        return result;
                    };
                }
                return result;
            }), cache);
            cacheableStore.set(cache, cacheableRequest.request());
        }
    }
    async _createCacheableRequest(url, options) {
        return new Promise((resolve, reject) => {
            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed
            Object.assign(options, (0,_utils_url_to_options_js__WEBPACK_IMPORTED_MODULE_22__["default"])(url));
            let request;
            // TODO: Fix `cacheable-response`. This is ugly.
            const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {
                response._readableState.autoDestroy = false;
                if (request) {
                    const fix = () => {
                        if (response.req) {
                            response.complete = response.req.res.complete;
                        }
                    };
                    response.prependOnceListener('end', fix);
                    fix();
                    (await request).emit('cacheableResponse', response);
                }
                resolve(response);
            });
            cacheRequest.once('error', reject);
            cacheRequest.once('request', async (requestOrPromise) => {
                request = requestOrPromise;
                resolve(request);
            });
        });
    }
    async _makeRequest() {
        const { options } = this;
        const { headers, username, password } = options;
        const cookieJar = options.cookieJar;
        for (const key in headers) {
            if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined(headers[key])) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete headers[key];
            }
            else if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].null_(headers[key])) {
                throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
            }
        }
        if (options.decompress && _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined(headers['accept-encoding'])) {
            headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';
        }
        if (username || password) {
            const credentials = node_buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(`${username}:${password}`).toString('base64');
            headers.authorization = `Basic ${credentials}`;
        }
        // Set cookies
        if (cookieJar) {
            const cookieString = await cookieJar.getCookieString(options.url.toString());
            if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].nonEmptyString(cookieString)) {
                headers.cookie = cookieString;
            }
        }
        // Reset `prefixUrl`
        options.prefixUrl = '';
        let request;
        for (const hook of options.hooks.beforeRequest) {
            // eslint-disable-next-line no-await-in-loop
            const result = await hook(options);
            if (!_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined(result)) {
                // @ts-expect-error Skip the type mismatch to support abstract responses
                request = () => result;
                break;
            }
        }
        if (!request) {
            request = options.getRequestFunction();
        }
        const url = options.url;
        this._requestOptions = options.createNativeRequestOptions();
        if (options.cache) {
            this._requestOptions._request = request;
            this._requestOptions.cache = options.cache;
            this._requestOptions.body = options.body;
            this._prepareCache(options.cache);
        }
        // Cache support
        const fn = options.cache ? this._createCacheableRequest : request;
        try {
            // We can't do `await fn(...)`,
            // because stream `error` event can be emitted before `Promise.resolve()`.
            let requestOrResponse = fn(url, this._requestOptions);
            if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].promise(requestOrResponse)) {
                requestOrResponse = await requestOrResponse;
            }
            // Fallback
            if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined(requestOrResponse)) {
                requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);
                if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].promise(requestOrResponse)) {
                    requestOrResponse = await requestOrResponse;
                }
            }
            if ((0,_utils_is_client_request_js__WEBPACK_IMPORTED_MODULE_23__["default"])(requestOrResponse)) {
                this._onRequest(requestOrResponse);
            }
            else if (this.writable) {
                this.once('finish', () => {
                    void this._onResponse(requestOrResponse);
                });
                this._sendBody();
            }
            else {
                void this._onResponse(requestOrResponse);
            }
        }
        catch (error) {
            if (error instanceof cacheable_request__WEBPACK_IMPORTED_MODULE_6__.CacheError) {
                throw new _errors_js__WEBPACK_IMPORTED_MODULE_12__.CacheError(error, this);
            }
            throw error;
        }
    }
    async _error(error) {
        try {
            if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_12__.HTTPError && !this.options.throwHttpErrors) {
                // This branch can be reached only when using the Promise API
                // Skip calling the hooks on purpose.
                // See https://github.com/sindresorhus/got/issues/2103
            }
            else {
                for (const hook of this.options.hooks.beforeError) {
                    // eslint-disable-next-line no-await-in-loop
                    error = await hook(error);
                }
            }
        }
        catch (error_) {
            error = new _errors_js__WEBPACK_IMPORTED_MODULE_12__.RequestError(error_.message, error_, this);
        }
        this.destroy(error);
    }
    _writeRequest(chunk, encoding, callback) {
        if (!this._request || this._request.destroyed) {
            // Probably the `ClientRequest` instance will throw
            return;
        }
        this._request.write(chunk, encoding, (error) => {
            // The `!destroyed` check is required to prevent `uploadProgress` being emitted after the stream was destroyed
            if (!error && !this._request.destroyed) {
                this._uploadedSize += node_buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.byteLength(chunk, encoding);
                const progress = this.uploadProgress;
                if (progress.percent < 1) {
                    this.emit('uploadProgress', progress);
                }
            }
            callback(error);
        });
    }
    /**
    The remote IP address.
    */
    get ip() {
        return this.socket?.remoteAddress;
    }
    /**
    Indicates whether the request has been aborted or not.
    */
    get isAborted() {
        return this._aborted;
    }
    get socket() {
        return this._request?.socket ?? undefined;
    }
    /**
    Progress event for downloading (receiving a response).
    */
    get downloadProgress() {
        let percent;
        if (this._responseSize) {
            percent = this._downloadedSize / this._responseSize;
        }
        else if (this._responseSize === this._downloadedSize) {
            percent = 1;
        }
        else {
            percent = 0;
        }
        return {
            percent,
            transferred: this._downloadedSize,
            total: this._responseSize,
        };
    }
    /**
    Progress event for uploading (sending a request).
    */
    get uploadProgress() {
        let percent;
        if (this._bodySize) {
            percent = this._uploadedSize / this._bodySize;
        }
        else if (this._bodySize === this._uploadedSize) {
            percent = 1;
        }
        else {
            percent = 0;
        }
        return {
            percent,
            transferred: this._uploadedSize,
            total: this._bodySize,
        };
    }
    /**
    The object contains the following properties:

    - `start` - Time when the request started.
    - `socket` - Time when a socket was assigned to the request.
    - `lookup` - Time when the DNS lookup finished.
    - `connect` - Time when the socket successfully connected.
    - `secureConnect` - Time when the socket securely connected.
    - `upload` - Time when the request finished uploading.
    - `response` - Time when the request fired `response` event.
    - `end` - Time when the response fired `end` event.
    - `error` - Time when the request fired `error` event.
    - `abort` - Time when the request fired `abort` event.
    - `phases`
        - `wait` - `timings.socket - timings.start`
        - `dns` - `timings.lookup - timings.socket`
        - `tcp` - `timings.connect - timings.lookup`
        - `tls` - `timings.secureConnect - timings.connect`
        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
        - `firstByte` - `timings.response - timings.upload`
        - `download` - `timings.end - timings.response`
        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`

    If something has not been measured yet, it will be `undefined`.

    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
    */
    get timings() {
        return this._request?.timings;
    }
    /**
    Whether the response was retrieved from the cache.
    */
    get isFromCache() {
        return this._isFromCache;
    }
    get reusedSocket() {
        return this._request?.reusedSocket;
    }
}


/***/ }),

/***/ "./node_modules/got/dist/source/core/options.js":
/*!******************************************************!*\
  !*** ./node_modules/got/dist/source/core/options.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Options)
/* harmony export */ });
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ "node:process");
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:url */ "node:url");
/* harmony import */ var node_tls__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:tls */ "node:tls");
/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:http */ "node:http");
/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:https */ "node:https");
/* harmony import */ var _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sindresorhus/is */ "./node_modules/@sindresorhus/is/dist/index.js");
/* harmony import */ var lowercase_keys__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lowercase-keys */ "./node_modules/lowercase-keys/index.js");
/* harmony import */ var cacheable_lookup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cacheable-lookup */ "./node_modules/cacheable-lookup/source/index.js");
/* harmony import */ var http2_wrapper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! http2-wrapper */ "./node_modules/http2-wrapper/source/index.js");
/* harmony import */ var form_data_encoder__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! form-data-encoder */ "./node_modules/form-data-encoder/lib/util/isFormData.js");
/* harmony import */ var _parse_link_header_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./parse-link-header.js */ "./node_modules/got/dist/source/core/parse-link-header.js");




// DO NOT use destructuring for `https.request` and `http.request` as it's not compatible with `nock`.








const [major, minor] = node_process__WEBPACK_IMPORTED_MODULE_0__.versions.node.split('.').map(Number);
function validateSearchParameters(searchParameters) {
    // eslint-disable-next-line guard-for-in
    for (const key in searchParameters) {
        const value = searchParameters[key];
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].number, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].boolean, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].null_, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
    }
}
const globalCache = new Map();
let globalDnsCache;
const getGlobalDnsCache = () => {
    if (globalDnsCache) {
        return globalDnsCache;
    }
    globalDnsCache = new cacheable_lookup__WEBPACK_IMPORTED_MODULE_7__["default"]();
    return globalDnsCache;
};
const defaultInternals = {
    request: undefined,
    agent: {
        http: undefined,
        https: undefined,
        http2: undefined,
    },
    h2session: undefined,
    decompress: true,
    timeout: {
        connect: undefined,
        lookup: undefined,
        read: undefined,
        request: undefined,
        response: undefined,
        secureConnect: undefined,
        send: undefined,
        socket: undefined,
    },
    prefixUrl: '',
    body: undefined,
    form: undefined,
    json: undefined,
    cookieJar: undefined,
    ignoreInvalidCookies: false,
    searchParams: undefined,
    dnsLookup: undefined,
    dnsCache: undefined,
    context: {},
    hooks: {
        init: [],
        beforeRequest: [],
        beforeError: [],
        beforeRedirect: [],
        beforeRetry: [],
        afterResponse: [],
    },
    followRedirect: true,
    maxRedirects: 10,
    cache: undefined,
    throwHttpErrors: true,
    username: '',
    password: '',
    http2: false,
    allowGetBody: false,
    headers: {
        'user-agent': 'got (https://github.com/sindresorhus/got)',
    },
    methodRewriting: false,
    dnsLookupIpVersion: undefined,
    parseJson: JSON.parse,
    stringifyJson: JSON.stringify,
    retry: {
        limit: 2,
        methods: [
            'GET',
            'PUT',
            'HEAD',
            'DELETE',
            'OPTIONS',
            'TRACE',
        ],
        statusCodes: [
            408,
            413,
            429,
            500,
            502,
            503,
            504,
            521,
            522,
            524,
        ],
        errorCodes: [
            'ETIMEDOUT',
            'ECONNRESET',
            'EADDRINUSE',
            'ECONNREFUSED',
            'EPIPE',
            'ENOTFOUND',
            'ENETUNREACH',
            'EAI_AGAIN',
        ],
        maxRetryAfter: undefined,
        calculateDelay: ({ computedValue }) => computedValue,
        backoffLimit: Number.POSITIVE_INFINITY,
        noise: 100,
    },
    localAddress: undefined,
    method: 'GET',
    createConnection: undefined,
    cacheOptions: {
        shared: undefined,
        cacheHeuristic: undefined,
        immutableMinTimeToLive: undefined,
        ignoreCargoCult: undefined,
    },
    https: {
        alpnProtocols: undefined,
        rejectUnauthorized: undefined,
        checkServerIdentity: undefined,
        certificateAuthority: undefined,
        key: undefined,
        certificate: undefined,
        passphrase: undefined,
        pfx: undefined,
        ciphers: undefined,
        honorCipherOrder: undefined,
        minVersion: undefined,
        maxVersion: undefined,
        signatureAlgorithms: undefined,
        tlsSessionLifetime: undefined,
        dhparam: undefined,
        ecdhCurve: undefined,
        certificateRevocationLists: undefined,
    },
    encoding: undefined,
    resolveBodyOnly: false,
    isStream: false,
    responseType: 'text',
    url: undefined,
    pagination: {
        transform(response) {
            if (response.request.options.responseType === 'json') {
                return response.body;
            }
            return JSON.parse(response.body);
        },
        paginate({ response }) {
            const rawLinkHeader = response.headers.link;
            if (typeof rawLinkHeader !== 'string' || rawLinkHeader.trim() === '') {
                return false;
            }
            const parsed = (0,_parse_link_header_js__WEBPACK_IMPORTED_MODULE_10__["default"])(rawLinkHeader);
            const next = parsed.find(entry => entry.parameters.rel === 'next' || entry.parameters.rel === '"next"');
            if (next) {
                return {
                    url: new node_url__WEBPACK_IMPORTED_MODULE_2__.URL(next.reference, response.url),
                };
            }
            return false;
        },
        filter: () => true,
        shouldContinue: () => true,
        countLimit: Number.POSITIVE_INFINITY,
        backoff: 0,
        requestLimit: 10000,
        stackAllItems: false,
    },
    setHost: true,
    maxHeaderSize: undefined,
    signal: undefined,
    enableUnixSockets: true,
};
const cloneInternals = (internals) => {
    const { hooks, retry } = internals;
    const result = {
        ...internals,
        context: { ...internals.context },
        cacheOptions: { ...internals.cacheOptions },
        https: { ...internals.https },
        agent: { ...internals.agent },
        headers: { ...internals.headers },
        retry: {
            ...retry,
            errorCodes: [...retry.errorCodes],
            methods: [...retry.methods],
            statusCodes: [...retry.statusCodes],
        },
        timeout: { ...internals.timeout },
        hooks: {
            init: [...hooks.init],
            beforeRequest: [...hooks.beforeRequest],
            beforeError: [...hooks.beforeError],
            beforeRedirect: [...hooks.beforeRedirect],
            beforeRetry: [...hooks.beforeRetry],
            afterResponse: [...hooks.afterResponse],
        },
        searchParams: internals.searchParams ? new node_url__WEBPACK_IMPORTED_MODULE_2__.URLSearchParams(internals.searchParams) : undefined,
        pagination: { ...internals.pagination },
    };
    if (result.url !== undefined) {
        result.prefixUrl = '';
    }
    return result;
};
const cloneRaw = (raw) => {
    const { hooks, retry } = raw;
    const result = { ...raw };
    if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object(raw.context)) {
        result.context = { ...raw.context };
    }
    if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object(raw.cacheOptions)) {
        result.cacheOptions = { ...raw.cacheOptions };
    }
    if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object(raw.https)) {
        result.https = { ...raw.https };
    }
    if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object(raw.cacheOptions)) {
        result.cacheOptions = { ...result.cacheOptions };
    }
    if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object(raw.agent)) {
        result.agent = { ...raw.agent };
    }
    if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object(raw.headers)) {
        result.headers = { ...raw.headers };
    }
    if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object(retry)) {
        result.retry = { ...retry };
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array(retry.errorCodes)) {
            result.retry.errorCodes = [...retry.errorCodes];
        }
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array(retry.methods)) {
            result.retry.methods = [...retry.methods];
        }
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array(retry.statusCodes)) {
            result.retry.statusCodes = [...retry.statusCodes];
        }
    }
    if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object(raw.timeout)) {
        result.timeout = { ...raw.timeout };
    }
    if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object(hooks)) {
        result.hooks = {
            ...hooks,
        };
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array(hooks.init)) {
            result.hooks.init = [...hooks.init];
        }
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array(hooks.beforeRequest)) {
            result.hooks.beforeRequest = [...hooks.beforeRequest];
        }
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array(hooks.beforeError)) {
            result.hooks.beforeError = [...hooks.beforeError];
        }
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array(hooks.beforeRedirect)) {
            result.hooks.beforeRedirect = [...hooks.beforeRedirect];
        }
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array(hooks.beforeRetry)) {
            result.hooks.beforeRetry = [...hooks.beforeRetry];
        }
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array(hooks.afterResponse)) {
            result.hooks.afterResponse = [...hooks.afterResponse];
        }
    }
    // TODO: raw.searchParams
    if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object(raw.pagination)) {
        result.pagination = { ...raw.pagination };
    }
    return result;
};
const getHttp2TimeoutOption = (internals) => {
    const delays = [internals.timeout.socket, internals.timeout.connect, internals.timeout.lookup, internals.timeout.request, internals.timeout.secureConnect].filter(delay => typeof delay === 'number');
    if (delays.length > 0) {
        return Math.min(...delays);
    }
    return undefined;
};
const init = (options, withOptions, self) => {
    const initHooks = options.hooks?.init;
    if (initHooks) {
        for (const hook of initHooks) {
            hook(withOptions, self);
        }
    }
};
class Options {
    constructor(input, options, defaults) {
        Object.defineProperty(this, "_unixOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_internals", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_merging", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_init", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].urlInstance, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], input);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], options);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], defaults);
        if (input instanceof Options || options instanceof Options) {
            throw new TypeError('The defaults must be passed as the third argument');
        }
        this._internals = cloneInternals(defaults?._internals ?? defaults ?? defaultInternals);
        this._init = [...(defaults?._init ?? [])];
        this._merging = false;
        this._unixOptions = undefined;
        // This rule allows `finally` to be considered more important.
        // Meaning no matter the error thrown in the `try` block,
        // if `finally` throws then the `finally` error will be thrown.
        //
        // Yes, we want this. If we set `url` first, then the `url.searchParams`
        // would get merged. Instead we set the `searchParams` first, then
        // `url.searchParams` is overwritten as expected.
        //
        /* eslint-disable no-unsafe-finally */
        try {
            if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].plainObject(input)) {
                try {
                    this.merge(input);
                    this.merge(options);
                }
                finally {
                    this.url = input.url;
                }
            }
            else {
                try {
                    this.merge(options);
                }
                finally {
                    if (options?.url !== undefined) {
                        if (input === undefined) {
                            this.url = options.url;
                        }
                        else {
                            throw new TypeError('The `url` option is mutually exclusive with the `input` argument');
                        }
                    }
                    else if (input !== undefined) {
                        this.url = input;
                    }
                }
            }
        }
        catch (error) {
            error.options = this;
            throw error;
        }
        /* eslint-enable no-unsafe-finally */
    }
    merge(options) {
        if (!options) {
            return;
        }
        if (options instanceof Options) {
            for (const init of options._init) {
                this.merge(init);
            }
            return;
        }
        options = cloneRaw(options);
        init(this, options, this);
        init(options, options, this);
        this._merging = true;
        // Always merge `isStream` first
        if ('isStream' in options) {
            this.isStream = options.isStream;
        }
        try {
            let push = false;
            for (const key in options) {
                // `got.extend()` options
                if (key === 'mutableDefaults' || key === 'handlers') {
                    continue;
                }
                // Never merge `url`
                if (key === 'url') {
                    continue;
                }
                if (!(key in this)) {
                    throw new Error(`Unexpected option: ${key}`);
                }
                // @ts-expect-error Type 'unknown' is not assignable to type 'never'.
                this[key] = options[key];
                push = true;
            }
            if (push) {
                this._init.push(options);
            }
        }
        finally {
            this._merging = false;
        }
    }
    /**
    Custom request function.
    The main purpose of this is to [support HTTP2 using a wrapper](https://github.com/szmarczak/http2-wrapper).

    @default http.request | https.request
    */
    get request() {
        return this._internals.request;
    }
    set request(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].function_, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
        this._internals.request = value;
    }
    /**
    An object representing `http`, `https` and `http2` keys for [`http.Agent`](https://nodejs.org/api/http.html#http_class_http_agent), [`https.Agent`](https://nodejs.org/api/https.html#https_class_https_agent) and [`http2wrapper.Agent`](https://github.com/szmarczak/http2-wrapper#new-http2agentoptions) instance.
    This is necessary because a request to one protocol might redirect to another.
    In such a scenario, Got will switch over to the right protocol agent for you.

    If a key is not present, it will default to a global agent.

    @example
    ```
    import got from 'got';
    import HttpAgent from 'agentkeepalive';

    const {HttpsAgent} = HttpAgent;

    await got('https://sindresorhus.com', {
        agent: {
            http: new HttpAgent(),
            https: new HttpsAgent()
        }
    });
    ```
    */
    get agent() {
        return this._internals.agent;
    }
    set agent(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.plainObject(value);
        // eslint-disable-next-line guard-for-in
        for (const key in value) {
            if (!(key in this._internals.agent)) {
                throw new TypeError(`Unexpected agent option: ${key}`);
            }
            // @ts-expect-error - No idea why `value[key]` doesn't work here.
            _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value[key]);
        }
        if (this._merging) {
            Object.assign(this._internals.agent, value);
        }
        else {
            this._internals.agent = { ...value };
        }
    }
    get h2session() {
        return this._internals.h2session;
    }
    set h2session(value) {
        this._internals.h2session = value;
    }
    /**
    Decompress the response automatically.

    This will set the `accept-encoding` header to `gzip, deflate, br` unless you set it yourself.

    If this is disabled, a compressed response is returned as a `Buffer`.
    This may be useful if you want to handle decompression yourself or stream the raw compressed data.

    @default true
    */
    get decompress() {
        return this._internals.decompress;
    }
    set decompress(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.boolean(value);
        this._internals.decompress = value;
    }
    /**
    Milliseconds to wait for the server to end the response before aborting the request with `got.TimeoutError` error (a.k.a. `request` property).
    By default, there's no timeout.

    This also accepts an `object` with the following fields to constrain the duration of each phase of the request lifecycle:

    - `lookup` starts when a socket is assigned and ends when the hostname has been resolved.
        Does not apply when using a Unix domain socket.
    - `connect` starts when `lookup` completes (or when the socket is assigned if lookup does not apply to the request) and ends when the socket is connected.
    - `secureConnect` starts when `connect` completes and ends when the handshaking process completes (HTTPS only).
    - `socket` starts when the socket is connected. See [request.setTimeout](https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback).
    - `response` starts when the request has been written to the socket and ends when the response headers are received.
    - `send` starts when the socket is connected and ends with the request has been written to the socket.
    - `request` starts when the request is initiated and ends when the response's end event fires.
    */
    get timeout() {
        // We always return `Delays` here.
        // It has to be `Delays | number`, otherwise TypeScript will error because the getter and the setter have incompatible types.
        return this._internals.timeout;
    }
    set timeout(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.plainObject(value);
        // eslint-disable-next-line guard-for-in
        for (const key in value) {
            if (!(key in this._internals.timeout)) {
                throw new Error(`Unexpected timeout option: ${key}`);
            }
            // @ts-expect-error - No idea why `value[key]` doesn't work here.
            _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].number, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value[key]);
        }
        if (this._merging) {
            Object.assign(this._internals.timeout, value);
        }
        else {
            this._internals.timeout = { ...value };
        }
    }
    /**
    When specified, `prefixUrl` will be prepended to `url`.
    The prefix can be any valid URL, either relative or absolute.
    A trailing slash `/` is optional - one will be added automatically.

    __Note__: `prefixUrl` will be ignored if the `url` argument is a URL instance.

    __Note__: Leading slashes in `input` are disallowed when using this option to enforce consistency and avoid confusion.
    For example, when the prefix URL is `https://example.com/foo` and the input is `/bar`, there's ambiguity whether the resulting URL would become `https://example.com/foo/bar` or `https://example.com/bar`.
    The latter is used by browsers.

    __Tip__: Useful when used with `got.extend()` to create niche-specific Got instances.

    __Tip__: You can change `prefixUrl` using hooks as long as the URL still includes the `prefixUrl`.
    If the URL doesn't include it anymore, it will throw.

    @example
    ```
    import got from 'got';

    await got('unicorn', {prefixUrl: 'https://cats.com'});
    //=> 'https://cats.com/unicorn'

    const instance = got.extend({
        prefixUrl: 'https://google.com'
    });

    await instance('unicorn', {
        hooks: {
            beforeRequest: [
                options => {
                    options.prefixUrl = 'https://cats.com';
                }
            ]
        }
    });
    //=> 'https://cats.com/unicorn'
    ```
    */
    get prefixUrl() {
        // We always return `string` here.
        // It has to be `string | URL`, otherwise TypeScript will error because the getter and the setter have incompatible types.
        return this._internals.prefixUrl;
    }
    set prefixUrl(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].urlInstance], value);
        if (value === '') {
            this._internals.prefixUrl = '';
            return;
        }
        value = value.toString();
        if (!value.endsWith('/')) {
            value += '/';
        }
        if (this._internals.prefixUrl && this._internals.url) {
            const { href } = this._internals.url;
            this._internals.url.href = value + href.slice(this._internals.prefixUrl.length);
        }
        this._internals.prefixUrl = value;
    }
    /**
    __Note #1__: The `body` option cannot be used with the `json` or `form` option.

    __Note #2__: If you provide this option, `got.stream()` will be read-only.

    __Note #3__: If you provide a payload with the `GET` or `HEAD` method, it will throw a `TypeError` unless the method is `GET` and the `allowGetBody` option is set to `true`.

    __Note #4__: This option is not enumerable and will not be merged with the instance defaults.

    The `content-length` header will be automatically set if `body` is a `string` / `Buffer` / [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) / [`form-data` instance](https://github.com/form-data/form-data), and `content-length` and `transfer-encoding` are not manually set in `options.headers`.

    Since Got 12, the `content-length` is not automatically set when `body` is a `fs.createReadStream`.
    */
    get body() {
        return this._internals.body;
    }
    set body(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].buffer, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].nodeStream, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].generator, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].asyncGenerator, form_data_encoder__WEBPACK_IMPORTED_MODULE_11__.isFormData, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].nodeStream(value)) {
            _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.truthy(value.readable);
        }
        if (value !== undefined) {
            _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.undefined(this._internals.form);
            _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.undefined(this._internals.json);
        }
        this._internals.body = value;
    }
    /**
    The form body is converted to a query string using [`(new URLSearchParams(object)).toString()`](https://nodejs.org/api/url.html#url_constructor_new_urlsearchparams_obj).

    If the `Content-Type` header is not present, it will be set to `application/x-www-form-urlencoded`.

    __Note #1__: If you provide this option, `got.stream()` will be read-only.

    __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
    */
    get form() {
        return this._internals.form;
    }
    set form(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].plainObject, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
        if (value !== undefined) {
            _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.undefined(this._internals.body);
            _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.undefined(this._internals.json);
        }
        this._internals.form = value;
    }
    /**
    JSON body. If the `Content-Type` header is not set, it will be set to `application/json`.

    __Note #1__: If you provide this option, `got.stream()` will be read-only.

    __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
    */
    get json() {
        return this._internals.json;
    }
    set json(value) {
        if (value !== undefined) {
            _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.undefined(this._internals.body);
            _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.undefined(this._internals.form);
        }
        this._internals.json = value;
    }
    /**
    The URL to request, as a string, a [`https.request` options object](https://nodejs.org/api/https.html#https_https_request_options_callback), or a [WHATWG `URL`](https://nodejs.org/api/url.html#url_class_url).

    Properties from `options` will override properties in the parsed `url`.

    If no protocol is specified, it will throw a `TypeError`.

    __Note__: The query string is **not** parsed as search params.

    @example
    ```
    await got('https://example.com/?query=a b'); //=> https://example.com/?query=a%20b
    await got('https://example.com/', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b

    // The query string is overridden by `searchParams`
    await got('https://example.com/?query=a b', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
    ```
    */
    get url() {
        return this._internals.url;
    }
    set url(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].urlInstance, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
        if (value === undefined) {
            this._internals.url = undefined;
            return;
        }
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string(value) && value.startsWith('/')) {
            throw new Error('`url` must not start with a slash');
        }
        const urlString = `${this.prefixUrl}${value.toString()}`;
        const url = new node_url__WEBPACK_IMPORTED_MODULE_2__.URL(urlString);
        this._internals.url = url;
        if (url.protocol === 'unix:') {
            url.href = `http://unix${url.pathname}${url.search}`;
        }
        if (url.protocol !== 'http:' && url.protocol !== 'https:') {
            const error = new Error(`Unsupported protocol: ${url.protocol}`);
            error.code = 'ERR_UNSUPPORTED_PROTOCOL';
            throw error;
        }
        if (this._internals.username) {
            url.username = this._internals.username;
            this._internals.username = '';
        }
        if (this._internals.password) {
            url.password = this._internals.password;
            this._internals.password = '';
        }
        if (this._internals.searchParams) {
            url.search = this._internals.searchParams.toString();
            this._internals.searchParams = undefined;
        }
        if (url.hostname === 'unix') {
            if (!this._internals.enableUnixSockets) {
                throw new Error('Using UNIX domain sockets but option `enableUnixSockets` is not enabled');
            }
            const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
            if (matches?.groups) {
                const { socketPath, path } = matches.groups;
                this._unixOptions = {
                    socketPath,
                    path,
                    host: '',
                };
            }
            else {
                this._unixOptions = undefined;
            }
            return;
        }
        this._unixOptions = undefined;
    }
    /**
    Cookie support. You don't have to care about parsing or how to store them.

    __Note__: If you provide this option, `options.headers.cookie` will be overridden.
    */
    get cookieJar() {
        return this._internals.cookieJar;
    }
    set cookieJar(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
        if (value === undefined) {
            this._internals.cookieJar = undefined;
            return;
        }
        let { setCookie, getCookieString } = value;
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.function_(setCookie);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.function_(getCookieString);
        /* istanbul ignore next: Horrible `tough-cookie` v3 check */
        if (setCookie.length === 4 && getCookieString.length === 0) {
            setCookie = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(setCookie.bind(value));
            getCookieString = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(getCookieString.bind(value));
            this._internals.cookieJar = {
                setCookie,
                getCookieString: getCookieString,
            };
        }
        else {
            this._internals.cookieJar = value;
        }
    }
    /**
    You can abort the `request` using [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).

    *Requires Node.js 16 or later.*

    @example
    ```
    import got from 'got';

    const abortController = new AbortController();

    const request = got('https://httpbin.org/anything', {
        signal: abortController.signal
    });

    setTimeout(() => {
        abortController.abort();
    }, 100);
    ```
    */
    // TODO: Replace `any` with `AbortSignal` when targeting Node 16.
    get signal() {
        return this._internals.signal;
    }
    // TODO: Replace `any` with `AbortSignal` when targeting Node 16.
    set signal(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.object(value);
        this._internals.signal = value;
    }
    /**
    Ignore invalid cookies instead of throwing an error.
    Only useful when the `cookieJar` option has been set. Not recommended.

    @default false
    */
    get ignoreInvalidCookies() {
        return this._internals.ignoreInvalidCookies;
    }
    set ignoreInvalidCookies(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.boolean(value);
        this._internals.ignoreInvalidCookies = value;
    }
    /**
    Query string that will be added to the request URL.
    This will override the query string in `url`.

    If you need to pass in an array, you can do it using a `URLSearchParams` instance.

    @example
    ```
    import got from 'got';

    const searchParams = new URLSearchParams([['key', 'a'], ['key', 'b']]);

    await got('https://example.com', {searchParams});

    console.log(searchParams.toString());
    //=> 'key=a&key=b'
    ```
    */
    get searchParams() {
        if (this._internals.url) {
            return this._internals.url.searchParams;
        }
        if (this._internals.searchParams === undefined) {
            this._internals.searchParams = new node_url__WEBPACK_IMPORTED_MODULE_2__.URLSearchParams();
        }
        return this._internals.searchParams;
    }
    set searchParams(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
        const url = this._internals.url;
        if (value === undefined) {
            this._internals.searchParams = undefined;
            if (url) {
                url.search = '';
            }
            return;
        }
        const searchParameters = this.searchParams;
        let updated;
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string(value)) {
            updated = new node_url__WEBPACK_IMPORTED_MODULE_2__.URLSearchParams(value);
        }
        else if (value instanceof node_url__WEBPACK_IMPORTED_MODULE_2__.URLSearchParams) {
            updated = value;
        }
        else {
            validateSearchParameters(value);
            updated = new node_url__WEBPACK_IMPORTED_MODULE_2__.URLSearchParams();
            // eslint-disable-next-line guard-for-in
            for (const key in value) {
                const entry = value[key];
                if (entry === null) {
                    updated.append(key, '');
                }
                else if (entry === undefined) {
                    searchParameters.delete(key);
                }
                else {
                    updated.append(key, entry);
                }
            }
        }
        if (this._merging) {
            // These keys will be replaced
            for (const key of updated.keys()) {
                searchParameters.delete(key);
            }
            for (const [key, value] of updated) {
                searchParameters.append(key, value);
            }
        }
        else if (url) {
            url.search = searchParameters.toString();
        }
        else {
            this._internals.searchParams = searchParameters;
        }
    }
    get searchParameters() {
        throw new Error('The `searchParameters` option does not exist. Use `searchParams` instead.');
    }
    set searchParameters(_value) {
        throw new Error('The `searchParameters` option does not exist. Use `searchParams` instead.');
    }
    get dnsLookup() {
        return this._internals.dnsLookup;
    }
    set dnsLookup(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].function_, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
        this._internals.dnsLookup = value;
    }
    /**
    An instance of [`CacheableLookup`](https://github.com/szmarczak/cacheable-lookup) used for making DNS lookups.
    Useful when making lots of requests to different *public* hostnames.

    `CacheableLookup` uses `dns.resolver4(..)` and `dns.resolver6(...)` under the hood and fall backs to `dns.lookup(...)` when the first two fail, which may lead to additional delay.

    __Note__: This should stay disabled when making requests to internal hostnames such as `localhost`, `database.local` etc.

    @default false
    */
    get dnsCache() {
        return this._internals.dnsCache;
    }
    set dnsCache(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].boolean, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
        if (value === true) {
            this._internals.dnsCache = getGlobalDnsCache();
        }
        else if (value === false) {
            this._internals.dnsCache = undefined;
        }
        else {
            this._internals.dnsCache = value;
        }
    }
    /**
    User data. `context` is shallow merged and enumerable. If it contains non-enumerable properties they will NOT be merged.

    @example
    ```
    import got from 'got';

    const instance = got.extend({
        hooks: {
            beforeRequest: [
                options => {
                    if (!options.context || !options.context.token) {
                        throw new Error('Token required');
                    }

                    options.headers.token = options.context.token;
                }
            ]
        }
    });

    const context = {
        token: 'secret'
    };

    const response = await instance('https://httpbin.org/headers', {context});

    // Let's see the headers
    console.log(response.body);
    ```
    */
    get context() {
        return this._internals.context;
    }
    set context(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.object(value);
        if (this._merging) {
            Object.assign(this._internals.context, value);
        }
        else {
            this._internals.context = { ...value };
        }
    }
    /**
    Hooks allow modifications during the request lifecycle.
    Hook functions may be async and are run serially.
    */
    get hooks() {
        return this._internals.hooks;
    }
    set hooks(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.object(value);
        // eslint-disable-next-line guard-for-in
        for (const knownHookEvent in value) {
            if (!(knownHookEvent in this._internals.hooks)) {
                throw new Error(`Unexpected hook event: ${knownHookEvent}`);
            }
            const typedKnownHookEvent = knownHookEvent;
            const hooks = value[typedKnownHookEvent];
            _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], hooks);
            if (hooks) {
                for (const hook of hooks) {
                    _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.function_(hook);
                }
            }
            if (this._merging) {
                if (hooks) {
                    // @ts-expect-error FIXME
                    this._internals.hooks[typedKnownHookEvent].push(...hooks);
                }
            }
            else {
                if (!hooks) {
                    throw new Error(`Missing hook event: ${knownHookEvent}`);
                }
                // @ts-expect-error FIXME
                this._internals.hooks[knownHookEvent] = [...hooks];
            }
        }
    }
    /**
    Defines if redirect responses should be followed automatically.

    Note that if a `303` is sent by the server in response to any request type (`POST`, `DELETE`, etc.), Got will automatically request the resource pointed to in the location header via `GET`.
    This is in accordance with [the spec](https://tools.ietf.org/html/rfc7231#section-6.4.4). You can optionally turn on this behavior also for other redirect codes - see `methodRewriting`.

    @default true
    */
    get followRedirect() {
        return this._internals.followRedirect;
    }
    set followRedirect(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.boolean(value);
        this._internals.followRedirect = value;
    }
    get followRedirects() {
        throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');
    }
    set followRedirects(_value) {
        throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');
    }
    /**
    If exceeded, the request will be aborted and a `MaxRedirectsError` will be thrown.

    @default 10
    */
    get maxRedirects() {
        return this._internals.maxRedirects;
    }
    set maxRedirects(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.number(value);
        this._internals.maxRedirects = value;
    }
    /**
    A cache adapter instance for storing cached response data.

    @default false
    */
    get cache() {
        return this._internals.cache;
    }
    set cache(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].boolean, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
        if (value === true) {
            this._internals.cache = globalCache;
        }
        else if (value === false) {
            this._internals.cache = undefined;
        }
        else {
            this._internals.cache = value;
        }
    }
    /**
    Determines if a `got.HTTPError` is thrown for unsuccessful responses.

    If this is disabled, requests that encounter an error status code will be resolved with the `response` instead of throwing.
    This may be useful if you are checking for resource availability and are expecting error responses.

    @default true
    */
    get throwHttpErrors() {
        return this._internals.throwHttpErrors;
    }
    set throwHttpErrors(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.boolean(value);
        this._internals.throwHttpErrors = value;
    }
    get username() {
        const url = this._internals.url;
        const value = url ? url.username : this._internals.username;
        return decodeURIComponent(value);
    }
    set username(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.string(value);
        const url = this._internals.url;
        const fixedValue = encodeURIComponent(value);
        if (url) {
            url.username = fixedValue;
        }
        else {
            this._internals.username = fixedValue;
        }
    }
    get password() {
        const url = this._internals.url;
        const value = url ? url.password : this._internals.password;
        return decodeURIComponent(value);
    }
    set password(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.string(value);
        const url = this._internals.url;
        const fixedValue = encodeURIComponent(value);
        if (url) {
            url.password = fixedValue;
        }
        else {
            this._internals.password = fixedValue;
        }
    }
    /**
    If set to `true`, Got will additionally accept HTTP2 requests.

    It will choose either HTTP/1.1 or HTTP/2 depending on the ALPN protocol.

    __Note__: This option requires Node.js 15.10.0 or newer as HTTP/2 support on older Node.js versions is very buggy.

    __Note__: Overriding `options.request` will disable HTTP2 support.

    @default false

    @example
    ```
    import got from 'got';

    const {headers} = await got('https://nghttp2.org/httpbin/anything', {http2: true});

    console.log(headers.via);
    //=> '2 nghttpx'
    ```
    */
    get http2() {
        return this._internals.http2;
    }
    set http2(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.boolean(value);
        this._internals.http2 = value;
    }
    /**
    Set this to `true` to allow sending body for the `GET` method.
    However, the [HTTP/2 specification](https://tools.ietf.org/html/rfc7540#section-8.1.3) says that `An HTTP GET request includes request header fields and no payload body`, therefore when using the HTTP/2 protocol this option will have no effect.
    This option is only meant to interact with non-compliant servers when you have no other choice.

    __Note__: The [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1) doesn't specify any particular behavior for the GET method having a payload, therefore __it's considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern)__.

    @default false
    */
    get allowGetBody() {
        return this._internals.allowGetBody;
    }
    set allowGetBody(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.boolean(value);
        this._internals.allowGetBody = value;
    }
    /**
    Request headers.

    Existing headers will be overwritten. Headers set to `undefined` will be omitted.

    @default {}
    */
    get headers() {
        return this._internals.headers;
    }
    set headers(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.plainObject(value);
        if (this._merging) {
            Object.assign(this._internals.headers, (0,lowercase_keys__WEBPACK_IMPORTED_MODULE_6__["default"])(value));
        }
        else {
            this._internals.headers = (0,lowercase_keys__WEBPACK_IMPORTED_MODULE_6__["default"])(value);
        }
    }
    /**
    Specifies if the HTTP request method should be [rewritten as `GET`](https://tools.ietf.org/html/rfc7231#section-6.4) on redirects.

    As the [specification](https://tools.ietf.org/html/rfc7231#section-6.4) prefers to rewrite the HTTP method only on `303` responses, this is Got's default behavior.
    Setting `methodRewriting` to `true` will also rewrite `301` and `302` responses, as allowed by the spec. This is the behavior followed by `curl` and browsers.

    __Note__: Got never performs method rewriting on `307` and `308` responses, as this is [explicitly prohibited by the specification](https://www.rfc-editor.org/rfc/rfc7231#section-6.4.7).

    @default false
    */
    get methodRewriting() {
        return this._internals.methodRewriting;
    }
    set methodRewriting(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.boolean(value);
        this._internals.methodRewriting = value;
    }
    /**
    Indicates which DNS record family to use.

    Values:
    - `undefined`: IPv4 (if present) or IPv6
    - `4`: Only IPv4
    - `6`: Only IPv6

    @default undefined
    */
    get dnsLookupIpVersion() {
        return this._internals.dnsLookupIpVersion;
    }
    set dnsLookupIpVersion(value) {
        if (value !== undefined && value !== 4 && value !== 6) {
            throw new TypeError(`Invalid DNS lookup IP version: ${value}`);
        }
        this._internals.dnsLookupIpVersion = value;
    }
    /**
    A function used to parse JSON responses.

    @example
    ```
    import got from 'got';
    import Bourne from '@hapi/bourne';

    const parsed = await got('https://example.com', {
        parseJson: text => Bourne.parse(text)
    }).json();

    console.log(parsed);
    ```
    */
    get parseJson() {
        return this._internals.parseJson;
    }
    set parseJson(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.function_(value);
        this._internals.parseJson = value;
    }
    /**
    A function used to stringify the body of JSON requests.

    @example
    ```
    import got from 'got';

    await got.post('https://example.com', {
        stringifyJson: object => JSON.stringify(object, (key, value) => {
            if (key.startsWith('_')) {
                return;
            }

            return value;
        }),
        json: {
            some: 'payload',
            _ignoreMe: 1234
        }
    });
    ```

    @example
    ```
    import got from 'got';

    await got.post('https://example.com', {
        stringifyJson: object => JSON.stringify(object, (key, value) => {
            if (typeof value === 'number') {
                return value.toString();
            }

            return value;
        }),
        json: {
            some: 'payload',
            number: 1
        }
    });
    ```
    */
    get stringifyJson() {
        return this._internals.stringifyJson;
    }
    set stringifyJson(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.function_(value);
        this._internals.stringifyJson = value;
    }
    /**
    An object representing `limit`, `calculateDelay`, `methods`, `statusCodes`, `maxRetryAfter` and `errorCodes` fields for maximum retry count, retry handler, allowed methods, allowed status codes, maximum [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) time and allowed error codes.

    Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 1).

    The `calculateDelay` property is a `function` that receives an object with `attemptCount`, `retryOptions`, `error` and `computedValue` properties for current retry count, the retry options, error and default computed value.
    The function must return a delay in milliseconds (or a Promise resolving with it) (`0` return value cancels retry).

    By default, it retries *only* on the specified methods, status codes, and on these network errors:

    - `ETIMEDOUT`: One of the [timeout](#timeout) limits were reached.
    - `ECONNRESET`: Connection was forcibly closed by a peer.
    - `EADDRINUSE`: Could not bind to any free port.
    - `ECONNREFUSED`: Connection was refused by the server.
    - `EPIPE`: The remote side of the stream being written has been closed.
    - `ENOTFOUND`: Couldn't resolve the hostname to an IP address.
    - `ENETUNREACH`: No internet connection.
    - `EAI_AGAIN`: DNS lookup timed out.

    __Note__: If `maxRetryAfter` is set to `undefined`, it will use `options.timeout`.
    __Note__: If [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header is greater than `maxRetryAfter`, it will cancel the request.
    */
    get retry() {
        return this._internals.retry;
    }
    set retry(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.plainObject(value);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].function_, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.calculateDelay);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].number, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.maxRetryAfter);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].number, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.limit);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.methods);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.statusCodes);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.errorCodes);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].number, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.noise);
        if (value.noise && Math.abs(value.noise) > 100) {
            throw new Error(`The maximum acceptable retry noise is +/- 100ms, got ${value.noise}`);
        }
        for (const key in value) {
            if (!(key in this._internals.retry)) {
                throw new Error(`Unexpected retry option: ${key}`);
            }
        }
        if (this._merging) {
            Object.assign(this._internals.retry, value);
        }
        else {
            this._internals.retry = { ...value };
        }
        const { retry } = this._internals;
        retry.methods = [...new Set(retry.methods.map(method => method.toUpperCase()))];
        retry.statusCodes = [...new Set(retry.statusCodes)];
        retry.errorCodes = [...new Set(retry.errorCodes)];
    }
    /**
    From `http.RequestOptions`.

    The IP address used to send the request from.
    */
    get localAddress() {
        return this._internals.localAddress;
    }
    set localAddress(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
        this._internals.localAddress = value;
    }
    /**
    The HTTP method used to make the request.

    @default 'GET'
    */
    get method() {
        return this._internals.method;
    }
    set method(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.string(value);
        this._internals.method = value.toUpperCase();
    }
    get createConnection() {
        return this._internals.createConnection;
    }
    set createConnection(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].function_, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
        this._internals.createConnection = value;
    }
    /**
    From `http-cache-semantics`

    @default {}
    */
    get cacheOptions() {
        return this._internals.cacheOptions;
    }
    set cacheOptions(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.plainObject(value);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].boolean, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.shared);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].number, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.cacheHeuristic);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].number, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.immutableMinTimeToLive);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].boolean, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.ignoreCargoCult);
        for (const key in value) {
            if (!(key in this._internals.cacheOptions)) {
                throw new Error(`Cache option \`${key}\` does not exist`);
            }
        }
        if (this._merging) {
            Object.assign(this._internals.cacheOptions, value);
        }
        else {
            this._internals.cacheOptions = { ...value };
        }
    }
    /**
    Options for the advanced HTTPS API.
    */
    get https() {
        return this._internals.https;
    }
    set https(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.plainObject(value);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].boolean, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.rejectUnauthorized);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].function_, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.checkServerIdentity);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.certificateAuthority);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.key);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].object, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.certificate);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.passphrase);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].buffer, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.pfx);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.alpnProtocols);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.ciphers);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].buffer, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.dhparam);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.signatureAlgorithms);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.minVersion);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.maxVersion);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].boolean, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.honorCipherOrder);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].number, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.tlsSessionLifetime);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.ecdhCurve);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].buffer, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value.certificateRevocationLists);
        for (const key in value) {
            if (!(key in this._internals.https)) {
                throw new Error(`HTTPS option \`${key}\` does not exist`);
            }
        }
        if (this._merging) {
            Object.assign(this._internals.https, value);
        }
        else {
            this._internals.https = { ...value };
        }
    }
    /**
    [Encoding](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings) to be used on `setEncoding` of the response data.

    To get a [`Buffer`](https://nodejs.org/api/buffer.html), you need to set `responseType` to `buffer` instead.
    Don't set this option to `null`.

    __Note__: This doesn't affect streams! Instead, you need to do `got.stream(...).setEncoding(encoding)`.

    @default 'utf-8'
    */
    get encoding() {
        return this._internals.encoding;
    }
    set encoding(value) {
        if (value === null) {
            throw new TypeError('To get a Buffer, set `options.responseType` to `buffer` instead');
        }
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].string, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
        this._internals.encoding = value;
    }
    /**
    When set to `true` the promise will return the Response body instead of the Response object.

    @default false
    */
    get resolveBodyOnly() {
        return this._internals.resolveBodyOnly;
    }
    set resolveBodyOnly(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.boolean(value);
        this._internals.resolveBodyOnly = value;
    }
    /**
    Returns a `Stream` instead of a `Promise`.
    This is equivalent to calling `got.stream(url, options?)`.

    @default false
    */
    get isStream() {
        return this._internals.isStream;
    }
    set isStream(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.boolean(value);
        this._internals.isStream = value;
    }
    /**
    The parsing method.

    The promise also has `.text()`, `.json()` and `.buffer()` methods which return another Got promise for the parsed body.

    It's like setting the options to `{responseType: 'json', resolveBodyOnly: true}` but without affecting the main Got promise.

    __Note__: When using streams, this option is ignored.

    @example
    ```
    const responsePromise = got(url);
    const bufferPromise = responsePromise.buffer();
    const jsonPromise = responsePromise.json();

    const [response, buffer, json] = Promise.all([responsePromise, bufferPromise, jsonPromise]);
    // `response` is an instance of Got Response
    // `buffer` is an instance of Buffer
    // `json` is an object
    ```

    @example
    ```
    // This
    const body = await got(url).json();

    // is semantically the same as this
    const body = await got(url, {responseType: 'json', resolveBodyOnly: true});
    ```
    */
    get responseType() {
        return this._internals.responseType;
    }
    set responseType(value) {
        if (value === undefined) {
            this._internals.responseType = 'text';
            return;
        }
        if (value !== 'text' && value !== 'buffer' && value !== 'json') {
            throw new Error(`Invalid \`responseType\` option: ${value}`);
        }
        this._internals.responseType = value;
    }
    get pagination() {
        return this._internals.pagination;
    }
    set pagination(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.object(value);
        if (this._merging) {
            Object.assign(this._internals.pagination, value);
        }
        else {
            this._internals.pagination = value;
        }
    }
    get auth() {
        throw new Error('Parameter `auth` is deprecated. Use `username` / `password` instead.');
    }
    set auth(_value) {
        throw new Error('Parameter `auth` is deprecated. Use `username` / `password` instead.');
    }
    get setHost() {
        return this._internals.setHost;
    }
    set setHost(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.boolean(value);
        this._internals.setHost = value;
    }
    get maxHeaderSize() {
        return this._internals.maxHeaderSize;
    }
    set maxHeaderSize(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].number, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].undefined], value);
        this._internals.maxHeaderSize = value;
    }
    get enableUnixSockets() {
        return this._internals.enableUnixSockets;
    }
    set enableUnixSockets(value) {
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__.assert.boolean(value);
        this._internals.enableUnixSockets = value;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    toJSON() {
        return { ...this._internals };
    }
    [Symbol.for('nodejs.util.inspect.custom')](_depth, options) {
        return (0,node_util__WEBPACK_IMPORTED_MODULE_1__.inspect)(this._internals, options);
    }
    createNativeRequestOptions() {
        const internals = this._internals;
        const url = internals.url;
        let agent;
        if (url.protocol === 'https:') {
            agent = internals.http2 ? internals.agent : internals.agent.https;
        }
        else {
            agent = internals.agent.http;
        }
        const { https } = internals;
        let { pfx } = https;
        if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].array(pfx) && _sindresorhus_is__WEBPACK_IMPORTED_MODULE_9__["default"].plainObject(pfx[0])) {
            pfx = pfx.map(object => ({
                buf: object.buffer,
                passphrase: object.passphrase,
            }));
        }
        return {
            ...internals.cacheOptions,
            ...this._unixOptions,
            // HTTPS options
            // eslint-disable-next-line @typescript-eslint/naming-convention
            ALPNProtocols: https.alpnProtocols,
            ca: https.certificateAuthority,
            cert: https.certificate,
            key: https.key,
            passphrase: https.passphrase,
            pfx: https.pfx,
            rejectUnauthorized: https.rejectUnauthorized,
            checkServerIdentity: https.checkServerIdentity ?? node_tls__WEBPACK_IMPORTED_MODULE_3__.checkServerIdentity,
            ciphers: https.ciphers,
            honorCipherOrder: https.honorCipherOrder,
            minVersion: https.minVersion,
            maxVersion: https.maxVersion,
            sigalgs: https.signatureAlgorithms,
            sessionTimeout: https.tlsSessionLifetime,
            dhparam: https.dhparam,
            ecdhCurve: https.ecdhCurve,
            crl: https.certificateRevocationLists,
            // HTTP options
            lookup: internals.dnsLookup ?? internals.dnsCache?.lookup,
            family: internals.dnsLookupIpVersion,
            agent,
            setHost: internals.setHost,
            method: internals.method,
            maxHeaderSize: internals.maxHeaderSize,
            localAddress: internals.localAddress,
            headers: internals.headers,
            createConnection: internals.createConnection,
            timeout: internals.http2 ? getHttp2TimeoutOption(internals) : undefined,
            // HTTP/2 options
            h2session: internals.h2session,
        };
    }
    getRequestFunction() {
        const url = this._internals.url;
        const { request } = this._internals;
        if (!request && url) {
            return this.getFallbackRequestFunction();
        }
        return request;
    }
    getFallbackRequestFunction() {
        const url = this._internals.url;
        if (!url) {
            return;
        }
        if (url.protocol === 'https:') {
            if (this._internals.http2) {
                if (major < 15 || (major === 15 && minor < 10)) {
                    const error = new Error('To use the `http2` option, install Node.js 15.10.0 or above');
                    error.code = 'EUNSUPPORTED';
                    throw error;
                }
                return http2_wrapper__WEBPACK_IMPORTED_MODULE_8__.auto;
            }
            return node_https__WEBPACK_IMPORTED_MODULE_5__.request;
        }
        return node_http__WEBPACK_IMPORTED_MODULE_4__.request;
    }
    freeze() {
        const options = this._internals;
        Object.freeze(options);
        Object.freeze(options.hooks);
        Object.freeze(options.hooks.afterResponse);
        Object.freeze(options.hooks.beforeError);
        Object.freeze(options.hooks.beforeRedirect);
        Object.freeze(options.hooks.beforeRequest);
        Object.freeze(options.hooks.beforeRetry);
        Object.freeze(options.hooks.init);
        Object.freeze(options.https);
        Object.freeze(options.cacheOptions);
        Object.freeze(options.agent);
        Object.freeze(options.headers);
        Object.freeze(options.timeout);
        Object.freeze(options.retry);
        Object.freeze(options.retry.errorCodes);
        Object.freeze(options.retry.methods);
        Object.freeze(options.retry.statusCodes);
    }
}


/***/ }),

/***/ "./node_modules/got/dist/source/core/parse-link-header.js":
/*!****************************************************************!*\
  !*** ./node_modules/got/dist/source/core/parse-link-header.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parseLinkHeader)
/* harmony export */ });
function parseLinkHeader(link) {
    const parsed = [];
    const items = link.split(',');
    for (const item of items) {
        // https://tools.ietf.org/html/rfc5988#section-5
        const [rawUriReference, ...rawLinkParameters] = item.split(';');
        const trimmedUriReference = rawUriReference.trim();
        // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
        if (trimmedUriReference[0] !== '<' || trimmedUriReference[trimmedUriReference.length - 1] !== '>') {
            throw new Error(`Invalid format of the Link header reference: ${trimmedUriReference}`);
        }
        const reference = trimmedUriReference.slice(1, -1);
        const parameters = {};
        if (rawLinkParameters.length === 0) {
            throw new Error(`Unexpected end of Link header parameters: ${rawLinkParameters.join(';')}`);
        }
        for (const rawParameter of rawLinkParameters) {
            const trimmedRawParameter = rawParameter.trim();
            const center = trimmedRawParameter.indexOf('=');
            if (center === -1) {
                throw new Error(`Failed to parse Link header: ${link}`);
            }
            const name = trimmedRawParameter.slice(0, center).trim();
            const value = trimmedRawParameter.slice(center + 1).trim();
            parameters[name] = value;
        }
        parsed.push({
            reference,
            parameters,
        });
    }
    return parsed;
}


/***/ }),

/***/ "./node_modules/got/dist/source/core/response.js":
/*!*******************************************************!*\
  !*** ./node_modules/got/dist/source/core/response.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParseError": () => (/* binding */ ParseError),
/* harmony export */   "isResponseOk": () => (/* binding */ isResponseOk),
/* harmony export */   "parseBody": () => (/* binding */ parseBody)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ "./node_modules/got/dist/source/core/errors.js");

const isResponseOk = (response) => {
    const { statusCode } = response;
    const limitStatusCode = response.request.options.followRedirect ? 299 : 399;
    return (statusCode >= 200 && statusCode <= limitStatusCode) || statusCode === 304;
};
/**
An error to be thrown when server response code is 2xx, and parsing body fails.
Includes a `response` property.
*/
class ParseError extends _errors_js__WEBPACK_IMPORTED_MODULE_0__.RequestError {
    constructor(error, response) {
        const { options } = response.request;
        super(`${error.message} in "${options.url.toString()}"`, error, response.request);
        this.name = 'ParseError';
        this.code = 'ERR_BODY_PARSE_FAILURE';
    }
}
const parseBody = (response, responseType, parseJson, encoding) => {
    const { rawBody } = response;
    try {
        if (responseType === 'text') {
            return rawBody.toString(encoding);
        }
        if (responseType === 'json') {
            return rawBody.length === 0 ? '' : parseJson(rawBody.toString(encoding));
        }
        if (responseType === 'buffer') {
            return rawBody;
        }
    }
    catch (error) {
        throw new ParseError(error, response);
    }
    throw new ParseError({
        message: `Unknown body type '${responseType}'`,
        name: 'Error',
    }, response);
};


/***/ }),

/***/ "./node_modules/got/dist/source/core/timed-out.js":
/*!********************************************************!*\
  !*** ./node_modules/got/dist/source/core/timed-out.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TimeoutError": () => (/* binding */ TimeoutError),
/* harmony export */   "default": () => (/* binding */ timedOut)
/* harmony export */ });
/* harmony import */ var node_net__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:net */ "node:net");
/* harmony import */ var _utils_unhandle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/unhandle.js */ "./node_modules/got/dist/source/core/utils/unhandle.js");


const reentry = Symbol('reentry');
const noop = () => { };
class TimeoutError extends Error {
    constructor(threshold, event) {
        super(`Timeout awaiting '${event}' for ${threshold}ms`);
        Object.defineProperty(this, "event", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: event
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'TimeoutError';
        this.code = 'ETIMEDOUT';
    }
}
function timedOut(request, delays, options) {
    if (reentry in request) {
        return noop;
    }
    request[reentry] = true;
    const cancelers = [];
    const { once, unhandleAll } = (0,_utils_unhandle_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
    const addTimeout = (delay, callback, event) => {
        const timeout = setTimeout(callback, delay, delay, event);
        timeout.unref?.();
        const cancel = () => {
            clearTimeout(timeout);
        };
        cancelers.push(cancel);
        return cancel;
    };
    const { host, hostname } = options;
    const timeoutHandler = (delay, event) => {
        request.destroy(new TimeoutError(delay, event));
    };
    const cancelTimeouts = () => {
        for (const cancel of cancelers) {
            cancel();
        }
        unhandleAll();
    };
    request.once('error', error => {
        cancelTimeouts();
        // Save original behavior
        /* istanbul ignore next */
        if (request.listenerCount('error') === 0) {
            throw error;
        }
    });
    if (typeof delays.request !== 'undefined') {
        const cancelTimeout = addTimeout(delays.request, timeoutHandler, 'request');
        once(request, 'response', (response) => {
            once(response, 'end', cancelTimeout);
        });
    }
    if (typeof delays.socket !== 'undefined') {
        const { socket } = delays;
        const socketTimeoutHandler = () => {
            timeoutHandler(socket, 'socket');
        };
        request.setTimeout(socket, socketTimeoutHandler);
        // `request.setTimeout(0)` causes a memory leak.
        // We can just remove the listener and forget about the timer - it's unreffed.
        // See https://github.com/sindresorhus/got/issues/690
        cancelers.push(() => {
            request.removeListener('timeout', socketTimeoutHandler);
        });
    }
    const hasLookup = typeof delays.lookup !== 'undefined';
    const hasConnect = typeof delays.connect !== 'undefined';
    const hasSecureConnect = typeof delays.secureConnect !== 'undefined';
    const hasSend = typeof delays.send !== 'undefined';
    if (hasLookup || hasConnect || hasSecureConnect || hasSend) {
        once(request, 'socket', (socket) => {
            const { socketPath } = request;
            /* istanbul ignore next: hard to test */
            if (socket.connecting) {
                const hasPath = Boolean(socketPath ?? node_net__WEBPACK_IMPORTED_MODULE_0__.isIP(hostname ?? host ?? '') !== 0);
                if (hasLookup && !hasPath && typeof socket.address().address === 'undefined') {
                    const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');
                    once(socket, 'lookup', cancelTimeout);
                }
                if (hasConnect) {
                    const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');
                    if (hasPath) {
                        once(socket, 'connect', timeConnect());
                    }
                    else {
                        once(socket, 'lookup', (error) => {
                            if (error === null) {
                                once(socket, 'connect', timeConnect());
                            }
                        });
                    }
                }
                if (hasSecureConnect && options.protocol === 'https:') {
                    once(socket, 'connect', () => {
                        const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');
                        once(socket, 'secureConnect', cancelTimeout);
                    });
                }
            }
            if (hasSend) {
                const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');
                /* istanbul ignore next: hard to test */
                if (socket.connecting) {
                    once(socket, 'connect', () => {
                        once(request, 'upload-complete', timeRequest());
                    });
                }
                else {
                    once(request, 'upload-complete', timeRequest());
                }
            }
        });
    }
    if (typeof delays.response !== 'undefined') {
        once(request, 'upload-complete', () => {
            const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');
            once(request, 'response', cancelTimeout);
        });
    }
    if (typeof delays.read !== 'undefined') {
        once(request, 'response', (response) => {
            const cancelTimeout = addTimeout(delays.read, timeoutHandler, 'read');
            once(response, 'end', cancelTimeout);
        });
    }
    return cancelTimeouts;
}


/***/ }),

/***/ "./node_modules/got/dist/source/core/utils/get-body-size.js":
/*!******************************************************************!*\
  !*** ./node_modules/got/dist/source/core/utils/get-body-size.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBodySize)
/* harmony export */ });
/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:buffer */ "node:buffer");
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var _sindresorhus_is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sindresorhus/is */ "./node_modules/@sindresorhus/is/dist/index.js");
/* harmony import */ var _is_form_data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is-form-data.js */ "./node_modules/got/dist/source/core/utils/is-form-data.js");




async function getBodySize(body, headers) {
    if (headers && 'content-length' in headers) {
        return Number(headers['content-length']);
    }
    if (!body) {
        return 0;
    }
    if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_2__["default"].string(body)) {
        return node_buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.byteLength(body);
    }
    if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_2__["default"].buffer(body)) {
        return body.length;
    }
    if ((0,_is_form_data_js__WEBPACK_IMPORTED_MODULE_3__["default"])(body)) {
        return (0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(body.getLength.bind(body))();
    }
    return undefined;
}


/***/ }),

/***/ "./node_modules/got/dist/source/core/utils/is-client-request.js":
/*!**********************************************************************!*\
  !*** ./node_modules/got/dist/source/core/utils/is-client-request.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function isClientRequest(clientRequest) {
    return clientRequest.writable && !clientRequest.writableEnded;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isClientRequest);


/***/ }),

/***/ "./node_modules/got/dist/source/core/utils/is-form-data.js":
/*!*****************************************************************!*\
  !*** ./node_modules/got/dist/source/core/utils/is-form-data.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isFormData)
/* harmony export */ });
/* harmony import */ var _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sindresorhus/is */ "./node_modules/@sindresorhus/is/dist/index.js");

function isFormData(body) {
    return _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__["default"].nodeStream(body) && _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__["default"].function_(body.getBoundary);
}


/***/ }),

/***/ "./node_modules/got/dist/source/core/utils/is-unix-socket-url.js":
/*!***********************************************************************!*\
  !*** ./node_modules/got/dist/source/core/utils/is-unix-socket-url.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isUnixSocketURL)
/* harmony export */ });
// eslint-disable-next-line @typescript-eslint/naming-convention
function isUnixSocketURL(url) {
    return url.protocol === 'unix:' || url.hostname === 'unix';
}


/***/ }),

/***/ "./node_modules/got/dist/source/core/utils/proxy-events.js":
/*!*****************************************************************!*\
  !*** ./node_modules/got/dist/source/core/utils/proxy-events.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ proxyEvents)
/* harmony export */ });
function proxyEvents(from, to, events) {
    const eventFunctions = {};
    for (const event of events) {
        const eventFunction = (...args) => {
            to.emit(event, ...args);
        };
        eventFunctions[event] = eventFunction;
        from.on(event, eventFunction);
    }
    return () => {
        for (const [event, eventFunction] of Object.entries(eventFunctions)) {
            from.off(event, eventFunction);
        }
    };
}


/***/ }),

/***/ "./node_modules/got/dist/source/core/utils/unhandle.js":
/*!*************************************************************!*\
  !*** ./node_modules/got/dist/source/core/utils/unhandle.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unhandle)
/* harmony export */ });
// When attaching listeners, it's very easy to forget about them.
// Especially if you do error handling and set timeouts.
// So instead of checking if it's proper to throw an error on every timeout ever,
// use this simple tool which will remove all listeners you have attached.
function unhandle() {
    const handlers = [];
    return {
        once(origin, event, fn) {
            origin.once(event, fn);
            handlers.push({ origin, event, fn });
        },
        unhandleAll() {
            for (const handler of handlers) {
                const { origin, event, fn } = handler;
                origin.removeListener(event, fn);
            }
            handlers.length = 0;
        },
    };
}


/***/ }),

/***/ "./node_modules/got/dist/source/core/utils/url-to-options.js":
/*!*******************************************************************!*\
  !*** ./node_modules/got/dist/source/core/utils/url-to-options.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ urlToOptions)
/* harmony export */ });
/* harmony import */ var _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sindresorhus/is */ "./node_modules/@sindresorhus/is/dist/index.js");

function urlToOptions(url) {
    // Cast to URL
    url = url;
    const options = {
        protocol: url.protocol,
        hostname: _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__["default"].string(url.hostname) && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ''}${url.search || ''}`,
    };
    if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__["default"].string(url.port) && url.port.length > 0) {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = `${url.username || ''}:${url.password || ''}`;
    }
    return options;
}


/***/ }),

/***/ "./node_modules/got/dist/source/core/utils/weakable-map.js":
/*!*****************************************************************!*\
  !*** ./node_modules/got/dist/source/core/utils/weakable-map.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WeakableMap)
/* harmony export */ });
class WeakableMap {
    constructor() {
        Object.defineProperty(this, "weakMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "map", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.weakMap = new WeakMap();
        this.map = new Map();
    }
    set(key, value) {
        if (typeof key === 'object') {
            this.weakMap.set(key, value);
        }
        else {
            this.map.set(key, value);
        }
    }
    get(key) {
        if (typeof key === 'object') {
            return this.weakMap.get(key);
        }
        return this.map.get(key);
    }
    has(key) {
        if (typeof key === 'object') {
            return this.weakMap.has(key);
        }
        return this.map.has(key);
    }
}


/***/ }),

/***/ "./node_modules/got/dist/source/create.js":
/*!************************************************!*\
  !*** ./node_modules/got/dist/source/create.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sindresorhus/is */ "./node_modules/@sindresorhus/is/dist/index.js");
/* harmony import */ var _as_promise_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./as-promise/index.js */ "./node_modules/got/dist/source/as-promise/index.js");
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/index.js */ "./node_modules/got/dist/source/core/index.js");
/* harmony import */ var _core_options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/options.js */ "./node_modules/got/dist/source/core/options.js");




// The `delay` package weighs 10KB (!)
const delay = async (ms) => new Promise(resolve => {
    setTimeout(resolve, ms);
});
const isGotInstance = (value) => _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__["default"].function_(value);
const aliases = [
    'get',
    'post',
    'put',
    'patch',
    'head',
    'delete',
];
const create = (defaults) => {
    defaults = {
        options: new _core_options_js__WEBPACK_IMPORTED_MODULE_1__["default"](undefined, undefined, defaults.options),
        handlers: [...defaults.handlers],
        mutableDefaults: defaults.mutableDefaults,
    };
    Object.defineProperty(defaults, 'mutableDefaults', {
        enumerable: true,
        configurable: false,
        writable: false,
    });
    // Got interface
    const got = ((url, options, defaultOptions = defaults.options) => {
        const request = new _core_index_js__WEBPACK_IMPORTED_MODULE_2__["default"](url, options, defaultOptions);
        let promise;
        const lastHandler = (normalized) => {
            // Note: `options` is `undefined` when `new Options(...)` fails
            request.options = normalized;
            request._noPipe = !normalized.isStream;
            void request.flush();
            if (normalized.isStream) {
                return request;
            }
            if (!promise) {
                promise = (0,_as_promise_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(request);
            }
            return promise;
        };
        let iteration = 0;
        const iterateHandlers = (newOptions) => {
            const handler = defaults.handlers[iteration++] ?? lastHandler;
            const result = handler(newOptions, iterateHandlers);
            if (_sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__["default"].promise(result) && !request.options.isStream) {
                if (!promise) {
                    promise = (0,_as_promise_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(request);
                }
                if (result !== promise) {
                    const descriptors = Object.getOwnPropertyDescriptors(promise);
                    for (const key in descriptors) {
                        if (key in result) {
                            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                            delete descriptors[key];
                        }
                    }
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    Object.defineProperties(result, descriptors);
                    result.cancel = promise.cancel;
                }
            }
            return result;
        };
        return iterateHandlers(request.options);
    });
    got.extend = (...instancesOrOptions) => {
        const options = new _core_options_js__WEBPACK_IMPORTED_MODULE_1__["default"](undefined, undefined, defaults.options);
        const handlers = [...defaults.handlers];
        let mutableDefaults;
        for (const value of instancesOrOptions) {
            if (isGotInstance(value)) {
                options.merge(value.defaults.options);
                handlers.push(...value.defaults.handlers);
                mutableDefaults = value.defaults.mutableDefaults;
            }
            else {
                options.merge(value);
                if (value.handlers) {
                    handlers.push(...value.handlers);
                }
                mutableDefaults = value.mutableDefaults;
            }
        }
        return create({
            options,
            handlers,
            mutableDefaults: Boolean(mutableDefaults),
        });
    };
    // Pagination
    const paginateEach = (async function* (url, options) {
        let normalizedOptions = new _core_options_js__WEBPACK_IMPORTED_MODULE_1__["default"](url, options, defaults.options);
        normalizedOptions.resolveBodyOnly = false;
        const { pagination } = normalizedOptions;
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__.assert.function_(pagination.transform);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__.assert.function_(pagination.shouldContinue);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__.assert.function_(pagination.filter);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__.assert.function_(pagination.paginate);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__.assert.number(pagination.countLimit);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__.assert.number(pagination.requestLimit);
        _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__.assert.number(pagination.backoff);
        const allItems = [];
        let { countLimit } = pagination;
        let numberOfRequests = 0;
        while (numberOfRequests < pagination.requestLimit) {
            if (numberOfRequests !== 0) {
                // eslint-disable-next-line no-await-in-loop
                await delay(pagination.backoff);
            }
            // eslint-disable-next-line no-await-in-loop
            const response = (await got(undefined, undefined, normalizedOptions));
            // eslint-disable-next-line no-await-in-loop
            const parsed = await pagination.transform(response);
            const currentItems = [];
            _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__.assert.array(parsed);
            for (const item of parsed) {
                if (pagination.filter({ item, currentItems, allItems })) {
                    if (!pagination.shouldContinue({ item, currentItems, allItems })) {
                        return;
                    }
                    yield item;
                    if (pagination.stackAllItems) {
                        allItems.push(item);
                    }
                    currentItems.push(item);
                    if (--countLimit <= 0) {
                        return;
                    }
                }
            }
            const optionsToMerge = pagination.paginate({
                response,
                currentItems,
                allItems,
            });
            if (optionsToMerge === false) {
                return;
            }
            if (optionsToMerge === response.request.options) {
                normalizedOptions = response.request.options;
            }
            else {
                normalizedOptions.merge(optionsToMerge);
                _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__.assert.any([_sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__["default"].urlInstance, _sindresorhus_is__WEBPACK_IMPORTED_MODULE_0__["default"].undefined], optionsToMerge.url);
                if (optionsToMerge.url !== undefined) {
                    normalizedOptions.prefixUrl = '';
                    normalizedOptions.url = optionsToMerge.url;
                }
            }
            numberOfRequests++;
        }
    });
    got.paginate = paginateEach;
    got.paginate.all = (async (url, options) => {
        const results = [];
        for await (const item of paginateEach(url, options)) {
            results.push(item);
        }
        return results;
    });
    // For those who like very descriptive names
    got.paginate.each = paginateEach;
    // Stream API
    got.stream = ((url, options) => got(url, { ...options, isStream: true }));
    // Shortcuts
    for (const method of aliases) {
        got[method] = ((url, options) => got(url, { ...options, method }));
        got.stream[method] = ((url, options) => got(url, { ...options, method, isStream: true }));
    }
    if (!defaults.mutableDefaults) {
        Object.freeze(defaults.handlers);
        defaults.options.freeze();
    }
    Object.defineProperty(got, 'defaults', {
        value: defaults,
        writable: false,
        configurable: false,
        enumerable: true,
    });
    return got;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (create);


/***/ }),

/***/ "./node_modules/got/dist/source/index.js":
/*!***********************************************!*\
  !*** ./node_modules/got/dist/source/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbortError": () => (/* reexport safe */ _core_errors_js__WEBPACK_IMPORTED_MODULE_3__.AbortError),
/* harmony export */   "CacheError": () => (/* reexport safe */ _core_errors_js__WEBPACK_IMPORTED_MODULE_3__.CacheError),
/* harmony export */   "CancelError": () => (/* reexport safe */ _as_promise_types_js__WEBPACK_IMPORTED_MODULE_5__.CancelError),
/* harmony export */   "HTTPError": () => (/* reexport safe */ _core_errors_js__WEBPACK_IMPORTED_MODULE_3__.HTTPError),
/* harmony export */   "MaxRedirectsError": () => (/* reexport safe */ _core_errors_js__WEBPACK_IMPORTED_MODULE_3__.MaxRedirectsError),
/* harmony export */   "Options": () => (/* reexport safe */ _core_options_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "ParseError": () => (/* reexport safe */ _core_response_js__WEBPACK_IMPORTED_MODULE_2__.ParseError),
/* harmony export */   "ReadError": () => (/* reexport safe */ _core_errors_js__WEBPACK_IMPORTED_MODULE_3__.ReadError),
/* harmony export */   "RequestError": () => (/* reexport safe */ _core_errors_js__WEBPACK_IMPORTED_MODULE_3__.RequestError),
/* harmony export */   "RetryError": () => (/* reexport safe */ _core_errors_js__WEBPACK_IMPORTED_MODULE_3__.RetryError),
/* harmony export */   "TimeoutError": () => (/* reexport safe */ _core_errors_js__WEBPACK_IMPORTED_MODULE_3__.TimeoutError),
/* harmony export */   "UploadError": () => (/* reexport safe */ _core_errors_js__WEBPACK_IMPORTED_MODULE_3__.UploadError),
/* harmony export */   "calculateRetryDelay": () => (/* reexport safe */ _core_calculate_retry_delay_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "create": () => (/* reexport safe */ _create_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "got": () => (/* binding */ got),
/* harmony export */   "isResponseOk": () => (/* reexport safe */ _core_response_js__WEBPACK_IMPORTED_MODULE_2__.isResponseOk),
/* harmony export */   "parseBody": () => (/* reexport safe */ _core_response_js__WEBPACK_IMPORTED_MODULE_2__.parseBody),
/* harmony export */   "parseLinkHeader": () => (/* reexport safe */ _core_parse_link_header_js__WEBPACK_IMPORTED_MODULE_6__["default"])
/* harmony export */ });
/* harmony import */ var _create_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./create.js */ "./node_modules/got/dist/source/create.js");
/* harmony import */ var _core_options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/options.js */ "./node_modules/got/dist/source/core/options.js");
/* harmony import */ var _core_response_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/response.js */ "./node_modules/got/dist/source/core/response.js");
/* harmony import */ var _core_errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/errors.js */ "./node_modules/got/dist/source/core/errors.js");
/* harmony import */ var _core_calculate_retry_delay_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/calculate-retry-delay.js */ "./node_modules/got/dist/source/core/calculate-retry-delay.js");
/* harmony import */ var _as_promise_types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./as-promise/types.js */ "./node_modules/got/dist/source/as-promise/types.js");
/* harmony import */ var _core_parse_link_header_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/parse-link-header.js */ "./node_modules/got/dist/source/core/parse-link-header.js");


const defaults = {
    options: new _core_options_js__WEBPACK_IMPORTED_MODULE_0__["default"](),
    handlers: [],
    mutableDefaults: false,
};
const got = (0,_create_js__WEBPACK_IMPORTED_MODULE_1__["default"])(defaults);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (got);













/***/ }),

/***/ "./node_modules/lowercase-keys/index.js":
/*!**********************************************!*\
  !*** ./node_modules/lowercase-keys/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lowercaseKeys)
/* harmony export */ });
function lowercaseKeys(object) {
	return Object.fromEntries(Object.entries(object).map(([key, value]) => [key.toLowerCase(), value]));
}


/***/ }),

/***/ "./node_modules/mimic-response/index.js":
/*!**********************************************!*\
  !*** ./node_modules/mimic-response/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mimicResponse)
/* harmony export */ });
// We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage
const knownProperties = [
	'aborted',
	'complete',
	'headers',
	'httpVersion',
	'httpVersionMinor',
	'httpVersionMajor',
	'method',
	'rawHeaders',
	'rawTrailers',
	'setTimeout',
	'socket',
	'statusCode',
	'statusMessage',
	'trailers',
	'url',
];

function mimicResponse(fromStream, toStream) {
	if (toStream._readableState.autoDestroy) {
		throw new Error('The second stream must have the `autoDestroy` option set to `false`');
	}

	const fromProperties = new Set([...Object.keys(fromStream), ...knownProperties]);

	const properties = {};

	for (const property of fromProperties) {
		// Don't overwrite existing properties.
		if (property in toStream) {
			continue;
		}

		properties[property] = {
			get() {
				const value = fromStream[property];
				const isFunction = typeof value === 'function';

				return isFunction ? value.bind(fromStream) : value;
			},
			set(value) {
				fromStream[property] = value;
			},
			enumerable: true,
			configurable: false,
		};
	}

	Object.defineProperties(toStream, properties);

	fromStream.once('aborted', () => {
		toStream.destroy();

		toStream.emit('aborted');
	});

	fromStream.once('close', () => {
		if (fromStream.complete) {
			if (toStream.readable) {
				toStream.once('end', () => {
					toStream.emit('close');
				});
			} else {
				toStream.emit('close');
			}
		} else {
			toStream.emit('close');
		}
	});

	return toStream;
}


/***/ }),

/***/ "./node_modules/normalize-url/index.js":
/*!*********************************************!*\
  !*** ./node_modules/normalize-url/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ normalizeUrl)
/* harmony export */ });
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
const DATA_URL_DEFAULT_MIME_TYPE = 'text/plain';
const DATA_URL_DEFAULT_CHARSET = 'us-ascii';

const testParameter = (name, filters) => filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name);

const supportedProtocols = new Set([
	'https:',
	'http:',
	'file:',
]);

const hasCustomProtocol = urlString => {
	try {
		const {protocol} = new URL(urlString);
		return protocol.endsWith(':') && !supportedProtocols.has(protocol);
	} catch {
		return false;
	}
};

const normalizeDataURL = (urlString, {stripHash}) => {
	const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);

	if (!match) {
		throw new Error(`Invalid URL: ${urlString}`);
	}

	let {type, data, hash} = match.groups;
	const mediaType = type.split(';');
	hash = stripHash ? '' : hash;

	let isBase64 = false;
	if (mediaType[mediaType.length - 1] === 'base64') {
		mediaType.pop();
		isBase64 = true;
	}

	// Lowercase MIME type
	const mimeType = mediaType.shift()?.toLowerCase() ?? '';
	const attributes = mediaType
		.map(attribute => {
			let [key, value = ''] = attribute.split('=').map(string => string.trim());

			// Lowercase `charset`
			if (key === 'charset') {
				value = value.toLowerCase();

				if (value === DATA_URL_DEFAULT_CHARSET) {
					return '';
				}
			}

			return `${key}${value ? `=${value}` : ''}`;
		})
		.filter(Boolean);

	const normalizedMediaType = [
		...attributes,
	];

	if (isBase64) {
		normalizedMediaType.push('base64');
	}

	if (normalizedMediaType.length > 0 || (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)) {
		normalizedMediaType.unshift(mimeType);
	}

	return `data:${normalizedMediaType.join(';')},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ''}`;
};

function normalizeUrl(urlString, options) {
	options = {
		defaultProtocol: 'http',
		normalizeProtocol: true,
		forceHttp: false,
		forceHttps: false,
		stripAuthentication: true,
		stripHash: false,
		stripTextFragment: true,
		stripWWW: true,
		removeQueryParameters: [/^utm_\w+/i],
		removeTrailingSlash: true,
		removeSingleSlash: true,
		removeDirectoryIndex: false,
		removeExplicitPort: false,
		sortQueryParameters: true,
		...options,
	};

	// Legacy: Append `:` to the protocol if missing.
	if (typeof options.defaultProtocol === 'string' && !options.defaultProtocol.endsWith(':')) {
		options.defaultProtocol = `${options.defaultProtocol}:`;
	}

	urlString = urlString.trim();

	// Data URL
	if (/^data:/i.test(urlString)) {
		return normalizeDataURL(urlString, options);
	}

	if (hasCustomProtocol(urlString)) {
		return urlString;
	}

	const hasRelativeProtocol = urlString.startsWith('//');
	const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);

	// Prepend protocol
	if (!isRelativeUrl) {
		urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
	}

	const urlObject = new URL(urlString);

	if (options.forceHttp && options.forceHttps) {
		throw new Error('The `forceHttp` and `forceHttps` options cannot be used together');
	}

	if (options.forceHttp && urlObject.protocol === 'https:') {
		urlObject.protocol = 'http:';
	}

	if (options.forceHttps && urlObject.protocol === 'http:') {
		urlObject.protocol = 'https:';
	}

	// Remove auth
	if (options.stripAuthentication) {
		urlObject.username = '';
		urlObject.password = '';
	}

	// Remove hash
	if (options.stripHash) {
		urlObject.hash = '';
	} else if (options.stripTextFragment) {
		urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, '');
	}

	// Remove duplicate slashes if not preceded by a protocol
	// NOTE: This could be implemented using a single negative lookbehind
	// regex, but we avoid that to maintain compatibility with older js engines
	// which do not have support for that feature.
	if (urlObject.pathname) {
		// TODO: Replace everything below with `urlObject.pathname = urlObject.pathname.replace(/(?<!\b[a-z][a-z\d+\-.]{1,50}:)\/{2,}/g, '/');` when Safari supports negative lookbehind.

		// Split the string by occurrences of this protocol regex, and perform
		// duplicate-slash replacement on the strings between those occurrences
		// (if any).
		const protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g;

		let lastIndex = 0;
		let result = '';
		for (;;) {
			const match = protocolRegex.exec(urlObject.pathname);
			if (!match) {
				break;
			}

			const protocol = match[0];
			const protocolAtIndex = match.index;
			const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);

			result += intermediate.replace(/\/{2,}/g, '/');
			result += protocol;
			lastIndex = protocolAtIndex + protocol.length;
		}

		const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);
		result += remnant.replace(/\/{2,}/g, '/');

		urlObject.pathname = result;
	}

	// Decode URI octets
	if (urlObject.pathname) {
		try {
			urlObject.pathname = decodeURI(urlObject.pathname);
		} catch {}
	}

	// Remove directory index
	if (options.removeDirectoryIndex === true) {
		options.removeDirectoryIndex = [/^index\.[a-z]+$/];
	}

	if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
		let pathComponents = urlObject.pathname.split('/');
		const lastComponent = pathComponents[pathComponents.length - 1];

		if (testParameter(lastComponent, options.removeDirectoryIndex)) {
			pathComponents = pathComponents.slice(0, -1);
			urlObject.pathname = pathComponents.slice(1).join('/') + '/';
		}
	}

	if (urlObject.hostname) {
		// Remove trailing dot
		urlObject.hostname = urlObject.hostname.replace(/\.$/, '');

		// Remove `www.`
		if (options.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname)) {
			// Each label should be max 63 at length (min: 1).
			// Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
			// Each TLD should be up to 63 characters long (min: 2).
			// It is technically possible to have a single character TLD, but none currently exist.
			urlObject.hostname = urlObject.hostname.replace(/^www\./, '');
		}
	}

	// Remove query unwanted parameters
	if (Array.isArray(options.removeQueryParameters)) {
		// eslint-disable-next-line unicorn/no-useless-spread -- We are intentionally spreading to get a copy.
		for (const key of [...urlObject.searchParams.keys()]) {
			if (testParameter(key, options.removeQueryParameters)) {
				urlObject.searchParams.delete(key);
			}
		}
	}

	if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {
		urlObject.search = '';
	}

	// Keep wanted query parameters
	if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {
		// eslint-disable-next-line unicorn/no-useless-spread -- We are intentionally spreading to get a copy.
		for (const key of [...urlObject.searchParams.keys()]) {
			if (!testParameter(key, options.keepQueryParameters)) {
				urlObject.searchParams.delete(key);
			}
		}
	}

	// Sort query parameters
	if (options.sortQueryParameters) {
		urlObject.searchParams.sort();

		// Calling `.sort()` encodes the search parameters, so we need to decode them again.
		try {
			urlObject.search = decodeURIComponent(urlObject.search);
		} catch {}
	}

	if (options.removeTrailingSlash) {
		urlObject.pathname = urlObject.pathname.replace(/\/$/, '');
	}

	// Remove an explicit port number, excluding a default port number, if applicable
	if (options.removeExplicitPort && urlObject.port) {
		urlObject.port = '';
	}

	const oldUrlString = urlString;

	// Take advantage of many of the Node `url` normalizations
	urlString = urlObject.toString();

	if (!options.removeSingleSlash && urlObject.pathname === '/' && !oldUrlString.endsWith('/') && urlObject.hash === '') {
		urlString = urlString.replace(/\/$/, '');
	}

	// Remove ending `/` unless removeSingleSlash is false
	if ((options.removeTrailingSlash || urlObject.pathname === '/') && urlObject.hash === '' && options.removeSingleSlash) {
		urlString = urlString.replace(/\/$/, '');
	}

	// Restore relative protocol, if applicable
	if (hasRelativeProtocol && !options.normalizeProtocol) {
		urlString = urlString.replace(/^http:\/\//, '//');
	}

	// Remove http/https
	if (options.stripProtocol) {
		urlString = urlString.replace(/^(?:https?:)?\/\//, '');
	}

	return urlString;
}


/***/ }),

/***/ "./node_modules/p-cancelable/index.js":
/*!********************************************!*\
  !*** ./node_modules/p-cancelable/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CancelError": () => (/* binding */ CancelError),
/* harmony export */   "default": () => (/* binding */ PCancelable)
/* harmony export */ });
class CancelError extends Error {
	constructor(reason) {
		super(reason || 'Promise was canceled');
		this.name = 'CancelError';
	}

	get isCanceled() {
		return true;
	}
}

// TODO: Use private class fields when ESLint 8 is out.

class PCancelable {
	static fn(userFunction) {
		return (...arguments_) => {
			return new PCancelable((resolve, reject, onCancel) => {
				arguments_.push(onCancel);
				// eslint-disable-next-line promise/prefer-await-to-then
				userFunction(...arguments_).then(resolve, reject);
			});
		};
	}

	constructor(executor) {
		this._cancelHandlers = [];
		this._isPending = true;
		this._isCanceled = false;
		this._rejectOnCancel = true;

		this._promise = new Promise((resolve, reject) => {
			this._reject = reject;

			const onResolve = value => {
				if (!this._isCanceled || !onCancel.shouldReject) {
					this._isPending = false;
					resolve(value);
				}
			};

			const onReject = error => {
				this._isPending = false;
				reject(error);
			};

			const onCancel = handler => {
				if (!this._isPending) {
					throw new Error('The `onCancel` handler was attached after the promise settled.');
				}

				this._cancelHandlers.push(handler);
			};

			Object.defineProperties(onCancel, {
				shouldReject: {
					get: () => this._rejectOnCancel,
					set: boolean => {
						this._rejectOnCancel = boolean;
					}
				}
			});

			executor(onResolve, onReject, onCancel);
		});
	}

	then(onFulfilled, onRejected) {
		// eslint-disable-next-line promise/prefer-await-to-then
		return this._promise.then(onFulfilled, onRejected);
	}

	catch(onRejected) {
		// eslint-disable-next-line promise/prefer-await-to-then
		return this._promise.catch(onRejected);
	}

	finally(onFinally) {
		// eslint-disable-next-line promise/prefer-await-to-then
		return this._promise.finally(onFinally);
	}

	cancel(reason) {
		if (!this._isPending || this._isCanceled) {
			return;
		}

		this._isCanceled = true;

		if (this._cancelHandlers.length > 0) {
			try {
				for (const handler of this._cancelHandlers) {
					handler();
				}
			} catch (error) {
				this._reject(error);
				return;
			}
		}

		if (this._rejectOnCancel) {
			this._reject(new CancelError(reason));
		}
	}

	get isCanceled() {
		return this._isCanceled;
	}
}

Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);


/***/ }),

/***/ "./node_modules/responselike/index.js":
/*!********************************************!*\
  !*** ./node_modules/responselike/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Response)
/* harmony export */ });
/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:stream */ "node:stream");
/* harmony import */ var lowercase_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lowercase-keys */ "./node_modules/lowercase-keys/index.js");



class Response extends node_stream__WEBPACK_IMPORTED_MODULE_0__.Readable {
	statusCode;
	headers;
	body;
	url;

	constructor({statusCode, headers, body, url}) {
		if (typeof statusCode !== 'number') {
			throw new TypeError('Argument `statusCode` should be a number');
		}

		if (typeof headers !== 'object') {
			throw new TypeError('Argument `headers` should be an object');
		}

		if (!(body instanceof Uint8Array)) {
			throw new TypeError('Argument `body` should be a buffer');
		}

		if (typeof url !== 'string') {
			throw new TypeError('Argument `url` should be a string');
		}

		super({
			read() {
				this.push(body);
				this.push(null);
			},
		});

		this.statusCode = statusCode;
		this.headers = (0,lowercase_keys__WEBPACK_IMPORTED_MODULE_1__["default"])(headers);
		this.body = body;
		this.url = url;
	}
}


/***/ }),

/***/ "./node_modules/webdriver/build/request/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/webdriver/build/request/index.js ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RequestLibError": () => (/* binding */ RequestLibError),
/* harmony export */   "default": () => (/* binding */ WebDriverRequest)
/* harmony export */ });
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ "node:path");
/* harmony import */ var node_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:events */ "node:events");
/* harmony import */ var node_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:module */ "node:module");
/* harmony import */ var _wdio_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @wdio/logger */ "./node_modules/@wdio/logger/build/index.js");
/* harmony import */ var _wdio_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wdio/utils */ "./node_modules/@wdio/utils/build/index.js");
/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./factory.js */ "./node_modules/webdriver/build/request/factory.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/webdriver/build/utils.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_wdio_logger__WEBPACK_IMPORTED_MODULE_3__, _wdio_utils__WEBPACK_IMPORTED_MODULE_4__, _utils_js__WEBPACK_IMPORTED_MODULE_6__]);
([_wdio_logger__WEBPACK_IMPORTED_MODULE_3__, _wdio_utils__WEBPACK_IMPORTED_MODULE_4__, _utils_js__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);







const require = (0,node_module__WEBPACK_IMPORTED_MODULE_2__.createRequire)("file:///C:/Users/jortw/Documents/Development/23feb-JortW/cli-test/node_modules/webdriver/build/request/index.js");
const pkg = require('../../package.json');
class RequestLibError extends Error {
    statusCode;
    body;
    code;
}
const DEFAULT_HEADERS = {
    'Content-Type': 'application/json; charset=utf-8',
    'Connection': 'keep-alive',
    'Accept': 'application/json',
    'User-Agent': 'webdriver/' + pkg.version
};
const log = (0,_wdio_logger__WEBPACK_IMPORTED_MODULE_3__["default"])('webdriver');
class WebDriverRequest extends node_events__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {
    body;
    method;
    endpoint;
    isHubCommand;
    requiresSessionId;
    defaultAgents;
    defaultOptions = {
        followRedirect: true,
        responseType: 'json',
        throwHttpErrors: false
    };
    constructor(method, endpoint, body, isHubCommand = false) {
        super();
        this.body = body;
        this.method = method;
        this.endpoint = endpoint;
        this.isHubCommand = isHubCommand;
        this.requiresSessionId = Boolean(this.endpoint.match(/:sessionId/));
    }
    async makeRequest(options, sessionId) {
        let fullRequestOptions = Object.assign({ method: this.method }, this.defaultOptions, await this._createOptions(options, sessionId));
        if (typeof options.transformRequest === 'function') {
            fullRequestOptions = options.transformRequest(fullRequestOptions);
        }
        this.emit('request', fullRequestOptions);
        return this._request(fullRequestOptions, options.transformResponse, options.connectionRetryCount, 0);
    }
    async _createOptions(options, sessionId, isBrowser = false) {
        const agent = isBrowser ? undefined : (options.agent || this.defaultAgents);
        const searchParams = isBrowser ?
            undefined :
            (typeof options.queryParams === 'object' ? options.queryParams : {});
        const requestOptions = {
            https: {},
            agent,
            headers: {
                ...DEFAULT_HEADERS,
                ...(typeof options.headers === 'object' ? options.headers : {})
            },
            searchParams,
            retry: { limit: options.connectionRetryCount },
            timeout: { response: options.connectionRetryTimeout }
        };
        /**
         * only apply body property if existing
         */
        if (this.body && (Object.keys(this.body).length || this.method === 'POST')) {
            const contentLength = Buffer.byteLength(JSON.stringify(this.body), 'utf8');
            requestOptions.json = this.body;
            requestOptions.headers['Content-Length'] = `${contentLength}`;
        }
        /**
         * if we don't have a session id we set it here, unless we call commands that don't require session ids, for
         * example /sessions. The call to /sessions is not connected to a session itself and it therefore doesn't
         * require it
         */
        let endpoint = this.endpoint;
        if (this.requiresSessionId) {
            if (!sessionId) {
                throw new Error('A sessionId is required for this command');
            }
            endpoint = endpoint.replace(':sessionId', sessionId);
        }
        requestOptions.url = await _factory_js__WEBPACK_IMPORTED_MODULE_5__.URLFactory.getInstance(`${options.protocol}://` +
            `${options.hostname}:${options.port}` +
            (this.isHubCommand ? this.endpoint : node_path__WEBPACK_IMPORTED_MODULE_0__.join(options.path || '', endpoint)));
        /**
         * send authentication credentials only when creating new session
         */
        if (this.endpoint === '/session' && options.user && options.key) {
            requestOptions.username = options.user;
            requestOptions.password = options.key;
        }
        /**
         * if the environment variable "STRICT_SSL" is defined as "false", it doesn't require SSL certificates to be valid.
         * Or the requestOptions has strictSSL for an environment which cannot get the environment variable correctly like on an Electron app.
         */
        requestOptions.https.rejectUnauthorized = !(options.strictSSL === false ||
            process.env.STRICT_SSL === 'false' ||
            process.env.strict_ssl === 'false');
        return requestOptions;
    }
    async _libRequest(url, options) {
        throw new Error('This function must be implemented');
    }
    _libPerformanceNow() {
        throw new Error('This function must be implemented');
    }
    async _request(fullRequestOptions, transformResponse, totalRetryCount = 0, retryCount = 0) {
        log.info(`[${fullRequestOptions.method}] ${fullRequestOptions.url.href}`);
        if (fullRequestOptions.json && Object.keys(fullRequestOptions.json).length) {
            log.info('DATA', (0,_wdio_utils__WEBPACK_IMPORTED_MODULE_4__.transformCommandLogResult)(fullRequestOptions.json));
        }
        const { url, ...requestLibOptions } = fullRequestOptions;
        const startTime = this._libPerformanceNow();
        let response = await this._libRequest(url, requestLibOptions)
            .catch((err) => err);
        const durationMillisecond = this._libPerformanceNow() - startTime;
        /**
         * handle retries for requests
         * @param {Error} error  error object that causes the retry
         * @param {String} msg   message that is being shown as warning to user
         */
        const retry = (error, msg) => {
            /**
             * stop retrying if totalRetryCount was exceeded or there is no reason to
             * retry, e.g. if sessionId is invalid
             */
            if (retryCount >= totalRetryCount || error.message.includes('invalid session id')) {
                log.error(`Request failed with status ${response.statusCode} due to ${error}`);
                this.emit('response', { error });
                this.emit('performance', { request: fullRequestOptions, durationMillisecond, success: false, error, retryCount });
                throw error;
            }
            ++retryCount;
            this.emit('retry', { error, retryCount });
            this.emit('performance', { request: fullRequestOptions, durationMillisecond, success: false, error, retryCount });
            log.warn(msg);
            log.info(`Retrying ${retryCount}/${totalRetryCount}`);
            return this._request(fullRequestOptions, transformResponse, totalRetryCount, retryCount);
        };
        /**
         * handle request errors
         */
        if (response instanceof Error) {
            /**
             * handle timeouts
             */
            if (response.code === 'ETIMEDOUT') {
                const error = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getTimeoutError)(response, fullRequestOptions);
                return retry(error, 'Request timed out! Consider increasing the "connectionRetryTimeout" option.');
            }
            /**
             * throw if request error is unknown
             */
            this.emit('performance', { request: fullRequestOptions, durationMillisecond, success: false, error: response, retryCount });
            throw response;
        }
        if (typeof transformResponse === 'function') {
            response = transformResponse(response, fullRequestOptions);
        }
        const error = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getErrorFromResponseBody)(response.body, fullRequestOptions.json);
        /**
         * retry connection refused errors
         */
        if (error.message === 'java.net.ConnectException: Connection refused: connect') {
            return retry(error, 'Connection to Selenium Standalone server was refused.');
        }
        /**
         * hub commands don't follow standard response formats
         * and can have empty bodies
         */
        if (this.isHubCommand) {
            /**
             * if body contains HTML the command was called on a node
             * directly without using a hub, therefore throw
             */
            if (typeof response.body === 'string' && response.body.startsWith('<!DOCTYPE html>')) {
                this.emit('performance', { request: fullRequestOptions, durationMillisecond, success: false, error, retryCount });
                return Promise.reject(new Error('Command can only be called to a Selenium Hub'));
            }
            return { value: response.body || null };
        }
        /**
         * Resolve only if successful response
         */
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.isSuccessfulResponse)(response.statusCode, response.body)) {
            this.emit('response', { result: response.body });
            this.emit('performance', { request: fullRequestOptions, durationMillisecond, success: true, retryCount });
            return response.body;
        }
        /**
         *  stop retrying as this will never be successful.
         *  we will handle this at the elementErrorHandler
         */
        if (error.name === 'stale element reference') {
            log.warn('Request encountered a stale element - terminating request');
            this.emit('response', { error });
            this.emit('performance', { request: fullRequestOptions, durationMillisecond, success: false, error, retryCount });
            throw error;
        }
        return retry(error, `Request failed with status ${response.statusCode} due to ${error.message}`);
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/webdriver/build/request/node.js":
/*!******************************************************!*\
  !*** ./node_modules/webdriver/build/request/node.js ***!
  \******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ NodeJSRequest)
/* harmony export */ });
/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:http */ "node:http");
/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:https */ "node:https");
/* harmony import */ var node_perf_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:perf_hooks */ "node:perf_hooks");
/* harmony import */ var got__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! got */ "./node_modules/got/dist/source/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.js */ "./node_modules/webdriver/build/request/index.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_index_js__WEBPACK_IMPORTED_MODULE_3__]);
_index_js__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];





const agents = {
    http: new node_http__WEBPACK_IMPORTED_MODULE_0__.Agent({ keepAlive: true }),
    https: new node_https__WEBPACK_IMPORTED_MODULE_1__.Agent({ keepAlive: true })
};
class NodeJSRequest extends _index_js__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(method, endpoint, body, isHubCommand = false) {
        super(method, endpoint, body, isHubCommand);
        this.defaultAgents = agents;
    }
    async _libRequest(url, opts) {
        try {
            return (await (0,got__WEBPACK_IMPORTED_MODULE_4__["default"])(url, opts));
        }
        catch (err) {
            if (!(err instanceof Error)) {
                throw new _index_js__WEBPACK_IMPORTED_MODULE_3__.RequestLibError(err.message || err);
            }
            throw err;
        }
    }
    _libPerformanceNow() {
        return node_perf_hooks__WEBPACK_IMPORTED_MODULE_2__.performance.now();
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ })

};
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfd2ViZHJpdmVyX2J1aWxkX3JlcXVlc3Rfbm9kZV9qcy5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBYTtBQUNiLE9BQU8sd0JBQXdCLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqRCxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0Isc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWdCOztBQUU5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDekRhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7Ozs7Ozs7Ozs7O0FDNUVhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxrQkFBa0I7QUFDbEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCLElBQUksc0JBQXNCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqcUJhO0FBQ2I7QUFDQTtBQUNBLE9BQU8sS0FBSyxFQUFFLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IscUJBQXFCLG1CQUFPLENBQUMsc0JBQVE7QUFDckMsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyxvREFBVztBQUNwQywwQkFBMEIsbUJBQU8sQ0FBQyx3R0FBZ0M7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHdHQUF3RyxJQUFJO0FBQzFIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFFBQVEsR0FBRyxPQUFPO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qyw4QkFBOEI7QUFDckU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLHlCQUF5QjtBQUMvQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksVUFBVTtBQUN0QjtBQUNBLGdDQUFnQyxVQUFVLDBCQUEwQixXQUFXO0FBQy9FO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCLEdBQUcsa0JBQWtCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFROztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7O0FBRUE7QUFDQSxlQUFlLHNCQUFzQjs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Es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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixxQkFBcUIsRUFBRSxVQUFVOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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Q0EsWUFBWSwyQ0FBMkM7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEUsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SDtBQUM5SCx1Q0FBdUM7QUFDdkMsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSwwQ0FBMEM7QUFDMUMseURBQXlELGdCQUFnQjtBQUN6RSx5QkFBeUI7QUFDekIsMENBQTBDLFVBQVU7QUFDcEQseURBQXlELFlBQVksTUFBTSxjQUFjO0FBQ3pGO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtS0FBbUssc0JBQXNCO0FBQ3pMLG9LQUFvSyxzQkFBc0I7QUFDMUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxpRUFBZSxFQUFFLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqYm9CO0FBQ1Q7QUFDaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnREFBWTtBQUNoQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlFQUFlLEtBQUssRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25HSDtBQUNrQjtBQUNYOztBQUV6QixPQUFPLHlCQUF5QixFQUFFLDhDQUFXOztBQUU3QztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHlDQUFHOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0Msc0RBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsYUFBYTtBQUNiLGFBQWE7QUFDYixjQUFjO0FBQ2QsY0FBYzs7QUFFQztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQVM7QUFDcEIsR0FBRyxJQUFJO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLG9EQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixvQkFBb0Isb0RBQVM7QUFDN0Isb0JBQW9CLG9EQUFTO0FBQzdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsOENBQVE7QUFDL0Isd0NBQXdDLHlDQUFHO0FBQzNDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLHNCQUFzQixnREFBVTtBQUNoQyxVQUFVLFFBQVE7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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O0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtCQUErQixvREFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsd0RBQVUsRUFBRSwrREFBUyxFQUFFLG9FQUFjLEVBQUUsK0RBQVMsRUFBRSxrRUFBWTtBQUN0RSxRQUFRLHdEQUFVLEVBQUUsK0RBQVMsRUFBRSxrRUFBWTtBQUMzQyxRQUFRLHdEQUFVLEVBQUUsK0RBQVMsRUFBRSxrRUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9FQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVUsRUFBRSxrRUFBWSxFQUFFLGtFQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFlBQVk7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRUFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLElBQUk7QUFDcEU7QUFDQTtBQUNBLFlBQVksd0RBQVUsRUFBRSwrREFBUyxFQUFFLGtFQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRUFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsOERBQThELElBQUk7QUFDbEU7QUFDQTtBQUNBLFlBQVksd0RBQVUsRUFBRSwrREFBUyxFQUFFLGtFQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsOEJBQThCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBVSxFQUFFLCtEQUFTLEVBQUUsb0VBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVUsRUFBRSwrREFBUyxFQUFFLCtEQUFTLEVBQUUsbUVBQWEsRUFBRSxrRUFBWSxFQUFFLHVFQUFpQixFQUFFLDBEQUFVLEVBQUUsa0VBQVk7QUFDbEgsWUFBWSxtRUFBYTtBQUN6QixZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxZQUFZLDhEQUFnQjtBQUM1QixZQUFZLDhEQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVUsRUFBRSxvRUFBYyxFQUFFLGtFQUFZO0FBQ2hEO0FBQ0EsWUFBWSw4REFBZ0I7QUFDNUIsWUFBWSw4REFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQWdCO0FBQzVCLFlBQVksOERBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx1Q0FBdUMsZUFBZSxjQUFjLEdBQUc7O0FBRXZFO0FBQ0EsaURBQWlELGVBQWUsY0FBYyxHQUFHO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVUsRUFBRSwrREFBUyxFQUFFLG9FQUFjLEVBQUUsa0VBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFTO0FBQ3JCO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZSxFQUFFLGlCQUFpQjtBQUMvRCx3QkFBd0IseUNBQUc7QUFDM0I7QUFDQTtBQUNBLHFDQUFxQyxhQUFhLEVBQUUsV0FBVztBQUMvRDtBQUNBO0FBQ0EsNkRBQTZELGFBQWE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsYUFBYSxFQUFFLFdBQVc7QUFDL0Y7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFVLEVBQUUsK0RBQVMsRUFBRSxrRUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDLFFBQVEsOERBQWdCO0FBQ3hCLFFBQVEsOERBQWdCO0FBQ3hCO0FBQ0E7QUFDQSx3QkFBd0Isb0RBQVM7QUFDakMsOEJBQThCLG9EQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkRBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxhQUFhOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscURBQWU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFVLEVBQUUsK0RBQVMsRUFBRSwrREFBUyxFQUFFLGtFQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBUztBQUNyQiwwQkFBMEIscURBQWU7QUFDekM7QUFDQSxrQ0FBa0MscURBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscURBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFVLEVBQUUsa0VBQVksRUFBRSxrRUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVUsRUFBRSwrREFBUyxFQUFFLGdFQUFVLEVBQUUsa0VBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLG9FQUFvRSxRQUFROztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkRBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGVBQWU7QUFDekU7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBVSxFQUFFLDhEQUFRLEVBQUUsa0VBQVk7QUFDOUM7QUFDQTtBQUNBLG9CQUFvQiw4REFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZUFBZTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVUsRUFBRSwrREFBUyxFQUFFLCtEQUFTLEVBQUUsZ0VBQVUsRUFBRSxrRUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkRBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxTQUFTLHFEQUFxRCxZQUFZOztBQUVyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdFQUFrQjtBQUMxQjtBQUNBLG1EQUFtRCwwREFBYTtBQUNoRTtBQUNBO0FBQ0Esc0NBQXNDLDBEQUFhO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdFQUFrQjtBQUMxQixRQUFRLHdEQUFVLEVBQUUsa0VBQVksRUFBRSxrRUFBWTtBQUM5QyxRQUFRLHdEQUFVLEVBQUUsK0RBQVMsRUFBRSxrRUFBWTtBQUMzQyxRQUFRLHdEQUFVLEVBQUUsK0RBQVMsRUFBRSxrRUFBWTtBQUMzQyxRQUFRLHdEQUFVLEVBQUUsOERBQVEsRUFBRSxrRUFBWTtBQUMxQyxRQUFRLHdEQUFVLEVBQUUsOERBQVEsRUFBRSxrRUFBWTtBQUMxQyxRQUFRLHdEQUFVLEVBQUUsOERBQVEsRUFBRSxrRUFBWTtBQUMxQyxRQUFRLHdEQUFVLEVBQUUsK0RBQVMsRUFBRSxrRUFBWTtBQUMzQztBQUNBLG9GQUFvRixZQUFZO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxJQUFJO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFVLEVBQUUsK0RBQVMsRUFBRSxrRUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVUsRUFBRSxrRUFBWSxFQUFFLGtFQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0VBQWtCO0FBQzFCLFFBQVEsd0RBQVUsRUFBRSxnRUFBVSxFQUFFLGtFQUFZO0FBQzVDLFFBQVEsd0RBQVUsRUFBRSwrREFBUyxFQUFFLGtFQUFZO0FBQzNDLFFBQVEsd0RBQVUsRUFBRSwrREFBUyxFQUFFLGtFQUFZO0FBQzNDLFFBQVEsd0RBQVUsRUFBRSxnRUFBVSxFQUFFLGtFQUFZO0FBQzVDO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRUFBa0I7QUFDMUIsUUFBUSx3REFBVSxFQUFFLGdFQUFVLEVBQUUsa0VBQVk7QUFDNUMsUUFBUSx3REFBVSxFQUFFLGtFQUFZLEVBQUUsa0VBQVk7QUFDOUMsUUFBUSx3REFBVSxFQUFFLCtEQUFTLEVBQUUsK0RBQVMsRUFBRSw4REFBUSxFQUFFLGtFQUFZO0FBQ2hFLFFBQVEsd0RBQVUsRUFBRSwrREFBUyxFQUFFLCtEQUFTLEVBQUUsOERBQVEsRUFBRSxrRUFBWTtBQUNoRSxRQUFRLHdEQUFVLEVBQUUsK0RBQVMsRUFBRSwrREFBUyxFQUFFLDhEQUFRLEVBQUUsa0VBQVk7QUFDaEUsUUFBUSx3REFBVSxFQUFFLCtEQUFTLEVBQUUsa0VBQVk7QUFDM0MsUUFBUSx3REFBVSxFQUFFLCtEQUFTLEVBQUUsK0RBQVMsRUFBRSw4REFBUSxFQUFFLGtFQUFZO0FBQ2hFLFFBQVEsd0RBQVUsRUFBRSw4REFBUSxFQUFFLGtFQUFZO0FBQzFDLFFBQVEsd0RBQVUsRUFBRSwrREFBUyxFQUFFLGtFQUFZO0FBQzNDLFFBQVEsd0RBQVUsRUFBRSwrREFBUyxFQUFFLCtEQUFTLEVBQUUsa0VBQVk7QUFDdEQsUUFBUSx3REFBVSxFQUFFLCtEQUFTLEVBQUUsa0VBQVk7QUFDM0MsUUFBUSx3REFBVSxFQUFFLCtEQUFTLEVBQUUsa0VBQVk7QUFDM0MsUUFBUSx3REFBVSxFQUFFLCtEQUFTLEVBQUUsa0VBQVk7QUFDM0MsUUFBUSx3REFBVSxFQUFFLGdFQUFVLEVBQUUsa0VBQVk7QUFDNUMsUUFBUSx3REFBVSxFQUFFLCtEQUFTLEVBQUUsa0VBQVk7QUFDM0MsUUFBUSx3REFBVSxFQUFFLCtEQUFTLEVBQUUsa0VBQVk7QUFDM0MsUUFBUSx3REFBVSxFQUFFLCtEQUFTLEVBQUUsK0RBQVMsRUFBRSw4REFBUSxFQUFFLGtF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ZSw0QkFBNEIsaURBQWdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQ0FBRztBQUM3QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQWU7QUFDOUI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9kZWNvbXByZXNzLXJlc3BvbnNlL2luZGV4LmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9kZWNvbXByZXNzLXJlc3BvbnNlL25vZGVfbW9kdWxlcy9taW1pYy1yZXNwb25zZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvZGVmZXItdG8tY29ubmVjdC9kaXN0L3NvdXJjZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvZ2V0LXN0cmVhbS9idWZmZXItc3RyZWFtLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9nZXQtc3RyZWFtL2luZGV4LmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9odHRwLWNhY2hlLXNlbWFudGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvaHR0cDItd3JhcHBlci9zb3VyY2UvYWdlbnQuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL2F1dG8uanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL2NsaWVudC1yZXF1ZXN0LmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9odHRwMi13cmFwcGVyL3NvdXJjZS9pbmNvbWluZy1tZXNzYWdlLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9odHRwMi13cmFwcGVyL3NvdXJjZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvaHR0cDItd3JhcHBlci9zb3VyY2UvcHJveGllcy9nZXQtYXV0aC1oZWFkZXJzLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9odHRwMi13cmFwcGVyL3NvdXJjZS9wcm94aWVzL2gxLW92ZXItaDIuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL3Byb3hpZXMvaDItb3Zlci1oMS5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvaHR0cDItd3JhcHBlci9zb3VyY2UvcHJveGllcy9oMi1vdmVyLWgyLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9odHRwMi13cmFwcGVyL3NvdXJjZS9wcm94aWVzL2gyLW92ZXItaHguanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL3Byb3hpZXMvaW5pdGlhbGl6ZS5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvaHR0cDItd3JhcHBlci9zb3VyY2UvcHJveGllcy91bmV4cGVjdGVkLXN0YXR1cy1jb2RlLWVycm9yLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9odHRwMi13cmFwcGVyL3NvdXJjZS91dGlscy9jYWxjdWxhdGUtc2VydmVyLW5hbWUuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL3V0aWxzL2NoZWNrLXR5cGUuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL3V0aWxzL2RlbGF5LWFzeW5jLWRlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL3V0aWxzL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvaHR0cDItd3JhcHBlci9zb3VyY2UvdXRpbHMvaXMtcmVxdWVzdC1wc2V1ZG8taGVhZGVyLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9odHRwMi13cmFwcGVyL3NvdXJjZS91dGlscy9qcy1zdHJlYW0tc29ja2V0LmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9odHRwMi13cmFwcGVyL3NvdXJjZS91dGlscy9wcm94eS1ldmVudHMuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL3V0aWxzL3Byb3h5LXNvY2tldC1oYW5kbGVyLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9odHRwMi13cmFwcGVyL3NvdXJjZS91dGlscy92YWxpZGF0ZS1oZWFkZXItbmFtZS5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvaHR0cDItd3JhcHBlci9zb3VyY2UvdXRpbHMvdmFsaWRhdGUtaGVhZGVyLXZhbHVlLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9qc29uLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMva2V5di9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS1hbHBuL2luZGV4LmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9Ac2luZHJlc29yaHVzL2lzL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL0Bzem1hcmN6YWsvaHR0cC10aW1lci9kaXN0L3NvdXJjZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvY2FjaGVhYmxlLWxvb2t1cC9zb3VyY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2NhY2hlYWJsZS1yZXF1ZXN0L2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2NhY2hlYWJsZS1yZXF1ZXN0L2Rpc3QvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2Zvcm0tZGF0YS1lbmNvZGVyL2xpYi9Gb3JtRGF0YUVuY29kZXIuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2Zvcm0tZGF0YS1lbmNvZGVyL2xpYi91dGlsL2NyZWF0ZUJvdW5kYXJ5LmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEtZW5jb2Rlci9saWIvdXRpbC9lc2NhcGVOYW1lLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEtZW5jb2Rlci9saWIvdXRpbC9nZXRTdHJlYW1JdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhLWVuY29kZXIvbGliL3V0aWwvaXNGaWxlLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEtZW5jb2Rlci9saWIvdXRpbC9pc0Zvcm1EYXRhLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEtZW5jb2Rlci9saWIvdXRpbC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEtZW5jb2Rlci9saWIvdXRpbC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEtZW5jb2Rlci9saWIvdXRpbC9ub3JtYWxpemVWYWx1ZS5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhLWVuY29kZXIvbGliL3V0aWwvcHJveHlIZWFkZXJzLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9nb3QvZGlzdC9zb3VyY2UvYXMtcHJvbWlzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2FzLXByb21pc2UvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL2NhbGN1bGF0ZS1yZXRyeS1kZWxheS5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2NvcmUvZXJyb3JzLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9nb3QvZGlzdC9zb3VyY2UvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2NvcmUvb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2NvcmUvcGFyc2UtbGluay1oZWFkZXIuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3Jlc3BvbnNlLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9nb3QvZGlzdC9zb3VyY2UvY29yZS90aW1lZC1vdXQuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL2dldC1ib2R5LXNpemUuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL2lzLWNsaWVudC1yZXF1ZXN0LmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9nb3QvZGlzdC9zb3VyY2UvY29yZS91dGlscy9pcy1mb3JtLWRhdGEuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL2lzLXVuaXgtc29ja2V0LXVybC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2NvcmUvdXRpbHMvcHJveHktZXZlbnRzLmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9nb3QvZGlzdC9zb3VyY2UvY29yZS91dGlscy91bmhhbmRsZS5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2NvcmUvdXRpbHMvdXJsLXRvLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL3dlYWthYmxlLW1hcC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2luZGV4LmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy9sb3dlcmNhc2Uta2V5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvbWltaWMtcmVzcG9uc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS11cmwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbXlzdGlxdWUtY2xpLy4vbm9kZV9tb2R1bGVzL3AtY2FuY2VsYWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvcmVzcG9uc2VsaWtlL2luZGV4LmpzIiwid2VicGFjazovL215c3RpcXVlLWNsaS8uL25vZGVfbW9kdWxlcy93ZWJkcml2ZXIvYnVpbGQvcmVxdWVzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9teXN0aXF1ZS1jbGkvLi9ub2RlX21vZHVsZXMvd2ViZHJpdmVyL2J1aWxkL3JlcXVlc3Qvbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCB7VHJhbnNmb3JtLCBQYXNzVGhyb3VnaH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5jb25zdCBtaW1pY1Jlc3BvbnNlID0gcmVxdWlyZSgnbWltaWMtcmVzcG9uc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXNwb25zZSA9PiB7XG5cdGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IChyZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10gfHwgJycpLnRvTG93ZXJDYXNlKCk7XG5cblx0aWYgKCFbJ2d6aXAnLCAnZGVmbGF0ZScsICdiciddLmluY2x1ZGVzKGNvbnRlbnRFbmNvZGluZykpIHtcblx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdH1cblxuXHQvLyBUT0RPOiBSZW1vdmUgdGhpcyB3aGVuIHRhcmdldGluZyBOb2RlLmpzIDEyLlxuXHRjb25zdCBpc0Jyb3RsaSA9IGNvbnRlbnRFbmNvZGluZyA9PT0gJ2JyJztcblx0aWYgKGlzQnJvdGxpICYmIHR5cGVvZiB6bGliLmNyZWF0ZUJyb3RsaURlY29tcHJlc3MgIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXNwb25zZS5kZXN0cm95KG5ldyBFcnJvcignQnJvdGxpIGlzIG5vdCBzdXBwb3J0ZWQgb24gTm9kZS5qcyA8IDEyJykpO1xuXHRcdHJldHVybiByZXNwb25zZTtcblx0fVxuXG5cdGxldCBpc0VtcHR5ID0gdHJ1ZTtcblxuXHRjb25zdCBjaGVja2VyID0gbmV3IFRyYW5zZm9ybSh7XG5cdFx0dHJhbnNmb3JtKGRhdGEsIF9lbmNvZGluZywgY2FsbGJhY2spIHtcblx0XHRcdGlzRW1wdHkgPSBmYWxzZTtcblxuXHRcdFx0Y2FsbGJhY2sobnVsbCwgZGF0YSk7XG5cdFx0fSxcblxuXHRcdGZsdXNoKGNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH1cblx0fSk7XG5cblx0Y29uc3QgZmluYWxTdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goe1xuXHRcdGF1dG9EZXN0cm95OiBmYWxzZSxcblx0XHRkZXN0cm95KGVycm9yLCBjYWxsYmFjaykge1xuXHRcdFx0cmVzcG9uc2UuZGVzdHJveSgpO1xuXG5cdFx0XHRjYWxsYmFjayhlcnJvcik7XG5cdFx0fVxuXHR9KTtcblxuXHRjb25zdCBkZWNvbXByZXNzU3RyZWFtID0gaXNCcm90bGkgPyB6bGliLmNyZWF0ZUJyb3RsaURlY29tcHJlc3MoKSA6IHpsaWIuY3JlYXRlVW56aXAoKTtcblxuXHRkZWNvbXByZXNzU3RyZWFtLm9uY2UoJ2Vycm9yJywgZXJyb3IgPT4ge1xuXHRcdGlmIChpc0VtcHR5ICYmICFyZXNwb25zZS5yZWFkYWJsZSkge1xuXHRcdFx0ZmluYWxTdHJlYW0uZW5kKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZmluYWxTdHJlYW0uZGVzdHJveShlcnJvcik7XG5cdH0pO1xuXG5cdG1pbWljUmVzcG9uc2UocmVzcG9uc2UsIGZpbmFsU3RyZWFtKTtcblx0cmVzcG9uc2UucGlwZShjaGVja2VyKS5waXBlKGRlY29tcHJlc3NTdHJlYW0pLnBpcGUoZmluYWxTdHJlYW0pO1xuXG5cdHJldHVybiBmaW5hbFN0cmVhbTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFdlIGRlZmluZSB0aGVzZSBtYW51YWxseSB0byBlbnN1cmUgdGhleSdyZSBhbHdheXMgY29waWVkXG4vLyBldmVuIGlmIHRoZXkgd291bGQgbW92ZSB1cCB0aGUgcHJvdG90eXBlIGNoYWluXG4vLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX2NsYXNzX2h0dHBfaW5jb21pbmdtZXNzYWdlXG5jb25zdCBrbm93blByb3BlcnRpZXMgPSBbXG5cdCdhYm9ydGVkJyxcblx0J2NvbXBsZXRlJyxcblx0J2hlYWRlcnMnLFxuXHQnaHR0cFZlcnNpb24nLFxuXHQnaHR0cFZlcnNpb25NaW5vcicsXG5cdCdodHRwVmVyc2lvbk1ham9yJyxcblx0J21ldGhvZCcsXG5cdCdyYXdIZWFkZXJzJyxcblx0J3Jhd1RyYWlsZXJzJyxcblx0J3NldFRpbWVvdXQnLFxuXHQnc29ja2V0Jyxcblx0J3N0YXR1c0NvZGUnLFxuXHQnc3RhdHVzTWVzc2FnZScsXG5cdCd0cmFpbGVycycsXG5cdCd1cmwnXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmcm9tU3RyZWFtLCB0b1N0cmVhbSkgPT4ge1xuXHRpZiAodG9TdHJlYW0uX3JlYWRhYmxlU3RhdGUuYXV0b0Rlc3Ryb3kpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZWNvbmQgc3RyZWFtIG11c3QgaGF2ZSB0aGUgYGF1dG9EZXN0cm95YCBvcHRpb24gc2V0IHRvIGBmYWxzZWAnKTtcblx0fVxuXG5cdGNvbnN0IGZyb21Qcm9wZXJ0aWVzID0gbmV3IFNldChPYmplY3Qua2V5cyhmcm9tU3RyZWFtKS5jb25jYXQoa25vd25Qcm9wZXJ0aWVzKSk7XG5cblx0Y29uc3QgcHJvcGVydGllcyA9IHt9O1xuXG5cdGZvciAoY29uc3QgcHJvcGVydHkgb2YgZnJvbVByb3BlcnRpZXMpIHtcblx0XHQvLyBEb24ndCBvdmVyd3JpdGUgZXhpc3RpbmcgcHJvcGVydGllcy5cblx0XHRpZiAocHJvcGVydHkgaW4gdG9TdHJlYW0pIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHByb3BlcnRpZXNbcHJvcGVydHldID0ge1xuXHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGZyb21TdHJlYW1bcHJvcGVydHldO1xuXHRcdFx0XHRjb25zdCBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG5cdFx0XHRcdHJldHVybiBpc0Z1bmN0aW9uID8gdmFsdWUuYmluZChmcm9tU3RyZWFtKSA6IHZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHNldCh2YWx1ZSkge1xuXHRcdFx0XHRmcm9tU3RyZWFtW3Byb3BlcnR5XSA9IHZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlXG5cdFx0fTtcblx0fVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRvU3RyZWFtLCBwcm9wZXJ0aWVzKTtcblxuXHRmcm9tU3RyZWFtLm9uY2UoJ2Fib3J0ZWQnLCAoKSA9PiB7XG5cdFx0dG9TdHJlYW0uZGVzdHJveSgpO1xuXG5cdFx0dG9TdHJlYW0uZW1pdCgnYWJvcnRlZCcpO1xuXHR9KTtcblxuXHRmcm9tU3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuXHRcdGlmIChmcm9tU3RyZWFtLmNvbXBsZXRlKSB7XG5cdFx0XHRpZiAodG9TdHJlYW0ucmVhZGFibGUpIHtcblx0XHRcdFx0dG9TdHJlYW0ub25jZSgnZW5kJywgKCkgPT4ge1xuXHRcdFx0XHRcdHRvU3RyZWFtLmVtaXQoJ2Nsb3NlJyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG9TdHJlYW0uZW1pdCgnY2xvc2UnKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9TdHJlYW0uZW1pdCgnY2xvc2UnKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiB0b1N0cmVhbTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGlzVExTU29ja2V0KHNvY2tldCkge1xuICAgIHJldHVybiBzb2NrZXQuZW5jcnlwdGVkO1xufVxuY29uc3QgZGVmZXJUb0Nvbm5lY3QgPSAoc29ja2V0LCBmbikgPT4ge1xuICAgIGxldCBsaXN0ZW5lcnM7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBjb25uZWN0ID0gZm47XG4gICAgICAgIGxpc3RlbmVycyA9IHsgY29ubmVjdCB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGlzdGVuZXJzID0gZm47XG4gICAgfVxuICAgIGNvbnN0IGhhc0Nvbm5lY3RMaXN0ZW5lciA9IHR5cGVvZiBsaXN0ZW5lcnMuY29ubmVjdCA9PT0gJ2Z1bmN0aW9uJztcbiAgICBjb25zdCBoYXNTZWN1cmVDb25uZWN0TGlzdGVuZXIgPSB0eXBlb2YgbGlzdGVuZXJzLnNlY3VyZUNvbm5lY3QgPT09ICdmdW5jdGlvbic7XG4gICAgY29uc3QgaGFzQ2xvc2VMaXN0ZW5lciA9IHR5cGVvZiBsaXN0ZW5lcnMuY2xvc2UgPT09ICdmdW5jdGlvbic7XG4gICAgY29uc3Qgb25Db25uZWN0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoaGFzQ29ubmVjdExpc3RlbmVyKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RMU1NvY2tldChzb2NrZXQpICYmIGhhc1NlY3VyZUNvbm5lY3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKHNvY2tldC5hdXRob3JpemVkKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNlY3VyZUNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFzb2NrZXQuYXV0aG9yaXphdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0Lm9uY2UoJ3NlY3VyZUNvbm5lY3QnLCBsaXN0ZW5lcnMuc2VjdXJlQ29ubmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Nsb3NlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHNvY2tldC5vbmNlKCdjbG9zZScsIGxpc3RlbmVycy5jbG9zZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChzb2NrZXQud3JpdGFibGUgJiYgIXNvY2tldC5jb25uZWN0aW5nKSB7XG4gICAgICAgIG9uQ29ubmVjdCgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzb2NrZXQuY29ubmVjdGluZykge1xuICAgICAgICBzb2NrZXQub25jZSgnY29ubmVjdCcsIG9uQ29ubmVjdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNvY2tldC5kZXN0cm95ZWQgJiYgaGFzQ2xvc2VMaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcnMuY2xvc2Uoc29ja2V0Ll9oYWRFcnJvcik7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmVyVG9Db25uZWN0O1xuLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcbm1vZHVsZS5leHBvcnRzID0gZGVmZXJUb0Nvbm5lY3Q7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZGVmZXJUb0Nvbm5lY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCB7UGFzc1Rocm91Z2g6IFBhc3NUaHJvdWdoU3RyZWFtfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9wdGlvbnMgPT4ge1xuXHRvcHRpb25zID0gey4uLm9wdGlvbnN9O1xuXG5cdGNvbnN0IHthcnJheX0gPSBvcHRpb25zO1xuXHRsZXQge2VuY29kaW5nfSA9IG9wdGlvbnM7XG5cdGNvbnN0IGlzQnVmZmVyID0gZW5jb2RpbmcgPT09ICdidWZmZXInO1xuXHRsZXQgb2JqZWN0TW9kZSA9IGZhbHNlO1xuXG5cdGlmIChhcnJheSkge1xuXHRcdG9iamVjdE1vZGUgPSAhKGVuY29kaW5nIHx8IGlzQnVmZmVyKTtcblx0fSBlbHNlIHtcblx0XHRlbmNvZGluZyA9IGVuY29kaW5nIHx8ICd1dGY4Jztcblx0fVxuXG5cdGlmIChpc0J1ZmZlcikge1xuXHRcdGVuY29kaW5nID0gbnVsbDtcblx0fVxuXG5cdGNvbnN0IHN0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaFN0cmVhbSh7b2JqZWN0TW9kZX0pO1xuXG5cdGlmIChlbmNvZGluZykge1xuXHRcdHN0cmVhbS5zZXRFbmNvZGluZyhlbmNvZGluZyk7XG5cdH1cblxuXHRsZXQgbGVuZ3RoID0gMDtcblx0Y29uc3QgY2h1bmtzID0gW107XG5cblx0c3RyZWFtLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuXHRcdGNodW5rcy5wdXNoKGNodW5rKTtcblxuXHRcdGlmIChvYmplY3RNb2RlKSB7XG5cdFx0XHRsZW5ndGggPSBjaHVua3MubGVuZ3RoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuXHRcdH1cblx0fSk7XG5cblx0c3RyZWFtLmdldEJ1ZmZlcmVkVmFsdWUgPSAoKSA9PiB7XG5cdFx0aWYgKGFycmF5KSB7XG5cdFx0XHRyZXR1cm4gY2h1bmtzO1xuXHRcdH1cblxuXHRcdHJldHVybiBpc0J1ZmZlciA/IEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBsZW5ndGgpIDogY2h1bmtzLmpvaW4oJycpO1xuXHR9O1xuXG5cdHN0cmVhbS5nZXRCdWZmZXJlZExlbmd0aCA9ICgpID0+IGxlbmd0aDtcblxuXHRyZXR1cm4gc3RyZWFtO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHtjb25zdGFudHM6IEJ1ZmZlckNvbnN0YW50c30gPSByZXF1aXJlKCdidWZmZXInKTtcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3Qge3Byb21pc2lmeX0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBidWZmZXJTdHJlYW0gPSByZXF1aXJlKCcuL2J1ZmZlci1zdHJlYW0nKTtcblxuY29uc3Qgc3RyZWFtUGlwZWxpbmVQcm9taXNpZmllZCA9IHByb21pc2lmeShzdHJlYW0ucGlwZWxpbmUpO1xuXG5jbGFzcyBNYXhCdWZmZXJFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoJ21heEJ1ZmZlciBleGNlZWRlZCcpO1xuXHRcdHRoaXMubmFtZSA9ICdNYXhCdWZmZXJFcnJvcic7XG5cdH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U3RyZWFtKGlucHV0U3RyZWFtLCBvcHRpb25zKSB7XG5cdGlmICghaW5wdXRTdHJlYW0pIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc3RyZWFtJyk7XG5cdH1cblxuXHRvcHRpb25zID0ge1xuXHRcdG1heEJ1ZmZlcjogSW5maW5pdHksXG5cdFx0Li4ub3B0aW9uc1xuXHR9O1xuXG5cdGNvbnN0IHttYXhCdWZmZXJ9ID0gb3B0aW9ucztcblx0Y29uc3Qgc3RyZWFtID0gYnVmZmVyU3RyZWFtKG9wdGlvbnMpO1xuXG5cdGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRjb25zdCByZWplY3RQcm9taXNlID0gZXJyb3IgPT4ge1xuXHRcdFx0Ly8gRG9uJ3QgcmV0cmlldmUgYW4gb3ZlcnNpemVkIGJ1ZmZlci5cblx0XHRcdGlmIChlcnJvciAmJiBzdHJlYW0uZ2V0QnVmZmVyZWRMZW5ndGgoKSA8PSBCdWZmZXJDb25zdGFudHMuTUFYX0xFTkdUSCkge1xuXHRcdFx0XHRlcnJvci5idWZmZXJlZERhdGEgPSBzdHJlYW0uZ2V0QnVmZmVyZWRWYWx1ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdH07XG5cblx0XHQoYXN5bmMgKCkgPT4ge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YXdhaXQgc3RyZWFtUGlwZWxpbmVQcm9taXNpZmllZChpbnB1dFN0cmVhbSwgc3RyZWFtKTtcblx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0cmVqZWN0UHJvbWlzZShlcnJvcik7XG5cdFx0XHR9XG5cdFx0fSkoKTtcblxuXHRcdHN0cmVhbS5vbignZGF0YScsICgpID0+IHtcblx0XHRcdGlmIChzdHJlYW0uZ2V0QnVmZmVyZWRMZW5ndGgoKSA+IG1heEJ1ZmZlcikge1xuXHRcdFx0XHRyZWplY3RQcm9taXNlKG5ldyBNYXhCdWZmZXJFcnJvcigpKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cblx0cmV0dXJuIHN0cmVhbS5nZXRCdWZmZXJlZFZhbHVlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3RyZWFtO1xubW9kdWxlLmV4cG9ydHMuYnVmZmVyID0gKHN0cmVhbSwgb3B0aW9ucykgPT4gZ2V0U3RyZWFtKHN0cmVhbSwgey4uLm9wdGlvbnMsIGVuY29kaW5nOiAnYnVmZmVyJ30pO1xubW9kdWxlLmV4cG9ydHMuYXJyYXkgPSAoc3RyZWFtLCBvcHRpb25zKSA9PiBnZXRTdHJlYW0oc3RyZWFtLCB7Li4ub3B0aW9ucywgYXJyYXk6IHRydWV9KTtcbm1vZHVsZS5leHBvcnRzLk1heEJ1ZmZlckVycm9yID0gTWF4QnVmZmVyRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG4vLyByZmM3MjMxIDYuMVxuY29uc3Qgc3RhdHVzQ29kZUNhY2hlYWJsZUJ5RGVmYXVsdCA9IG5ldyBTZXQoW1xuICAgIDIwMCxcbiAgICAyMDMsXG4gICAgMjA0LFxuICAgIDIwNixcbiAgICAzMDAsXG4gICAgMzAxLFxuICAgIDMwOCxcbiAgICA0MDQsXG4gICAgNDA1LFxuICAgIDQxMCxcbiAgICA0MTQsXG4gICAgNTAxLFxuXSk7XG5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgdW5kZXJzdGFuZCBwYXJ0aWFsIHJlc3BvbnNlcyAoMjA2KVxuY29uc3QgdW5kZXJzdG9vZFN0YXR1c2VzID0gbmV3IFNldChbXG4gICAgMjAwLFxuICAgIDIwMyxcbiAgICAyMDQsXG4gICAgMzAwLFxuICAgIDMwMSxcbiAgICAzMDIsXG4gICAgMzAzLFxuICAgIDMwNyxcbiAgICAzMDgsXG4gICAgNDA0LFxuICAgIDQwNSxcbiAgICA0MTAsXG4gICAgNDE0LFxuICAgIDUwMSxcbl0pO1xuXG5jb25zdCBlcnJvclN0YXR1c0NvZGVzID0gbmV3IFNldChbXG4gICAgNTAwLFxuICAgIDUwMixcbiAgICA1MDMsIFxuICAgIDUwNCxcbl0pO1xuXG5jb25zdCBob3BCeUhvcEhlYWRlcnMgPSB7XG4gICAgZGF0ZTogdHJ1ZSwgLy8gaW5jbHVkZWQsIGJlY2F1c2Ugd2UgYWRkIEFnZSB1cGRhdGUgRGF0ZVxuICAgIGNvbm5lY3Rpb246IHRydWUsXG4gICAgJ2tlZXAtYWxpdmUnOiB0cnVlLFxuICAgICdwcm94eS1hdXRoZW50aWNhdGUnOiB0cnVlLFxuICAgICdwcm94eS1hdXRob3JpemF0aW9uJzogdHJ1ZSxcbiAgICB0ZTogdHJ1ZSxcbiAgICB0cmFpbGVyOiB0cnVlLFxuICAgICd0cmFuc2Zlci1lbmNvZGluZyc6IHRydWUsXG4gICAgdXBncmFkZTogdHJ1ZSxcbn07XG5cbmNvbnN0IGV4Y2x1ZGVkRnJvbVJldmFsaWRhdGlvblVwZGF0ZSA9IHtcbiAgICAvLyBTaW5jZSB0aGUgb2xkIGJvZHkgaXMgcmV1c2VkLCBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gY2hhbmdlIHByb3BlcnRpZXMgb2YgdGhlIGJvZHlcbiAgICAnY29udGVudC1sZW5ndGgnOiB0cnVlLFxuICAgICdjb250ZW50LWVuY29kaW5nJzogdHJ1ZSxcbiAgICAndHJhbnNmZXItZW5jb2RpbmcnOiB0cnVlLFxuICAgICdjb250ZW50LXJhbmdlJzogdHJ1ZSxcbn07XG5cbmZ1bmN0aW9uIHRvTnVtYmVyT3JaZXJvKHMpIHtcbiAgICBjb25zdCBuID0gcGFyc2VJbnQocywgMTApO1xuICAgIHJldHVybiBpc0Zpbml0ZShuKSA/IG4gOiAwO1xufVxuXG4vLyBSRkMgNTg2MVxuZnVuY3Rpb24gaXNFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgLy8gY29uc2lkZXIgdW5kZWZpbmVkIHJlc3BvbnNlIGFzIGZhdWx0eVxuICAgIGlmKCFyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JTdGF0dXNDb2Rlcy5oYXMocmVzcG9uc2Uuc3RhdHVzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDYWNoZUNvbnRyb2woaGVhZGVyKSB7XG4gICAgY29uc3QgY2MgPSB7fTtcbiAgICBpZiAoIWhlYWRlcikgcmV0dXJuIGNjO1xuXG4gICAgLy8gVE9ETzogV2hlbiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHZhbHVlIHByZXNlbnQgZm9yIGEgZ2l2ZW4gZGlyZWN0aXZlIChlLmcuLCB0d28gRXhwaXJlcyBoZWFkZXIgZmllbGRzLCBtdWx0aXBsZSBDYWNoZS1Db250cm9sOiBtYXgtYWdlIGRpcmVjdGl2ZXMpLFxuICAgIC8vIHRoZSBkaXJlY3RpdmUncyB2YWx1ZSBpcyBjb25zaWRlcmVkIGludmFsaWQuIENhY2hlcyBhcmUgZW5jb3VyYWdlZCB0byBjb25zaWRlciByZXNwb25zZXMgdGhhdCBoYXZlIGludmFsaWQgZnJlc2huZXNzIGluZm9ybWF0aW9uIHRvIGJlIHN0YWxlXG4gICAgY29uc3QgcGFydHMgPSBoZWFkZXIudHJpbSgpLnNwbGl0KC8sLyk7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgIGNvbnN0IFtrLCB2XSA9IHBhcnQuc3BsaXQoLz0vLCAyKTtcbiAgICAgICAgY2Nbay50cmltKCldID0gdiA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHYudHJpbSgpLnJlcGxhY2UoL15cInxcIiQvZywgJycpO1xuICAgIH1cblxuICAgIHJldHVybiBjYztcbn1cblxuZnVuY3Rpb24gZm9ybWF0Q2FjaGVDb250cm9sKGNjKSB7XG4gICAgbGV0IHBhcnRzID0gW107XG4gICAgZm9yIChjb25zdCBrIGluIGNjKSB7XG4gICAgICAgIGNvbnN0IHYgPSBjY1trXTtcbiAgICAgICAgcGFydHMucHVzaCh2ID09PSB0cnVlID8gayA6IGsgKyAnPScgKyB2KTtcbiAgICB9XG4gICAgaWYgKCFwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ2FjaGVQb2xpY3kge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICByZXEsXG4gICAgICAgIHJlcyxcbiAgICAgICAge1xuICAgICAgICAgICAgc2hhcmVkLFxuICAgICAgICAgICAgY2FjaGVIZXVyaXN0aWMsXG4gICAgICAgICAgICBpbW11dGFibGVNaW5UaW1lVG9MaXZlLFxuICAgICAgICAgICAgaWdub3JlQ2FyZ29DdWx0LFxuICAgICAgICAgICAgX2Zyb21PYmplY3QsXG4gICAgICAgIH0gPSB7fVxuICAgICkge1xuICAgICAgICBpZiAoX2Zyb21PYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zyb21PYmplY3QoX2Zyb21PYmplY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXMgfHwgIXJlcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUmVzcG9uc2UgaGVhZGVycyBtaXNzaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVxdWVzdEhhc0hlYWRlcnMocmVxKTtcblxuICAgICAgICB0aGlzLl9yZXNwb25zZVRpbWUgPSB0aGlzLm5vdygpO1xuICAgICAgICB0aGlzLl9pc1NoYXJlZCA9IHNoYXJlZCAhPT0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NhY2hlSGV1cmlzdGljID1cbiAgICAgICAgICAgIHVuZGVmaW5lZCAhPT0gY2FjaGVIZXVyaXN0aWMgPyBjYWNoZUhldXJpc3RpYyA6IDAuMTsgLy8gMTAlIG1hdGNoZXMgSUVcbiAgICAgICAgdGhpcy5faW1tdXRhYmxlTWluVHRsID1cbiAgICAgICAgICAgIHVuZGVmaW5lZCAhPT0gaW1tdXRhYmxlTWluVGltZVRvTGl2ZVxuICAgICAgICAgICAgICAgID8gaW1tdXRhYmxlTWluVGltZVRvTGl2ZVxuICAgICAgICAgICAgICAgIDogMjQgKiAzNjAwICogMTAwMDtcblxuICAgICAgICB0aGlzLl9zdGF0dXMgPSAnc3RhdHVzJyBpbiByZXMgPyByZXMuc3RhdHVzIDogMjAwO1xuICAgICAgICB0aGlzLl9yZXNIZWFkZXJzID0gcmVzLmhlYWRlcnM7XG4gICAgICAgIHRoaXMuX3Jlc2NjID0gcGFyc2VDYWNoZUNvbnRyb2wocmVzLmhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSk7XG4gICAgICAgIHRoaXMuX21ldGhvZCA9ICdtZXRob2QnIGluIHJlcSA/IHJlcS5tZXRob2QgOiAnR0VUJztcbiAgICAgICAgdGhpcy5fdXJsID0gcmVxLnVybDtcbiAgICAgICAgdGhpcy5faG9zdCA9IHJlcS5oZWFkZXJzLmhvc3Q7XG4gICAgICAgIHRoaXMuX25vQXV0aG9yaXphdGlvbiA9ICFyZXEuaGVhZGVycy5hdXRob3JpemF0aW9uO1xuICAgICAgICB0aGlzLl9yZXFIZWFkZXJzID0gcmVzLmhlYWRlcnMudmFyeSA/IHJlcS5oZWFkZXJzIDogbnVsbDsgLy8gRG9uJ3Qga2VlcCBhbGwgcmVxdWVzdCBoZWFkZXJzIGlmIHRoZXkgd29uJ3QgYmUgdXNlZFxuICAgICAgICB0aGlzLl9yZXFjYyA9IHBhcnNlQ2FjaGVDb250cm9sKHJlcS5oZWFkZXJzWydjYWNoZS1jb250cm9sJ10pO1xuXG4gICAgICAgIC8vIEFzc3VtZSB0aGF0IGlmIHNvbWVvbmUgdXNlcyBsZWdhY3ksIG5vbi1zdGFuZGFyZCB1bmNlY2Vzc2FyeSBvcHRpb25zIHRoZXkgZG9uJ3QgdW5kZXJzdGFuZCBjYWNoaW5nLFxuICAgICAgICAvLyBzbyB0aGVyZSdzIG5vIHBvaW50IHN0cmljbHkgYWRoZXJpbmcgdG8gdGhlIGJsaW5kbHkgY29weSZwYXN0ZWQgZGlyZWN0aXZlcy5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaWdub3JlQ2FyZ29DdWx0ICYmXG4gICAgICAgICAgICAncHJlLWNoZWNrJyBpbiB0aGlzLl9yZXNjYyAmJlxuICAgICAgICAgICAgJ3Bvc3QtY2hlY2snIGluIHRoaXMuX3Jlc2NjXG4gICAgICAgICkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc2NjWydwcmUtY2hlY2snXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZXNjY1sncG9zdC1jaGVjayddO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc2NjWyduby1jYWNoZSddO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc2NjWyduby1zdG9yZSddO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc2NjWydtdXN0LXJldmFsaWRhdGUnXTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc0hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yZXNIZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgJ2NhY2hlLWNvbnRyb2wnOiBmb3JtYXRDYWNoZUNvbnRyb2wodGhpcy5fcmVzY2MpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcmVzSGVhZGVycy5leHBpcmVzO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc0hlYWRlcnMucHJhZ21hO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2hlbiB0aGUgQ2FjaGUtQ29udHJvbCBoZWFkZXIgZmllbGQgaXMgbm90IHByZXNlbnQgaW4gYSByZXF1ZXN0LCBjYWNoZXMgTVVTVCBjb25zaWRlciB0aGUgbm8tY2FjaGUgcmVxdWVzdCBwcmFnbWEtZGlyZWN0aXZlXG4gICAgICAgIC8vIGFzIGhhdmluZyB0aGUgc2FtZSBlZmZlY3QgYXMgaWYgXCJDYWNoZS1Db250cm9sOiBuby1jYWNoZVwiIHdlcmUgcHJlc2VudCAoc2VlIFNlY3Rpb24gNS4yLjEpLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICByZXMuaGVhZGVyc1snY2FjaGUtY29udHJvbCddID09IG51bGwgJiZcbiAgICAgICAgICAgIC9uby1jYWNoZS8udGVzdChyZXMuaGVhZGVycy5wcmFnbWEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5fcmVzY2NbJ25vLWNhY2hlJ10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbm93KCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICBzdG9yYWJsZSgpIHtcbiAgICAgICAgLy8gVGhlIFwibm8tc3RvcmVcIiByZXF1ZXN0IGRpcmVjdGl2ZSBpbmRpY2F0ZXMgdGhhdCBhIGNhY2hlIE1VU1QgTk9UIHN0b3JlIGFueSBwYXJ0IG9mIGVpdGhlciB0aGlzIHJlcXVlc3Qgb3IgYW55IHJlc3BvbnNlIHRvIGl0LlxuICAgICAgICByZXR1cm4gISEoXG4gICAgICAgICAgICAhdGhpcy5fcmVxY2NbJ25vLXN0b3JlJ10gJiZcbiAgICAgICAgICAgIC8vIEEgY2FjaGUgTVVTVCBOT1Qgc3RvcmUgYSByZXNwb25zZSB0byBhbnkgcmVxdWVzdCwgdW5sZXNzOlxuICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgbWV0aG9kIGlzIHVuZGVyc3Rvb2QgYnkgdGhlIGNhY2hlIGFuZCBkZWZpbmVkIGFzIGJlaW5nIGNhY2hlYWJsZSwgYW5kXG4gICAgICAgICAgICAoJ0dFVCcgPT09IHRoaXMuX21ldGhvZCB8fFxuICAgICAgICAgICAgICAgICdIRUFEJyA9PT0gdGhpcy5fbWV0aG9kIHx8XG4gICAgICAgICAgICAgICAgKCdQT1NUJyA9PT0gdGhpcy5fbWV0aG9kICYmIHRoaXMuX2hhc0V4cGxpY2l0RXhwaXJhdGlvbigpKSkgJiZcbiAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSBzdGF0dXMgY29kZSBpcyB1bmRlcnN0b29kIGJ5IHRoZSBjYWNoZSwgYW5kXG4gICAgICAgICAgICB1bmRlcnN0b29kU3RhdHVzZXMuaGFzKHRoaXMuX3N0YXR1cykgJiZcbiAgICAgICAgICAgIC8vIHRoZSBcIm5vLXN0b3JlXCIgY2FjaGUgZGlyZWN0aXZlIGRvZXMgbm90IGFwcGVhciBpbiByZXF1ZXN0IG9yIHJlc3BvbnNlIGhlYWRlciBmaWVsZHMsIGFuZFxuICAgICAgICAgICAgIXRoaXMuX3Jlc2NjWyduby1zdG9yZSddICYmXG4gICAgICAgICAgICAvLyB0aGUgXCJwcml2YXRlXCIgcmVzcG9uc2UgZGlyZWN0aXZlIGRvZXMgbm90IGFwcGVhciBpbiB0aGUgcmVzcG9uc2UsIGlmIHRoZSBjYWNoZSBpcyBzaGFyZWQsIGFuZFxuICAgICAgICAgICAgKCF0aGlzLl9pc1NoYXJlZCB8fCAhdGhpcy5fcmVzY2MucHJpdmF0ZSkgJiZcbiAgICAgICAgICAgIC8vIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlciBmaWVsZCBkb2VzIG5vdCBhcHBlYXIgaW4gdGhlIHJlcXVlc3QsIGlmIHRoZSBjYWNoZSBpcyBzaGFyZWQsXG4gICAgICAgICAgICAoIXRoaXMuX2lzU2hhcmVkIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9BdXRob3JpemF0aW9uIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsb3dzU3RvcmluZ0F1dGhlbnRpY2F0ZWQoKSkgJiZcbiAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSBlaXRoZXI6XG4gICAgICAgICAgICAvLyBjb250YWlucyBhbiBFeHBpcmVzIGhlYWRlciBmaWVsZCwgb3JcbiAgICAgICAgICAgICh0aGlzLl9yZXNIZWFkZXJzLmV4cGlyZXMgfHxcbiAgICAgICAgICAgICAgICAvLyBjb250YWlucyBhIG1heC1hZ2UgcmVzcG9uc2UgZGlyZWN0aXZlLCBvclxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIGEgcy1tYXhhZ2UgcmVzcG9uc2UgZGlyZWN0aXZlIGFuZCB0aGUgY2FjaGUgaXMgc2hhcmVkLCBvclxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIGEgcHVibGljIHJlc3BvbnNlIGRpcmVjdGl2ZS5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNjY1snbWF4LWFnZSddIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuX2lzU2hhcmVkICYmIHRoaXMuX3Jlc2NjWydzLW1heGFnZSddKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2NjLnB1YmxpYyB8fFxuICAgICAgICAgICAgICAgIC8vIGhhcyBhIHN0YXR1cyBjb2RlIHRoYXQgaXMgZGVmaW5lZCBhcyBjYWNoZWFibGUgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGVDYWNoZWFibGVCeURlZmF1bHQuaGFzKHRoaXMuX3N0YXR1cykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgX2hhc0V4cGxpY2l0RXhwaXJhdGlvbigpIHtcbiAgICAgICAgLy8gNC4yLjEgQ2FsY3VsYXRpbmcgRnJlc2huZXNzIExpZmV0aW1lXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAodGhpcy5faXNTaGFyZWQgJiYgdGhpcy5fcmVzY2NbJ3MtbWF4YWdlJ10pIHx8XG4gICAgICAgICAgICB0aGlzLl9yZXNjY1snbWF4LWFnZSddIHx8XG4gICAgICAgICAgICB0aGlzLl9yZXNIZWFkZXJzLmV4cGlyZXNcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBfYXNzZXJ0UmVxdWVzdEhhc0hlYWRlcnMocmVxKSB7XG4gICAgICAgIGlmICghcmVxIHx8ICFyZXEuaGVhZGVycykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlcXVlc3QgaGVhZGVycyBtaXNzaW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzYXRpc2ZpZXNXaXRob3V0UmV2YWxpZGF0aW9uKHJlcSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZXF1ZXN0SGFzSGVhZGVycyhyZXEpO1xuXG4gICAgICAgIC8vIFdoZW4gcHJlc2VudGVkIHdpdGggYSByZXF1ZXN0LCBhIGNhY2hlIE1VU1QgTk9UIHJldXNlIGEgc3RvcmVkIHJlc3BvbnNlLCB1bmxlc3M6XG4gICAgICAgIC8vIHRoZSBwcmVzZW50ZWQgcmVxdWVzdCBkb2VzIG5vdCBjb250YWluIHRoZSBuby1jYWNoZSBwcmFnbWEgKFNlY3Rpb24gNS40KSwgbm9yIHRoZSBuby1jYWNoZSBjYWNoZSBkaXJlY3RpdmUsXG4gICAgICAgIC8vIHVubGVzcyB0aGUgc3RvcmVkIHJlc3BvbnNlIGlzIHN1Y2Nlc3NmdWxseSB2YWxpZGF0ZWQgKFNlY3Rpb24gNC4zKSwgYW5kXG4gICAgICAgIGNvbnN0IHJlcXVlc3RDQyA9IHBhcnNlQ2FjaGVDb250cm9sKHJlcS5oZWFkZXJzWydjYWNoZS1jb250cm9sJ10pO1xuICAgICAgICBpZiAocmVxdWVzdENDWyduby1jYWNoZSddIHx8IC9uby1jYWNoZS8udGVzdChyZXEuaGVhZGVycy5wcmFnbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWVzdENDWydtYXgtYWdlJ10gJiYgdGhpcy5hZ2UoKSA+IHJlcXVlc3RDQ1snbWF4LWFnZSddKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICByZXF1ZXN0Q0NbJ21pbi1mcmVzaCddICYmXG4gICAgICAgICAgICB0aGlzLnRpbWVUb0xpdmUoKSA8IDEwMDAgKiByZXF1ZXN0Q0NbJ21pbi1mcmVzaCddXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIHN0b3JlZCByZXNwb25zZSBpcyBlaXRoZXI6XG4gICAgICAgIC8vIGZyZXNoLCBvciBhbGxvd2VkIHRvIGJlIHNlcnZlZCBzdGFsZVxuICAgICAgICBpZiAodGhpcy5zdGFsZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBhbGxvd3NTdGFsZSA9XG4gICAgICAgICAgICAgICAgcmVxdWVzdENDWydtYXgtc3RhbGUnXSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLl9yZXNjY1snbXVzdC1yZXZhbGlkYXRlJ10gJiZcbiAgICAgICAgICAgICAgICAodHJ1ZSA9PT0gcmVxdWVzdENDWydtYXgtc3RhbGUnXSB8fFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Q0NbJ21heC1zdGFsZSddID4gdGhpcy5hZ2UoKSAtIHRoaXMubWF4QWdlKCkpO1xuICAgICAgICAgICAgaWYgKCFhbGxvd3NTdGFsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0TWF0Y2hlcyhyZXEsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBfcmVxdWVzdE1hdGNoZXMocmVxLCBhbGxvd0hlYWRNZXRob2QpIHtcbiAgICAgICAgLy8gVGhlIHByZXNlbnRlZCBlZmZlY3RpdmUgcmVxdWVzdCBVUkkgYW5kIHRoYXQgb2YgdGhlIHN0b3JlZCByZXNwb25zZSBtYXRjaCwgYW5kXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoIXRoaXMuX3VybCB8fCB0aGlzLl91cmwgPT09IHJlcS51cmwpICYmXG4gICAgICAgICAgICB0aGlzLl9ob3N0ID09PSByZXEuaGVhZGVycy5ob3N0ICYmXG4gICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBtZXRob2QgYXNzb2NpYXRlZCB3aXRoIHRoZSBzdG9yZWQgcmVzcG9uc2UgYWxsb3dzIGl0IHRvIGJlIHVzZWQgZm9yIHRoZSBwcmVzZW50ZWQgcmVxdWVzdCwgYW5kXG4gICAgICAgICAgICAoIXJlcS5tZXRob2QgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXRob2QgPT09IHJlcS5tZXRob2QgfHxcbiAgICAgICAgICAgICAgICAoYWxsb3dIZWFkTWV0aG9kICYmICdIRUFEJyA9PT0gcmVxLm1ldGhvZCkpICYmXG4gICAgICAgICAgICAvLyBzZWxlY3RpbmcgaGVhZGVyIGZpZWxkcyBub21pbmF0ZWQgYnkgdGhlIHN0b3JlZCByZXNwb25zZSAoaWYgYW55KSBtYXRjaCB0aG9zZSBwcmVzZW50ZWQsIGFuZFxuICAgICAgICAgICAgdGhpcy5fdmFyeU1hdGNoZXMocmVxKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIF9hbGxvd3NTdG9yaW5nQXV0aGVudGljYXRlZCgpIHtcbiAgICAgICAgLy8gIGZvbGxvd2luZyBDYWNoZS1Db250cm9sIHJlc3BvbnNlIGRpcmVjdGl2ZXMgKFNlY3Rpb24gNS4yLjIpIGhhdmUgc3VjaCBhbiBlZmZlY3Q6IG11c3QtcmV2YWxpZGF0ZSwgcHVibGljLCBhbmQgcy1tYXhhZ2UuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9yZXNjY1snbXVzdC1yZXZhbGlkYXRlJ10gfHxcbiAgICAgICAgICAgIHRoaXMuX3Jlc2NjLnB1YmxpYyB8fFxuICAgICAgICAgICAgdGhpcy5fcmVzY2NbJ3MtbWF4YWdlJ11cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBfdmFyeU1hdGNoZXMocmVxKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVzSGVhZGVycy52YXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEEgVmFyeSBoZWFkZXIgZmllbGQtdmFsdWUgb2YgXCIqXCIgYWx3YXlzIGZhaWxzIHRvIG1hdGNoXG4gICAgICAgIGlmICh0aGlzLl9yZXNIZWFkZXJzLnZhcnkgPT09ICcqJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fcmVzSGVhZGVycy52YXJ5XG4gICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKHJlcS5oZWFkZXJzW25hbWVdICE9PSB0aGlzLl9yZXFIZWFkZXJzW25hbWVdKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgX2NvcHlXaXRob3V0SG9wQnlIb3BIZWFkZXJzKGluSGVhZGVycykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBpbkhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChob3BCeUhvcEhlYWRlcnNbbmFtZV0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgaGVhZGVyc1tuYW1lXSA9IGluSGVhZGVyc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICAvLyA5LjEuICBDb25uZWN0aW9uXG4gICAgICAgIGlmIChpbkhlYWRlcnMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gaW5IZWFkZXJzLmNvbm5lY3Rpb24udHJpbSgpLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVycy53YXJuaW5nKSB7XG4gICAgICAgICAgICBjb25zdCB3YXJuaW5ncyA9IGhlYWRlcnMud2FybmluZy5zcGxpdCgvLC8pLmZpbHRlcih3YXJuaW5nID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIS9eXFxzKjFbMC05XVswLTldLy50ZXN0KHdhcm5pbmcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXdhcm5pbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzLndhcm5pbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMud2FybmluZyA9IHdhcm5pbmdzLmpvaW4oJywnKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgcmVzcG9uc2VIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5fY29weVdpdGhvdXRIb3BCeUhvcEhlYWRlcnModGhpcy5fcmVzSGVhZGVycyk7XG4gICAgICAgIGNvbnN0IGFnZSA9IHRoaXMuYWdlKCk7XG5cbiAgICAgICAgLy8gQSBjYWNoZSBTSE9VTEQgZ2VuZXJhdGUgMTEzIHdhcm5pbmcgaWYgaXQgaGV1cmlzdGljYWxseSBjaG9zZSBhIGZyZXNobmVzc1xuICAgICAgICAvLyBsaWZldGltZSBncmVhdGVyIHRoYW4gMjQgaG91cnMgYW5kIHRoZSByZXNwb25zZSdzIGFnZSBpcyBncmVhdGVyIHRoYW4gMjQgaG91cnMuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGFnZSA+IDM2MDAgKiAyNCAmJlxuICAgICAgICAgICAgIXRoaXMuX2hhc0V4cGxpY2l0RXhwaXJhdGlvbigpICYmXG4gICAgICAgICAgICB0aGlzLm1heEFnZSgpID4gMzYwMCAqIDI0XG4gICAgICAgICkge1xuICAgICAgICAgICAgaGVhZGVycy53YXJuaW5nID1cbiAgICAgICAgICAgICAgICAoaGVhZGVycy53YXJuaW5nID8gYCR7aGVhZGVycy53YXJuaW5nfSwgYCA6ICcnKSArXG4gICAgICAgICAgICAgICAgJzExMyAtIFwicmZjNzIzNCA1LjUuNFwiJztcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzLmFnZSA9IGAke01hdGgucm91bmQoYWdlKX1gO1xuICAgICAgICBoZWFkZXJzLmRhdGUgPSBuZXcgRGF0ZSh0aGlzLm5vdygpKS50b1VUQ1N0cmluZygpO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBvZiB0aGUgRGF0ZSByZXNwb25zZSBoZWFkZXIgb3IgY3VycmVudCB0aW1lIGlmIERhdGUgd2FzIGludmFsaWRcbiAgICAgKiBAcmV0dXJuIHRpbWVzdGFtcFxuICAgICAqL1xuICAgIGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHNlcnZlckRhdGUgPSBEYXRlLnBhcnNlKHRoaXMuX3Jlc0hlYWRlcnMuZGF0ZSk7XG4gICAgICAgIGlmIChpc0Zpbml0ZShzZXJ2ZXJEYXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZlckRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlVGltZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBvZiB0aGUgQWdlIGhlYWRlciwgaW4gc2Vjb25kcywgdXBkYXRlZCBmb3IgdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgKiBNYXkgYmUgZnJhY3Rpb25hbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gTnVtYmVyXG4gICAgICovXG4gICAgYWdlKCkge1xuICAgICAgICBsZXQgYWdlID0gdGhpcy5fYWdlVmFsdWUoKTtcblxuICAgICAgICBjb25zdCByZXNpZGVudFRpbWUgPSAodGhpcy5ub3coKSAtIHRoaXMuX3Jlc3BvbnNlVGltZSkgLyAxMDAwO1xuICAgICAgICByZXR1cm4gYWdlICsgcmVzaWRlbnRUaW1lO1xuICAgIH1cblxuICAgIF9hZ2VWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRvTnVtYmVyT3JaZXJvKHRoaXMuX3Jlc0hlYWRlcnMuYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBvZiBhcHBsaWNhYmxlIG1heC1hZ2UgKG9yIGhldXJpc3RpYyBlcXVpdmFsZW50KSBpbiBzZWNvbmRzLiBUaGlzIGNvdW50cyBzaW5jZSByZXNwb25zZSdzIGBEYXRlYC5cbiAgICAgKlxuICAgICAqIEZvciBhbiB1cC10by1kYXRlIHZhbHVlLCBzZWUgYHRpbWVUb0xpdmUoKWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIE51bWJlclxuICAgICAqL1xuICAgIG1heEFnZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0b3JhYmxlKCkgfHwgdGhpcy5fcmVzY2NbJ25vLWNhY2hlJ10pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hhcmVkIHJlc3BvbnNlcyB3aXRoIGNvb2tpZXMgYXJlIGNhY2hlYWJsZSBhY2NvcmRpbmcgdG8gdGhlIFJGQywgYnV0IElNSE8gaXQnZCBiZSB1bndpc2UgdG8gZG8gc28gYnkgZGVmYXVsdFxuICAgICAgICAvLyBzbyB0aGlzIGltcGxlbWVudGF0aW9uIHJlcXVpcmVzIGV4cGxpY2l0IG9wdC1pbiB2aWEgcHVibGljIGhlYWRlclxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLl9pc1NoYXJlZCAmJlxuICAgICAgICAgICAgKHRoaXMuX3Jlc0hlYWRlcnNbJ3NldC1jb29raWUnXSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLl9yZXNjYy5wdWJsaWMgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5fcmVzY2MuaW1tdXRhYmxlKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3Jlc0hlYWRlcnMudmFyeSA9PT0gJyonKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pc1NoYXJlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2NjWydwcm94eS1yZXZhbGlkYXRlJ10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGEgcmVzcG9uc2UgaW5jbHVkZXMgdGhlIHMtbWF4YWdlIGRpcmVjdGl2ZSwgYSBzaGFyZWQgY2FjaGUgcmVjaXBpZW50IE1VU1QgaWdub3JlIHRoZSBFeHBpcmVzIGZpZWxkLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2NjWydzLW1heGFnZSddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvTnVtYmVyT3JaZXJvKHRoaXMuX3Jlc2NjWydzLW1heGFnZSddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgcmVzcG9uc2UgaW5jbHVkZXMgYSBDYWNoZS1Db250cm9sIGZpZWxkIHdpdGggdGhlIG1heC1hZ2UgZGlyZWN0aXZlLCBhIHJlY2lwaWVudCBNVVNUIGlnbm9yZSB0aGUgRXhwaXJlcyBmaWVsZC5cbiAgICAgICAgaWYgKHRoaXMuX3Jlc2NjWydtYXgtYWdlJ10pIHtcbiAgICAgICAgICAgIHJldHVybiB0b051bWJlck9yWmVybyh0aGlzLl9yZXNjY1snbWF4LWFnZSddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlZmF1bHRNaW5UdGwgPSB0aGlzLl9yZXNjYy5pbW11dGFibGUgPyB0aGlzLl9pbW11dGFibGVNaW5UdGwgOiAwO1xuXG4gICAgICAgIGNvbnN0IHNlcnZlckRhdGUgPSB0aGlzLmRhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc0hlYWRlcnMuZXhwaXJlcykge1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlcyA9IERhdGUucGFyc2UodGhpcy5fcmVzSGVhZGVycy5leHBpcmVzKTtcbiAgICAgICAgICAgIC8vIEEgY2FjaGUgcmVjaXBpZW50IE1VU1QgaW50ZXJwcmV0IGludmFsaWQgZGF0ZSBmb3JtYXRzLCBlc3BlY2lhbGx5IHRoZSB2YWx1ZSBcIjBcIiwgYXMgcmVwcmVzZW50aW5nIGEgdGltZSBpbiB0aGUgcGFzdCAoaS5lLiwgXCJhbHJlYWR5IGV4cGlyZWRcIikuXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGV4cGlyZXMpIHx8IGV4cGlyZXMgPCBzZXJ2ZXJEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoZGVmYXVsdE1pblR0bCwgKGV4cGlyZXMgLSBzZXJ2ZXJEYXRlKSAvIDEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3Jlc0hlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdE1vZGlmaWVkID0gRGF0ZS5wYXJzZSh0aGlzLl9yZXNIZWFkZXJzWydsYXN0LW1vZGlmaWVkJ10pO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGxhc3RNb2RpZmllZCkgJiYgc2VydmVyRGF0ZSA+IGxhc3RNb2RpZmllZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE1pblR0bCxcbiAgICAgICAgICAgICAgICAgICAgKChzZXJ2ZXJEYXRlIC0gbGFzdE1vZGlmaWVkKSAvIDEwMDApICogdGhpcy5fY2FjaGVIZXVyaXN0aWNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRNaW5UdGw7XG4gICAgfVxuXG4gICAgdGltZVRvTGl2ZSgpIHtcbiAgICAgICAgY29uc3QgYWdlID0gdGhpcy5tYXhBZ2UoKSAtIHRoaXMuYWdlKCk7XG4gICAgICAgIGNvbnN0IHN0YWxlSWZFcnJvckFnZSA9IGFnZSArIHRvTnVtYmVyT3JaZXJvKHRoaXMuX3Jlc2NjWydzdGFsZS1pZi1lcnJvciddKTtcbiAgICAgICAgY29uc3Qgc3RhbGVXaGlsZVJldmFsaWRhdGVBZ2UgPSBhZ2UgKyB0b051bWJlck9yWmVybyh0aGlzLl9yZXNjY1snc3RhbGUtd2hpbGUtcmV2YWxpZGF0ZSddKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGFnZSwgc3RhbGVJZkVycm9yQWdlLCBzdGFsZVdoaWxlUmV2YWxpZGF0ZUFnZSkgKiAxMDAwO1xuICAgIH1cblxuICAgIHN0YWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhBZ2UoKSA8PSB0aGlzLmFnZSgpO1xuICAgIH1cblxuICAgIF91c2VTdGFsZUlmRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heEFnZSgpICsgdG9OdW1iZXJPclplcm8odGhpcy5fcmVzY2NbJ3N0YWxlLWlmLWVycm9yJ10pID4gdGhpcy5hZ2UoKTtcbiAgICB9XG5cbiAgICB1c2VTdGFsZVdoaWxlUmV2YWxpZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4QWdlKCkgKyB0b051bWJlck9yWmVybyh0aGlzLl9yZXNjY1snc3RhbGUtd2hpbGUtcmV2YWxpZGF0ZSddKSA+IHRoaXMuYWdlKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21PYmplY3Qob2JqKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBfZnJvbU9iamVjdDogb2JqIH0pO1xuICAgIH1cblxuICAgIF9mcm9tT2JqZWN0KG9iaikge1xuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2VUaW1lKSB0aHJvdyBFcnJvcignUmVpbml0aWFsaXplZCcpO1xuICAgICAgICBpZiAoIW9iaiB8fCBvYmoudiAhPT0gMSkgdGhyb3cgRXJyb3IoJ0ludmFsaWQgc2VyaWFsaXphdGlvbicpO1xuXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlVGltZSA9IG9iai50O1xuICAgICAgICB0aGlzLl9pc1NoYXJlZCA9IG9iai5zaDtcbiAgICAgICAgdGhpcy5fY2FjaGVIZXVyaXN0aWMgPSBvYmouY2g7XG4gICAgICAgIHRoaXMuX2ltbXV0YWJsZU1pblR0bCA9XG4gICAgICAgICAgICBvYmouaW1tICE9PSB1bmRlZmluZWQgPyBvYmouaW1tIDogMjQgKiAzNjAwICogMTAwMDtcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gb2JqLnN0O1xuICAgICAgICB0aGlzLl9yZXNIZWFkZXJzID0gb2JqLnJlc2g7XG4gICAgICAgIHRoaXMuX3Jlc2NjID0gb2JqLnJlc2NjO1xuICAgICAgICB0aGlzLl9tZXRob2QgPSBvYmoubTtcbiAgICAgICAgdGhpcy5fdXJsID0gb2JqLnU7XG4gICAgICAgIHRoaXMuX2hvc3QgPSBvYmouaDtcbiAgICAgICAgdGhpcy5fbm9BdXRob3JpemF0aW9uID0gb2JqLmE7XG4gICAgICAgIHRoaXMuX3JlcUhlYWRlcnMgPSBvYmoucmVxaDtcbiAgICAgICAgdGhpcy5fcmVxY2MgPSBvYmoucmVxY2M7XG4gICAgfVxuXG4gICAgdG9PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2OiAxLFxuICAgICAgICAgICAgdDogdGhpcy5fcmVzcG9uc2VUaW1lLFxuICAgICAgICAgICAgc2g6IHRoaXMuX2lzU2hhcmVkLFxuICAgICAgICAgICAgY2g6IHRoaXMuX2NhY2hlSGV1cmlzdGljLFxuICAgICAgICAgICAgaW1tOiB0aGlzLl9pbW11dGFibGVNaW5UdGwsXG4gICAgICAgICAgICBzdDogdGhpcy5fc3RhdHVzLFxuICAgICAgICAgICAgcmVzaDogdGhpcy5fcmVzSGVhZGVycyxcbiAgICAgICAgICAgIHJlc2NjOiB0aGlzLl9yZXNjYyxcbiAgICAgICAgICAgIG06IHRoaXMuX21ldGhvZCxcbiAgICAgICAgICAgIHU6IHRoaXMuX3VybCxcbiAgICAgICAgICAgIGg6IHRoaXMuX2hvc3QsXG4gICAgICAgICAgICBhOiB0aGlzLl9ub0F1dGhvcml6YXRpb24sXG4gICAgICAgICAgICByZXFoOiB0aGlzLl9yZXFIZWFkZXJzLFxuICAgICAgICAgICAgcmVxY2M6IHRoaXMuX3JlcWNjLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlYWRlcnMgZm9yIHNlbmRpbmcgdG8gdGhlIG9yaWdpbiBzZXJ2ZXIgdG8gcmV2YWxpZGF0ZSBzdGFsZSByZXNwb25zZS5cbiAgICAgKiBBbGxvd3Mgc2VydmVyIHRvIHJldHVybiAzMDQgdG8gYWxsb3cgcmV1c2Ugb2YgdGhlIHByZXZpb3VzIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogSG9wIGJ5IGhvcCBoZWFkZXJzIGFyZSBhbHdheXMgc3RyaXBwZWQuXG4gICAgICogUmV2YWxpZGF0aW9uIGhlYWRlcnMgbWF5IGJlIGFkZGVkIG9yIHJlbW92ZWQsIGRlcGVuZGluZyBvbiByZXF1ZXN0LlxuICAgICAqL1xuICAgIHJldmFsaWRhdGlvbkhlYWRlcnMoaW5jb21pbmdSZXEpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVxdWVzdEhhc0hlYWRlcnMoaW5jb21pbmdSZXEpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5fY29weVdpdGhvdXRIb3BCeUhvcEhlYWRlcnMoaW5jb21pbmdSZXEuaGVhZGVycyk7XG5cbiAgICAgICAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCB1bmRlcnN0YW5kIHJhbmdlIHJlcXVlc3RzXG4gICAgICAgIGRlbGV0ZSBoZWFkZXJzWydpZi1yYW5nZSddO1xuXG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdE1hdGNoZXMoaW5jb21pbmdSZXEsIHRydWUpIHx8ICF0aGlzLnN0b3JhYmxlKCkpIHtcbiAgICAgICAgICAgIC8vIHJldmFsaWRhdGlvbiBhbGxvd2VkIHZpYSBIRUFEXG4gICAgICAgICAgICAvLyBub3QgZm9yIHRoZSBzYW1lIHJlc291cmNlLCBvciB3YXNuJ3QgYWxsb3dlZCB0byBiZSBjYWNoZWQgYW55d2F5XG4gICAgICAgICAgICBkZWxldGUgaGVhZGVyc1snaWYtbm9uZS1tYXRjaCddO1xuICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNbJ2lmLW1vZGlmaWVkLXNpbmNlJ107XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIE1VU1Qgc2VuZCB0aGF0IGVudGl0eS10YWcgaW4gYW55IGNhY2hlIHZhbGlkYXRpb24gcmVxdWVzdCAodXNpbmcgSWYtTWF0Y2ggb3IgSWYtTm9uZS1NYXRjaCkgaWYgYW4gZW50aXR5LXRhZyBoYXMgYmVlbiBwcm92aWRlZCBieSB0aGUgb3JpZ2luIHNlcnZlci4gKi9cbiAgICAgICAgaWYgKHRoaXMuX3Jlc0hlYWRlcnMuZXRhZykge1xuICAgICAgICAgICAgaGVhZGVyc1snaWYtbm9uZS1tYXRjaCddID0gaGVhZGVyc1snaWYtbm9uZS1tYXRjaCddXG4gICAgICAgICAgICAgICAgPyBgJHtoZWFkZXJzWydpZi1ub25lLW1hdGNoJ119LCAke3RoaXMuX3Jlc0hlYWRlcnMuZXRhZ31gXG4gICAgICAgICAgICAgICAgOiB0aGlzLl9yZXNIZWFkZXJzLmV0YWc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGllbnRzIE1BWSBpc3N1ZSBzaW1wbGUgKG5vbi1zdWJyYW5nZSkgR0VUIHJlcXVlc3RzIHdpdGggZWl0aGVyIHdlYWsgdmFsaWRhdG9ycyBvciBzdHJvbmcgdmFsaWRhdG9ycy4gQ2xpZW50cyBNVVNUIE5PVCB1c2Ugd2VhayB2YWxpZGF0b3JzIGluIG90aGVyIGZvcm1zIG9mIHJlcXVlc3QuXG4gICAgICAgIGNvbnN0IGZvcmJpZHNXZWFrVmFsaWRhdG9ycyA9XG4gICAgICAgICAgICBoZWFkZXJzWydhY2NlcHQtcmFuZ2VzJ10gfHxcbiAgICAgICAgICAgIGhlYWRlcnNbJ2lmLW1hdGNoJ10gfHxcbiAgICAgICAgICAgIGhlYWRlcnNbJ2lmLXVubW9kaWZpZWQtc2luY2UnXSB8fFxuICAgICAgICAgICAgKHRoaXMuX21ldGhvZCAmJiB0aGlzLl9tZXRob2QgIT0gJ0dFVCcpO1xuXG4gICAgICAgIC8qIFNIT1VMRCBzZW5kIHRoZSBMYXN0LU1vZGlmaWVkIHZhbHVlIGluIG5vbi1zdWJyYW5nZSBjYWNoZSB2YWxpZGF0aW9uIHJlcXVlc3RzICh1c2luZyBJZi1Nb2RpZmllZC1TaW5jZSkgaWYgb25seSBhIExhc3QtTW9kaWZpZWQgdmFsdWUgaGFzIGJlZW4gcHJvdmlkZWQgYnkgdGhlIG9yaWdpbiBzZXJ2ZXIuXG4gICAgICAgIE5vdGU6IFRoaXMgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgdW5kZXJzdGFuZCBwYXJ0aWFsIHJlc3BvbnNlcyAoMjA2KSAqL1xuICAgICAgICBpZiAoZm9yYmlkc1dlYWtWYWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBkZWxldGUgaGVhZGVyc1snaWYtbW9kaWZpZWQtc2luY2UnXTtcblxuICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ2lmLW5vbmUtbWF0Y2gnXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV0YWdzID0gaGVhZGVyc1snaWYtbm9uZS1tYXRjaCddXG4gICAgICAgICAgICAgICAgICAgIC5zcGxpdCgvLC8pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZXRhZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIS9eXFxzKldcXC8vLnRlc3QoZXRhZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghZXRhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snaWYtbm9uZS1tYXRjaCddID0gZXRhZ3Muam9pbignLCcpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICB0aGlzLl9yZXNIZWFkZXJzWydsYXN0LW1vZGlmaWVkJ10gJiZcbiAgICAgICAgICAgICFoZWFkZXJzWydpZi1tb2RpZmllZC1zaW5jZSddXG4gICAgICAgICkge1xuICAgICAgICAgICAgaGVhZGVyc1snaWYtbW9kaWZpZWQtc2luY2UnXSA9IHRoaXMuX3Jlc0hlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IENhY2hlUG9saWN5IHdpdGggaW5mb3JtYXRpb24gY29tYmluZWQgZnJvbSB0aGUgcHJldmlld3MgcmVzcG9uc2UsXG4gICAgICogYW5kIHRoZSBuZXcgcmV2YWxpZGF0aW9uIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogUmV0dXJucyB7cG9saWN5LCBtb2RpZmllZH0gd2hlcmUgbW9kaWZpZWQgaXMgYSBib29sZWFuIGluZGljYXRpbmdcbiAgICAgKiB3aGV0aGVyIHRoZSByZXNwb25zZSBib2R5IGhhcyBiZWVuIG1vZGlmaWVkLCBhbmQgb2xkIGNhY2hlZCBib2R5IGNhbid0IGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHtwb2xpY3k6IENhY2hlUG9saWN5LCBtb2RpZmllZDogQm9vbGVhbn1cbiAgICAgKi9cbiAgICByZXZhbGlkYXRlZFBvbGljeShyZXF1ZXN0LCByZXNwb25zZSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZXF1ZXN0SGFzSGVhZGVycyhyZXF1ZXN0KTtcbiAgICAgICAgaWYodGhpcy5fdXNlU3RhbGVJZkVycm9yKCkgJiYgaXNFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSkgeyAgLy8gSSBjb25zaWRlciB0aGUgcmV2YWxpZGF0aW9uIHJlcXVlc3QgdW5zdWNjZXNzZnVsXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1hdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgcG9saWN5OiB0aGlzLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1Jlc3BvbnNlIGhlYWRlcnMgbWlzc2luZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlc2UgYXJlbid0IGdvaW5nIHRvIGJlIHN1cHBvcnRlZCBleGFjdGx5LCBzaW5jZSBvbmUgQ2FjaGVQb2xpY3kgb2JqZWN0XG4gICAgICAgIC8vIGRvZXNuJ3Qga25vdyBhYm91dCBhbGwgdGhlIG90aGVyIGNhY2hlZCBvYmplY3RzLlxuICAgICAgICBsZXQgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSB1bmRlZmluZWQgJiYgcmVzcG9uc2Uuc3RhdHVzICE9IDMwNCkge1xuICAgICAgICAgICAgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5ldGFnICYmXG4gICAgICAgICAgICAhL15cXHMqV1xcLy8udGVzdChyZXNwb25zZS5oZWFkZXJzLmV0YWcpXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gXCJBbGwgb2YgdGhlIHN0b3JlZCByZXNwb25zZXMgd2l0aCB0aGUgc2FtZSBzdHJvbmcgdmFsaWRhdG9yIGFyZSBzZWxlY3RlZC5cbiAgICAgICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIHN0b3JlZCByZXNwb25zZXMgY29udGFpbiB0aGUgc2FtZSBzdHJvbmcgdmFsaWRhdG9yLFxuICAgICAgICAgICAgLy8gdGhlbiB0aGUgY2FjaGUgTVVTVCBOT1QgdXNlIHRoZSBuZXcgcmVzcG9uc2UgdG8gdXBkYXRlIGFueSBzdG9yZWQgcmVzcG9uc2VzLlwiXG4gICAgICAgICAgICBtYXRjaGVzID1cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNIZWFkZXJzLmV0YWcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNIZWFkZXJzLmV0YWcucmVwbGFjZSgvXlxccypXXFwvLywgJycpID09PVxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLmV0YWc7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fcmVzSGVhZGVycy5ldGFnICYmIHJlc3BvbnNlLmhlYWRlcnMuZXRhZykge1xuICAgICAgICAgICAgLy8gXCJJZiB0aGUgbmV3IHJlc3BvbnNlIGNvbnRhaW5zIGEgd2VhayB2YWxpZGF0b3IgYW5kIHRoYXQgdmFsaWRhdG9yIGNvcnJlc3BvbmRzXG4gICAgICAgICAgICAvLyB0byBvbmUgb2YgdGhlIGNhY2hlJ3Mgc3RvcmVkIHJlc3BvbnNlcyxcbiAgICAgICAgICAgIC8vIHRoZW4gdGhlIG1vc3QgcmVjZW50IG9mIHRob3NlIG1hdGNoaW5nIHN0b3JlZCByZXNwb25zZXMgaXMgc2VsZWN0ZWQgZm9yIHVwZGF0ZS5cIlxuICAgICAgICAgICAgbWF0Y2hlcyA9XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzSGVhZGVycy5ldGFnLnJlcGxhY2UoL15cXHMqV1xcLy8sICcnKSA9PT1cbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLmV0YWcucmVwbGFjZSgvXlxccypXXFwvLywgJycpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3Jlc0hlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXSkge1xuICAgICAgICAgICAgbWF0Y2hlcyA9XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzSGVhZGVyc1snbGFzdC1tb2RpZmllZCddID09PVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXcgcmVzcG9uc2UgZG9lcyBub3QgaW5jbHVkZSBhbnkgZm9ybSBvZiB2YWxpZGF0b3IgKHN1Y2ggYXMgaW4gdGhlIGNhc2Ugd2hlcmVcbiAgICAgICAgICAgIC8vIGEgY2xpZW50IGdlbmVyYXRlcyBhbiBJZi1Nb2RpZmllZC1TaW5jZSByZXF1ZXN0IGZyb20gYSBzb3VyY2Ugb3RoZXIgdGhhbiB0aGUgTGFzdC1Nb2RpZmllZFxuICAgICAgICAgICAgLy8gcmVzcG9uc2UgaGVhZGVyIGZpZWxkKSwgYW5kIHRoZXJlIGlzIG9ubHkgb25lIHN0b3JlZCByZXNwb25zZSwgYW5kIHRoYXQgc3RvcmVkIHJlc3BvbnNlIGFsc29cbiAgICAgICAgICAgIC8vIGxhY2tzIGEgdmFsaWRhdG9yLCB0aGVuIHRoYXQgc3RvcmVkIHJlc3BvbnNlIGlzIHNlbGVjdGVkIGZvciB1cGRhdGUuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXRoaXMuX3Jlc0hlYWRlcnMuZXRhZyAmJlxuICAgICAgICAgICAgICAgICF0aGlzLl9yZXNIZWFkZXJzWydsYXN0LW1vZGlmaWVkJ10gJiZcbiAgICAgICAgICAgICAgICAhcmVzcG9uc2UuaGVhZGVycy5ldGFnICYmXG4gICAgICAgICAgICAgICAgIXJlc3BvbnNlLmhlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9saWN5OiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihyZXF1ZXN0LCByZXNwb25zZSksXG4gICAgICAgICAgICAgICAgLy8gQ2xpZW50IHJlY2VpdmluZyAzMDQgd2l0aG91dCBib2R5LCBldmVuIGlmIGl0J3MgaW52YWxpZC9taXNtYXRjaGVkIGhhcyBubyBvcHRpb25cbiAgICAgICAgICAgICAgICAvLyBidXQgdG8gcmV1c2UgYSBjYWNoZWQgYm9keS4gV2UgZG9uJ3QgaGF2ZSBhIGdvb2Qgd2F5IHRvIHRlbGwgY2xpZW50cyB0byBkb1xuICAgICAgICAgICAgICAgIC8vIGVycm9yIHJlY292ZXJ5IGluIHN1Y2ggY2FzZS5cbiAgICAgICAgICAgICAgICBtb2RpZmllZDogcmVzcG9uc2Uuc3RhdHVzICE9IDMwNCxcbiAgICAgICAgICAgICAgICBtYXRjaGVzOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1c2Ugb3RoZXIgaGVhZGVyIGZpZWxkcyBwcm92aWRlZCBpbiB0aGUgMzA0IChOb3QgTW9kaWZpZWQpIHJlc3BvbnNlIHRvIHJlcGxhY2UgYWxsIGluc3RhbmNlc1xuICAgICAgICAvLyBvZiB0aGUgY29ycmVzcG9uZGluZyBoZWFkZXIgZmllbGRzIGluIHRoZSBzdG9yZWQgcmVzcG9uc2UuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrIGluIHRoaXMuX3Jlc0hlYWRlcnMpIHtcbiAgICAgICAgICAgIGhlYWRlcnNba10gPVxuICAgICAgICAgICAgICAgIGsgaW4gcmVzcG9uc2UuaGVhZGVycyAmJiAhZXhjbHVkZWRGcm9tUmV2YWxpZGF0aW9uVXBkYXRlW2tdXG4gICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2UuaGVhZGVyc1trXVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3Jlc0hlYWRlcnNba107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdSZXNwb25zZSA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbnNlLCB7XG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuX3N0YXR1cyxcbiAgICAgICAgICAgIG1ldGhvZDogdGhpcy5fbWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2xpY3k6IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHJlcXVlc3QsIG5ld1Jlc3BvbnNlLCB7XG4gICAgICAgICAgICAgICAgc2hhcmVkOiB0aGlzLl9pc1NoYXJlZCxcbiAgICAgICAgICAgICAgICBjYWNoZUhldXJpc3RpYzogdGhpcy5fY2FjaGVIZXVyaXN0aWMsXG4gICAgICAgICAgICAgICAgaW1tdXRhYmxlTWluVGltZVRvTGl2ZTogdGhpcy5faW1tdXRhYmxlTWluVHRsLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtb2RpZmllZDogZmFsc2UsXG4gICAgICAgICAgICBtYXRjaGVzOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2plc3QvaXNzdWVzLzI1NDlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL3ByZWZlci1nbG9iYWwvdXJsXG5jb25zdCB7VVJMfSA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZSgnaHR0cDInKTtcbmNvbnN0IFF1aWNrTFJVID0gcmVxdWlyZSgncXVpY2stbHJ1Jyk7XG5jb25zdCBkZWxheUFzeW5jRGVzdHJveSA9IHJlcXVpcmUoJy4vdXRpbHMvZGVsYXktYXN5bmMtZGVzdHJveS5qcycpO1xuXG5jb25zdCBrQ3VycmVudFN0cmVhbUNvdW50ID0gU3ltYm9sKCdjdXJyZW50U3RyZWFtQ291bnQnKTtcbmNvbnN0IGtSZXF1ZXN0ID0gU3ltYm9sKCdyZXF1ZXN0Jyk7XG5jb25zdCBrT3JpZ2luU2V0ID0gU3ltYm9sKCdjYWNoZWRPcmlnaW5TZXQnKTtcbmNvbnN0IGtHcmFjZWZ1bGx5Q2xvc2luZyA9IFN5bWJvbCgnZ3JhY2VmdWxseUNsb3NpbmcnKTtcbmNvbnN0IGtMZW5ndGggPSBTeW1ib2woJ2xlbmd0aCcpO1xuXG5jb25zdCBuYW1lS2V5cyA9IFtcblx0Ly8gTm90IGFuIEFnZW50IG9wdGlvbiBhY3R1YWxseVxuXHQnY3JlYXRlQ29ubmVjdGlvbicsXG5cblx0Ly8gYGh0dHAyLmNvbm5lY3QoKWAgb3B0aW9uc1xuXHQnbWF4RGVmbGF0ZUR5bmFtaWNUYWJsZVNpemUnLFxuXHQnbWF4U2V0dGluZ3MnLFxuXHQnbWF4U2Vzc2lvbk1lbW9yeScsXG5cdCdtYXhIZWFkZXJMaXN0UGFpcnMnLFxuXHQnbWF4T3V0c3RhbmRpbmdQaW5ncycsXG5cdCdtYXhSZXNlcnZlZFJlbW90ZVN0cmVhbXMnLFxuXHQnbWF4U2VuZEhlYWRlckJsb2NrTGVuZ3RoJyxcblx0J3BhZGRpbmdTdHJhdGVneScsXG5cdCdwZWVyTWF4Q29uY3VycmVudFN0cmVhbXMnLFxuXHQnc2V0dGluZ3MnLFxuXG5cdC8vIGB0bHMuY29ubmVjdCgpYCBzb3VyY2Ugb3B0aW9uc1xuXHQnZmFtaWx5Jyxcblx0J2xvY2FsQWRkcmVzcycsXG5cdCdyZWplY3RVbmF1dGhvcml6ZWQnLFxuXG5cdC8vIGB0bHMuY29ubmVjdCgpYCBzZWN1cmUgY29udGV4dCBvcHRpb25zXG5cdCdwc2tDYWxsYmFjaycsXG5cdCdtaW5ESFNpemUnLFxuXG5cdC8vIGB0bHMuY29ubmVjdCgpYCBkZXN0aW5hdGlvbiBvcHRpb25zXG5cdC8vIC0gYHNlcnZlcm5hbWVgIGlzIGF1dG9tYXRpY2FsbHkgdmFsaWRhdGVkLCBza2lwIGl0XG5cdC8vIC0gYGhvc3RgIGFuZCBgcG9ydGAganVzdCBkZXNjcmliZSB0aGUgZGVzdGluYXRpb24gc2VydmVyLFxuXHQncGF0aCcsXG5cdCdzb2NrZXQnLFxuXG5cdC8vIGB0bHMuY3JlYXRlU2VjdXJlQ29udGV4dCgpYCBvcHRpb25zXG5cdCdjYScsXG5cdCdjZXJ0Jyxcblx0J3NpZ2FsZ3MnLFxuXHQnY2lwaGVycycsXG5cdCdjbGllbnRDZXJ0RW5naW5lJyxcblx0J2NybCcsXG5cdCdkaHBhcmFtJyxcblx0J2VjZGhDdXJ2ZScsXG5cdCdob25vckNpcGhlck9yZGVyJyxcblx0J2tleScsXG5cdCdwcml2YXRlS2V5RW5naW5lJyxcblx0J3ByaXZhdGVLZXlJZGVudGlmaWVyJyxcblx0J21heFZlcnNpb24nLFxuXHQnbWluVmVyc2lvbicsXG5cdCdwZngnLFxuXHQnc2VjdXJlT3B0aW9ucycsXG5cdCdzZWN1cmVQcm90b2NvbCcsXG5cdCdzZXNzaW9uSWRDb250ZXh0Jyxcblx0J3RpY2tldEtleXMnXG5dO1xuXG5jb25zdCBnZXRTb3J0ZWRJbmRleCA9IChhcnJheSwgdmFsdWUsIGNvbXBhcmUpID0+IHtcblx0bGV0IGxvdyA9IDA7XG5cdGxldCBoaWdoID0gYXJyYXkubGVuZ3RoO1xuXG5cdHdoaWxlIChsb3cgPCBoaWdoKSB7XG5cdFx0Y29uc3QgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuXG5cdFx0aWYgKGNvbXBhcmUoYXJyYXlbbWlkXSwgdmFsdWUpKSB7XG5cdFx0XHRsb3cgPSBtaWQgKyAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWdoID0gbWlkO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBsb3c7XG59O1xuXG5jb25zdCBjb21wYXJlU2Vzc2lvbnMgPSAoYSwgYikgPT4gYS5yZW1vdGVTZXR0aW5ncy5tYXhDb25jdXJyZW50U3RyZWFtcyA+IGIucmVtb3RlU2V0dGluZ3MubWF4Q29uY3VycmVudFN0cmVhbXM7XG5cbi8vIFNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjODMzNlxuY29uc3QgY2xvc2VDb3ZlcmVkU2Vzc2lvbnMgPSAod2hlcmUsIHNlc3Npb24pID0+IHtcblx0Ly8gQ2xpZW50cyBTSE9VTEQgTk9UIGVtaXQgbmV3IHJlcXVlc3RzIG9uIGFueSBjb25uZWN0aW9uIHdob3NlIE9yaWdpblxuXHQvLyBTZXQgaXMgYSBwcm9wZXIgc3Vic2V0IG9mIGFub3RoZXIgY29ubmVjdGlvbidzIE9yaWdpbiBTZXQsIGFuZCB0aGV5XG5cdC8vIFNIT1VMRCBjbG9zZSBpdCBvbmNlIGFsbCBvdXRzdGFuZGluZyByZXF1ZXN0cyBhcmUgc2F0aXNmaWVkLlxuXHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgd2hlcmUubGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0Y29uc3QgY292ZXJlZFNlc3Npb24gPSB3aGVyZVtpbmRleF07XG5cblx0XHRpZiAoXG5cdFx0XHQvLyBVbmZvcnR1bmF0ZWx5IGAuZXZlcnkoKWAgcmV0dXJucyB0cnVlIGZvciBhbiBlbXB0eSBhcnJheVxuXHRcdFx0Y292ZXJlZFNlc3Npb25ba09yaWdpblNldF0ubGVuZ3RoID4gMFxuXG5cdFx0XHQvLyBUaGUgc2V0IGlzIGEgcHJvcGVyIHN1YnNldCB3aGVuIGl0cyBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBvdGhlciBzZXQuXG5cdFx0XHQmJiBjb3ZlcmVkU2Vzc2lvbltrT3JpZ2luU2V0XS5sZW5ndGggPCBzZXNzaW9uW2tPcmlnaW5TZXRdLmxlbmd0aFxuXG5cdFx0XHQvLyBBbmQgdGhlIG90aGVyIHNldCBpbmNsdWRlcyBhbGwgZWxlbWVudHMgb2YgdGhlIHN1YnNldC5cblx0XHRcdCYmIGNvdmVyZWRTZXNzaW9uW2tPcmlnaW5TZXRdLmV2ZXJ5KG9yaWdpbiA9PiBzZXNzaW9uW2tPcmlnaW5TZXRdLmluY2x1ZGVzKG9yaWdpbikpXG5cblx0XHRcdC8vIE1ha2VzIHN1cmUgdGhhdCB0aGUgc2Vzc2lvbiBjYW4gaGFuZGxlIGFsbCByZXF1ZXN0cyBmcm9tIHRoZSBjb3ZlcmVkIHNlc3Npb24uXG5cdFx0XHQmJiAoY292ZXJlZFNlc3Npb25ba0N1cnJlbnRTdHJlYW1Db3VudF0gKyBzZXNzaW9uW2tDdXJyZW50U3RyZWFtQ291bnRdKSA8PSBzZXNzaW9uLnJlbW90ZVNldHRpbmdzLm1heENvbmN1cnJlbnRTdHJlYW1zXG5cdFx0KSB7XG5cdFx0XHQvLyBUaGlzIGFsbG93cyBwZW5kaW5nIHJlcXVlc3RzIHRvIGZpbmlzaCBhbmQgcHJldmVudHMgbWFraW5nIG5ldyByZXF1ZXN0cy5cblx0XHRcdGdyYWNlZnVsbHlDbG9zZShjb3ZlcmVkU2Vzc2lvbik7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBUaGlzIGlzIGJhc2ljYWxseSBpbnZlcnRlZCBgY2xvc2VDb3ZlcmVkU2Vzc2lvbnMoLi4uKWAuXG5jb25zdCBjbG9zZVNlc3Npb25JZkNvdmVyZWQgPSAod2hlcmUsIGNvdmVyZWRTZXNzaW9uKSA9PiB7XG5cdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB3aGVyZS5sZW5ndGg7IGluZGV4KyspIHtcblx0XHRjb25zdCBzZXNzaW9uID0gd2hlcmVbaW5kZXhdO1xuXG5cdFx0aWYgKFxuXHRcdFx0Y292ZXJlZFNlc3Npb25ba09yaWdpblNldF0ubGVuZ3RoID4gMFxuXHRcdFx0JiYgY292ZXJlZFNlc3Npb25ba09yaWdpblNldF0ubGVuZ3RoIDwgc2Vzc2lvbltrT3JpZ2luU2V0XS5sZW5ndGhcblx0XHRcdCYmIGNvdmVyZWRTZXNzaW9uW2tPcmlnaW5TZXRdLmV2ZXJ5KG9yaWdpbiA9PiBzZXNzaW9uW2tPcmlnaW5TZXRdLmluY2x1ZGVzKG9yaWdpbikpXG5cdFx0XHQmJiAoY292ZXJlZFNlc3Npb25ba0N1cnJlbnRTdHJlYW1Db3VudF0gKyBzZXNzaW9uW2tDdXJyZW50U3RyZWFtQ291bnRdKSA8PSBzZXNzaW9uLnJlbW90ZVNldHRpbmdzLm1heENvbmN1cnJlbnRTdHJlYW1zXG5cdFx0KSB7XG5cdFx0XHRncmFjZWZ1bGx5Q2xvc2UoY292ZXJlZFNlc3Npb24pO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBncmFjZWZ1bGx5Q2xvc2UgPSBzZXNzaW9uID0+IHtcblx0c2Vzc2lvbltrR3JhY2VmdWxseUNsb3NpbmddID0gdHJ1ZTtcblxuXHRpZiAoc2Vzc2lvbltrQ3VycmVudFN0cmVhbUNvdW50XSA9PT0gMCkge1xuXHRcdHNlc3Npb24uY2xvc2UoKTtcblx0fVxufTtcblxuY2xhc3MgQWdlbnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXHRjb25zdHJ1Y3Rvcih7dGltZW91dCA9IDAsIG1heFNlc3Npb25zID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXhFbXB0eVNlc3Npb25zID0gMTAsIG1heENhY2hlZFRsc1Nlc3Npb25zID0gMTAwfSA9IHt9KSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdC8vIFNFU1NJT05TW05PUk1BTElaRURfT1BUSU9OU10gPSBbXTtcblx0XHR0aGlzLnNlc3Npb25zID0ge307XG5cblx0XHQvLyBUaGUgcXVldWUgZm9yIGNyZWF0aW5nIG5ldyBzZXNzaW9ucy4gSXQgbG9va3MgbGlrZSB0aGlzOlxuXHRcdC8vIFFVRVVFW05PUk1BTElaRURfT1BUSU9OU11bTk9STUFMSVpFRF9PUklHSU5dID0gRU5UUllfRlVOQ1RJT05cblx0XHQvL1xuXHRcdC8vIEl0J3MgZmFzdGVyIHdoZW4gdGhlcmUgYXJlIG1hbnkgb3JpZ2lucy4gSWYgdGhlcmUncyBvbmx5IG9uZSwgdGhlbiBRVUVVRVtgJHtvcHRpb25zfToke29yaWdpbn1gXSBpcyBmYXN0ZXIuXG5cdFx0Ly8gSSBndWVzcyBvYmplY3QgY3JlYXRpb24gLyBkZWxldGlvbiBpcyBjYXVzaW5nIHRoZSBzbG93ZG93bi5cblx0XHQvL1xuXHRcdC8vIFRoZSBlbnRyeSBmdW5jdGlvbiBoYXMgYGxpc3RlbmVyc2AsIGBjb21wbGV0ZWRgIGFuZCBgZGVzdHJveWVkYCBwcm9wZXJ0aWVzLlxuXHRcdC8vIGBsaXN0ZW5lcnNgIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBgcmVzb2x2ZWAgYW5kIGByZWplY3RgIGZ1bmN0aW9ucy5cblx0XHQvLyBgY29tcGxldGVkYCBpcyBhIGJvb2xlYW4uIEl0J3Mgc2V0IHRvIHRydWUgYWZ0ZXIgRU5UUllfRlVOQ1RJT04gaXMgZXhlY3V0ZWQuXG5cdFx0Ly8gYGRlc3Ryb3llZGAgaXMgYSBib29sZWFuLiBJZiBpdCdzIHNldCB0byB0cnVlLCB0aGUgc2Vzc2lvbiB3aWxsIGJlIGRlc3Ryb3llZCBpZiBoYXNuJ3QgY29ubmVjdGVkIHlldC5cblx0XHR0aGlzLnF1ZXVlID0ge307XG5cblx0XHQvLyBFYWNoIHNlc3Npb24gd2lsbCB1c2UgdGhpcyB0aW1lb3V0IHZhbHVlLlxuXHRcdHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG5cblx0XHQvLyBNYXggc2Vzc2lvbnMgaW4gdG90YWxcblx0XHR0aGlzLm1heFNlc3Npb25zID0gbWF4U2Vzc2lvbnM7XG5cblx0XHQvLyBNYXggZW1wdHkgc2Vzc2lvbnMgaW4gdG90YWxcblx0XHR0aGlzLm1heEVtcHR5U2Vzc2lvbnMgPSBtYXhFbXB0eVNlc3Npb25zO1xuXG5cdFx0dGhpcy5fZW1wdHlTZXNzaW9uQ291bnQgPSAwO1xuXHRcdHRoaXMuX3Nlc3Npb25Db3VudCA9IDA7XG5cblx0XHQvLyBXZSBkb24ndCBzdXBwb3J0IHB1c2ggc3RyZWFtcyBieSBkZWZhdWx0LlxuXHRcdHRoaXMuc2V0dGluZ3MgPSB7XG5cdFx0XHRlbmFibGVQdXNoOiBmYWxzZSxcblx0XHRcdGluaXRpYWxXaW5kb3dTaXplOiAxMDI0ICogMTAyNCAqIDMyIC8vIDMyTUIsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzM4NDI2XG5cdFx0fTtcblxuXHRcdC8vIFJldXNpbmcgVExTIHNlc3Npb25zIGluY3JlYXNlcyBwZXJmb3JtYW5jZS5cblx0XHR0aGlzLnRsc1Nlc3Npb25DYWNoZSA9IG5ldyBRdWlja0xSVSh7bWF4U2l6ZTogbWF4Q2FjaGVkVGxzU2Vzc2lvbnN9KTtcblx0fVxuXG5cdGdldCBwcm90b2NvbCgpIHtcblx0XHRyZXR1cm4gJ2h0dHBzOic7XG5cdH1cblxuXHRub3JtYWxpemVPcHRpb25zKG9wdGlvbnMpIHtcblx0XHRsZXQgbm9ybWFsaXplZCA9ICcnO1xuXG5cdFx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG5hbWVLZXlzLmxlbmd0aDsgaW5kZXgrKykge1xuXHRcdFx0Y29uc3Qga2V5ID0gbmFtZUtleXNbaW5kZXhdO1xuXG5cdFx0XHRub3JtYWxpemVkICs9ICc6JztcblxuXHRcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bm9ybWFsaXplZCArPSBvcHRpb25zW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vcm1hbGl6ZWQ7XG5cdH1cblxuXHRfcHJvY2Vzc1F1ZXVlKCkge1xuXHRcdGlmICh0aGlzLl9zZXNzaW9uQ291bnQgPj0gdGhpcy5tYXhTZXNzaW9ucykge1xuXHRcdFx0dGhpcy5jbG9zZUVtcHR5U2Vzc2lvbnModGhpcy5tYXhTZXNzaW9ucyAtIHRoaXMuX3Nlc3Npb25Db3VudCArIDEpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cblx0XHRmb3IgKGNvbnN0IG5vcm1hbGl6ZWRPcHRpb25zIGluIHRoaXMucXVldWUpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cblx0XHRcdGZvciAoY29uc3Qgbm9ybWFsaXplZE9yaWdpbiBpbiB0aGlzLnF1ZXVlW25vcm1hbGl6ZWRPcHRpb25zXSkge1xuXHRcdFx0XHRjb25zdCBpdGVtID0gdGhpcy5xdWV1ZVtub3JtYWxpemVkT3B0aW9uc11bbm9ybWFsaXplZE9yaWdpbl07XG5cblx0XHRcdFx0Ly8gVGhlIGVudHJ5IGZ1bmN0aW9uIGNhbiBiZSBydW4gb25seSBvbmNlLlxuXHRcdFx0XHRpZiAoIWl0ZW0uY29tcGxldGVkKSB7XG5cdFx0XHRcdFx0aXRlbS5jb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0aXRlbSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0X2lzQmV0dGVyU2Vzc2lvbih0aGlzU3RyZWFtQ291bnQsIHRoYXRTdHJlYW1Db3VudCkge1xuXHRcdHJldHVybiB0aGlzU3RyZWFtQ291bnQgPiB0aGF0U3RyZWFtQ291bnQ7XG5cdH1cblxuXHRfYWNjZXB0KHNlc3Npb24sIGxpc3RlbmVycywgbm9ybWFsaXplZE9yaWdpbiwgb3B0aW9ucykge1xuXHRcdGxldCBpbmRleCA9IDA7XG5cblx0XHR3aGlsZSAoaW5kZXggPCBsaXN0ZW5lcnMubGVuZ3RoICYmIHNlc3Npb25ba0N1cnJlbnRTdHJlYW1Db3VudF0gPCBzZXNzaW9uLnJlbW90ZVNldHRpbmdzLm1heENvbmN1cnJlbnRTdHJlYW1zKSB7XG5cdFx0XHQvLyBXZSBhc3N1bWUgYHJlc29sdmUoLi4uKWAgY2FsbHMgYHJlcXVlc3QoLi4uKWAgKmRpcmVjdGx5Kixcblx0XHRcdC8vIG90aGVyd2lzZSB0aGUgc2Vzc2lvbiB3aWxsIGdldCBvdmVybG9hZGVkLlxuXHRcdFx0bGlzdGVuZXJzW2luZGV4XS5yZXNvbHZlKHNlc3Npb24pO1xuXG5cdFx0XHRpbmRleCsrO1xuXHRcdH1cblxuXHRcdGxpc3RlbmVycy5zcGxpY2UoMCwgaW5kZXgpO1xuXG5cdFx0aWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aGlzLmdldFNlc3Npb24obm9ybWFsaXplZE9yaWdpbiwgb3B0aW9ucywgbGlzdGVuZXJzKTtcblx0XHRcdGxpc3RlbmVycy5sZW5ndGggPSAwO1xuXHRcdH1cblx0fVxuXG5cdGdldFNlc3Npb24ob3JpZ2luLCBvcHRpb25zLCBsaXN0ZW5lcnMpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSAmJiBsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRsaXN0ZW5lcnMgPSBbLi4ubGlzdGVuZXJzXTtcblxuXHRcdFx0XHQvLyBSZXNvbHZlIHRoZSBjdXJyZW50IHByb21pc2UgQVNBUCwgd2UncmUganVzdCBtb3ZpbmcgdGhlIGxpc3RlbmVycy5cblx0XHRcdFx0Ly8gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGF0IGEgZGlmZmVyZW50IHRpbWUuXG5cdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxpc3RlbmVycyA9IFt7cmVzb2x2ZSwgcmVqZWN0fV07XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIFBhcnNlIG9yaWdpblxuXHRcdFx0XHRpZiAodHlwZW9mIG9yaWdpbiA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRvcmlnaW4gPSBuZXcgVVJMKG9yaWdpbik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIShvcmlnaW4gaW5zdGFuY2VvZiBVUkwpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGBvcmlnaW5gIGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgc3RyaW5nIG9yIGFuIFVSTCBvYmplY3QnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvcHRpb25zKSB7XG5cdFx0XHRcdFx0Ly8gVmFsaWRhdGUgc2VydmVybmFtZVxuXHRcdFx0XHRcdGNvbnN0IHtzZXJ2ZXJuYW1lfSA9IG9wdGlvbnM7XG5cdFx0XHRcdFx0Y29uc3Qge2hvc3RuYW1lfSA9IG9yaWdpbjtcblx0XHRcdFx0XHRpZiAoc2VydmVybmFtZSAmJiBob3N0bmFtZSAhPT0gc2VydmVybmFtZSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBPcmlnaW4gJHtob3N0bmFtZX0gZGlmZmVycyBmcm9tIHNlcnZlcm5hbWUgJHtzZXJ2ZXJuYW1lfWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxpc3RlbmVycy5sZW5ndGg7IGluZGV4KyspIHtcblx0XHRcdFx0XHRsaXN0ZW5lcnNbaW5kZXhdLnJlamVjdChlcnJvcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG5vcm1hbGl6ZWRPcHRpb25zID0gdGhpcy5ub3JtYWxpemVPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0Y29uc3Qgbm9ybWFsaXplZE9yaWdpbiA9IG9yaWdpbi5vcmlnaW47XG5cblx0XHRcdGlmIChub3JtYWxpemVkT3B0aW9ucyBpbiB0aGlzLnNlc3Npb25zKSB7XG5cdFx0XHRcdGNvbnN0IHNlc3Npb25zID0gdGhpcy5zZXNzaW9uc1tub3JtYWxpemVkT3B0aW9uc107XG5cblx0XHRcdFx0bGV0IG1heENvbmN1cnJlbnRTdHJlYW1zID0gLTE7XG5cdFx0XHRcdGxldCBjdXJyZW50U3RyZWFtc0NvdW50ID0gLTE7XG5cdFx0XHRcdGxldCBvcHRpbWFsU2Vzc2lvbjtcblxuXHRcdFx0XHQvLyBXZSBjb3VsZCBqdXN0IGRvIHRoaXMuc2Vzc2lvbnNbbm9ybWFsaXplZE9wdGlvbnNdLmZpbmQoLi4uKSBidXQgdGhhdCBpc24ndCBvcHRpbWFsLlxuXHRcdFx0XHQvLyBBZGRpdGlvbmFsbHksIHdlIGFyZSBsb29raW5nIGZvciBzZXNzaW9uIHdoaWNoIGhhcyBiaWdnZXN0IGN1cnJlbnQgcGVuZGluZyBzdHJlYW1zIGNvdW50LlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyB8LS0tLS0tLS0tLS0tfCB8LS0tLS0tLS0tLS0tfCB8LS0tLS0tLS0tLS0tfCB8LS0tLS0tLS0tLS0tfFxuXHRcdFx0XHQvLyB8IFNlc3Npb246IEEgfCB8IFNlc3Npb246IEIgfCB8IFNlc3Npb246IEMgfCB8IFNlc3Npb246IEQgfFxuXHRcdFx0XHQvLyB8IFBlbmRpbmc6IDUgfC18IFBlbmRpbmc6IDggfC18IFBlbmRpbmc6IDkgfC18IFBlbmRpbmc6IDQgfFxuXHRcdFx0XHQvLyB8IE1heDogICAgMTAgfCB8IE1heDogICAgMTAgfCB8IE1heDogICAgIDkgfCB8IE1heDogICAgIDUgfFxuXHRcdFx0XHQvLyB8LS0tLS0tLS0tLS0tfCB8LS0tLS0tLS0tLS0tfCB8LS0tLS0tLS0tLS0tfCB8LS0tLS0tLS0tLS0tfFxuXHRcdFx0XHQvLyAgICAgICAgICAgICAgICAgICAgIF5cblx0XHRcdFx0Ly8gICAgICAgICAgICAgICAgICAgICB8XG5cdFx0XHRcdC8vICAgICBwaWNrIHRoaXMgb25lICAtLVxuXHRcdFx0XHQvL1xuXHRcdFx0XHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc2Vzc2lvbnMubGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2Vzc2lvbiA9IHNlc3Npb25zW2luZGV4XTtcblxuXHRcdFx0XHRcdGNvbnN0IHNlc3Npb25NYXhDb25jdXJyZW50U3RyZWFtcyA9IHNlc3Npb24ucmVtb3RlU2V0dGluZ3MubWF4Q29uY3VycmVudFN0cmVhbXM7XG5cblx0XHRcdFx0XHRpZiAoc2Vzc2lvbk1heENvbmN1cnJlbnRTdHJlYW1zIDwgbWF4Q29uY3VycmVudFN0cmVhbXMpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICghc2Vzc2lvbltrT3JpZ2luU2V0XS5pbmNsdWRlcyhub3JtYWxpemVkT3JpZ2luKSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3Qgc2Vzc2lvbkN1cnJlbnRTdHJlYW1zQ291bnQgPSBzZXNzaW9uW2tDdXJyZW50U3RyZWFtQ291bnRdO1xuXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0c2Vzc2lvbkN1cnJlbnRTdHJlYW1zQ291bnQgPj0gc2Vzc2lvbk1heENvbmN1cnJlbnRTdHJlYW1zXG5cdFx0XHRcdFx0XHR8fCBzZXNzaW9uW2tHcmFjZWZ1bGx5Q2xvc2luZ11cblx0XHRcdFx0XHRcdC8vIFVuZm9ydHVuYXRlbHkgdGhlIGBjbG9zZWAgZXZlbnQgaXNuJ3QgY2FsbGVkIGltbWVkaWF0ZWx5LFxuXHRcdFx0XHRcdFx0Ly8gc28gYHNlc3Npb24uZGVzdHJveWVkYCBpcyBgdHJ1ZWAsIGJ1dCBgc2Vzc2lvbi5jbG9zZWRgIGlzIGBmYWxzZWAuXG5cdFx0XHRcdFx0XHR8fCBzZXNzaW9uLmRlc3Ryb3llZFxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gV2Ugb25seSBuZWVkIHNldCB0aGlzIG9uY2UuXG5cdFx0XHRcdFx0aWYgKCFvcHRpbWFsU2Vzc2lvbikge1xuXHRcdFx0XHRcdFx0bWF4Q29uY3VycmVudFN0cmVhbXMgPSBzZXNzaW9uTWF4Q29uY3VycmVudFN0cmVhbXM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIGdldCB0aGUgc2Vzc2lvbiB3aGljaCBoYXMgYmlnZ2VzdCBjdXJyZW50IHN0cmVhbSBjb3VudCBvciB0aGUgbG93ZXN0LlxuXHRcdFx0XHRcdGlmICh0aGlzLl9pc0JldHRlclNlc3Npb24oc2Vzc2lvbkN1cnJlbnRTdHJlYW1zQ291bnQsIGN1cnJlbnRTdHJlYW1zQ291bnQpKSB7XG5cdFx0XHRcdFx0XHRvcHRpbWFsU2Vzc2lvbiA9IHNlc3Npb247XG5cdFx0XHRcdFx0XHRjdXJyZW50U3RyZWFtc0NvdW50ID0gc2Vzc2lvbkN1cnJlbnRTdHJlYW1zQ291bnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9wdGltYWxTZXNzaW9uKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWNjZXB0KG9wdGltYWxTZXNzaW9uLCBsaXN0ZW5lcnMsIG5vcm1hbGl6ZWRPcmlnaW4sIG9wdGlvbnMpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobm9ybWFsaXplZE9wdGlvbnMgaW4gdGhpcy5xdWV1ZSkge1xuXHRcdFx0XHRpZiAobm9ybWFsaXplZE9yaWdpbiBpbiB0aGlzLnF1ZXVlW25vcm1hbGl6ZWRPcHRpb25zXSkge1xuXHRcdFx0XHRcdC8vIFRoZXJlJ3MgYWxyZWFkeSBhbiBpdGVtIGluIHRoZSBxdWV1ZSwganVzdCBhdHRhY2ggb3Vyc2VsdmVzIHRvIGl0LlxuXHRcdFx0XHRcdHRoaXMucXVldWVbbm9ybWFsaXplZE9wdGlvbnNdW25vcm1hbGl6ZWRPcmlnaW5dLmxpc3RlbmVycy5wdXNoKC4uLmxpc3RlbmVycyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnF1ZXVlW25vcm1hbGl6ZWRPcHRpb25zXSA9IHtcblx0XHRcdFx0XHRba0xlbmd0aF06IDBcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVudHJ5IG11c3QgYmUgcmVtb3ZlZCBmcm9tIHRoZSBxdWV1ZSBJTU1FRElBVEVMWSB3aGVuOlxuXHRcdFx0Ly8gMS4gdGhlIHNlc3Npb24gY29ubmVjdHMgc3VjY2Vzc2Z1bGx5LFxuXHRcdFx0Ly8gMi4gYW4gZXJyb3Igb2NjdXJzLlxuXHRcdFx0Y29uc3QgcmVtb3ZlRnJvbVF1ZXVlID0gKCkgPT4ge1xuXHRcdFx0XHQvLyBPdXIgZW50cnkgY2FuIGJlIHJlcGxhY2VkLiBXZSBjYW5ub3QgcmVtb3ZlIHRoZSBuZXcgb25lLlxuXHRcdFx0XHRpZiAobm9ybWFsaXplZE9wdGlvbnMgaW4gdGhpcy5xdWV1ZSAmJiB0aGlzLnF1ZXVlW25vcm1hbGl6ZWRPcHRpb25zXVtub3JtYWxpemVkT3JpZ2luXSA9PT0gZW50cnkpIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5xdWV1ZVtub3JtYWxpemVkT3B0aW9uc11bbm9ybWFsaXplZE9yaWdpbl07XG5cblx0XHRcdFx0XHRpZiAoLS10aGlzLnF1ZXVlW25vcm1hbGl6ZWRPcHRpb25zXVtrTGVuZ3RoXSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMucXVldWVbbm9ybWFsaXplZE9wdGlvbnNdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gVGhlIG1haW4gbG9naWMgaXMgaGVyZVxuXHRcdFx0Y29uc3QgZW50cnkgPSBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuX3Nlc3Npb25Db3VudCsrO1xuXG5cdFx0XHRcdGNvbnN0IG5hbWUgPSBgJHtub3JtYWxpemVkT3JpZ2lufToke25vcm1hbGl6ZWRPcHRpb25zfWA7XG5cdFx0XHRcdGxldCByZWNlaXZlZFNldHRpbmdzID0gZmFsc2U7XG5cdFx0XHRcdGxldCBzb2NrZXQ7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb25zdCBjb21wdXRlZE9wdGlvbnMgPSB7Li4ub3B0aW9uc307XG5cblx0XHRcdFx0XHRpZiAoY29tcHV0ZWRPcHRpb25zLnNldHRpbmdzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGNvbXB1dGVkT3B0aW9ucy5zZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGNvbXB1dGVkT3B0aW9ucy5zZXNzaW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGNvbXB1dGVkT3B0aW9ucy5zZXNzaW9uID0gdGhpcy50bHNTZXNzaW9uQ2FjaGUuZ2V0KG5hbWUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IGNyZWF0ZUNvbm5lY3Rpb24gPSBjb21wdXRlZE9wdGlvbnMuY3JlYXRlQ29ubmVjdGlvbiB8fCB0aGlzLmNyZWF0ZUNvbm5lY3Rpb247XG5cblx0XHRcdFx0XHQvLyBBIGhhY2t5IHdvcmthcm91bmQgdG8gZW5hYmxlIGFzeW5jIGBjcmVhdGVDb25uZWN0aW9uYFxuXHRcdFx0XHRcdHNvY2tldCA9IGF3YWl0IGNyZWF0ZUNvbm5lY3Rpb24uY2FsbCh0aGlzLCBvcmlnaW4sIGNvbXB1dGVkT3B0aW9ucyk7XG5cdFx0XHRcdFx0Y29tcHV0ZWRPcHRpb25zLmNyZWF0ZUNvbm5lY3Rpb24gPSAoKSA9PiBzb2NrZXQ7XG5cblx0XHRcdFx0XHRjb25zdCBzZXNzaW9uID0gaHR0cDIuY29ubmVjdChvcmlnaW4sIGNvbXB1dGVkT3B0aW9ucyk7XG5cdFx0XHRcdFx0c2Vzc2lvbltrQ3VycmVudFN0cmVhbUNvdW50XSA9IDA7XG5cdFx0XHRcdFx0c2Vzc2lvbltrR3JhY2VmdWxseUNsb3NpbmddID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBOb2RlLmpzIHJldHVybiBodHRwczovL2ZhbHNlOjQ0MyBpbnN0ZWFkIG9mIGh0dHBzOi8vMS4xLjEuMTo0NDNcblx0XHRcdFx0XHRjb25zdCBnZXRPcmlnaW5TZXQgPSAoKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCB7c29ja2V0fSA9IHNlc3Npb247XG5cblx0XHRcdFx0XHRcdGxldCBvcmlnaW5TZXQ7XG5cdFx0XHRcdFx0XHRpZiAoc29ja2V0LnNlcnZlcm5hbWUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdHNvY2tldC5zZXJ2ZXJuYW1lID0gc29ja2V0LnJlbW90ZUFkZHJlc3M7XG5cdFx0XHRcdFx0XHRcdG9yaWdpblNldCA9IHNlc3Npb24ub3JpZ2luU2V0O1xuXHRcdFx0XHRcdFx0XHRzb2NrZXQuc2VydmVybmFtZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0b3JpZ2luU2V0ID0gc2Vzc2lvbi5vcmlnaW5TZXQ7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBvcmlnaW5TZXQ7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGNvbnN0IGlzRnJlZSA9ICgpID0+IHNlc3Npb25ba0N1cnJlbnRTdHJlYW1Db3VudF0gPCBzZXNzaW9uLnJlbW90ZVNldHRpbmdzLm1heENvbmN1cnJlbnRTdHJlYW1zO1xuXG5cdFx0XHRcdFx0c2Vzc2lvbi5zb2NrZXQub25jZSgnc2Vzc2lvbicsIHRsc1Nlc3Npb24gPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy50bHNTZXNzaW9uQ2FjaGUuc2V0KG5hbWUsIHRsc1Nlc3Npb24pO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0c2Vzc2lvbi5vbmNlKCdlcnJvcicsIGVycm9yID0+IHtcblx0XHRcdFx0XHRcdC8vIExpc3RlbmVycyBhcmUgZW1wdHkgd2hlbiB0aGUgc2Vzc2lvbiBzdWNjZXNzZnVsbHkgY29ubmVjdGVkLlxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxpc3RlbmVycy5sZW5ndGg7IGluZGV4KyspIHtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXJzW2luZGV4XS5yZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBUaGUgY29ubmVjdGlvbiBnb3QgYnJva2VuLCBwdXJnZSB0aGUgY2FjaGUuXG5cdFx0XHRcdFx0XHR0aGlzLnRsc1Nlc3Npb25DYWNoZS5kZWxldGUobmFtZSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRzZXNzaW9uLnNldFRpbWVvdXQodGhpcy50aW1lb3V0LCAoKSA9PiB7XG5cdFx0XHRcdFx0XHQvLyBUZXJtaW5hdGVzIGFsbCBzdHJlYW1zIG93bmVkIGJ5IHRoaXMgc2Vzc2lvbi5cblx0XHRcdFx0XHRcdHNlc3Npb24uZGVzdHJveSgpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0c2Vzc2lvbi5vbmNlKCdjbG9zZScsICgpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuX3Nlc3Npb25Db3VudC0tO1xuXG5cdFx0XHRcdFx0XHRpZiAocmVjZWl2ZWRTZXR0aW5ncykge1xuXHRcdFx0XHRcdFx0XHQvLyBBc3N1bWVzIHNlc3Npb24gYGNsb3NlYCBpcyBlbWl0dGVkIGFmdGVyIHJlcXVlc3QgYGNsb3NlYFxuXHRcdFx0XHRcdFx0XHR0aGlzLl9lbXB0eVNlc3Npb25Db3VudC0tO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgY2Fubm90IGJlIG1vdmVkIHRvIHRoZSBzdHJlYW0gbG9naWMsXG5cdFx0XHRcdFx0XHRcdC8vIGJlY2F1c2UgdGhlcmUgbWF5IGJlIGEgc2Vzc2lvbiB0aGF0IGhhZG4ndCBtYWRlIGEgc2luZ2xlIHJlcXVlc3QuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHdoZXJlID0gdGhpcy5zZXNzaW9uc1tub3JtYWxpemVkT3B0aW9uc107XG5cblx0XHRcdFx0XHRcdFx0aWYgKHdoZXJlLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnNlc3Npb25zW25vcm1hbGl6ZWRPcHRpb25zXTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR3aGVyZS5zcGxpY2Uod2hlcmUuaW5kZXhPZihzZXNzaW9uKSwgMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIEJyb2tlbiBjb25uZWN0aW9uXG5cdFx0XHRcdFx0XHRcdHJlbW92ZUZyb21RdWV1ZSgpO1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdTZXNzaW9uIGNsb3NlZCB3aXRob3V0IHJlY2VpdmluZyBhIFNFVFRJTkdTIGZyYW1lJyk7XG5cdFx0XHRcdFx0XHRcdGVycm9yLmNvZGUgPSAnSFRUUDJXUkFQUEVSX05PU0VUVElOR1MnO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsaXN0ZW5lcnMubGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGlzdGVuZXJzW2luZGV4XS5yZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFRoZXJlIG1heSBiZSBhbm90aGVyIHNlc3Npb24gYXdhaXRpbmcuXG5cdFx0XHRcdFx0XHR0aGlzLl9wcm9jZXNzUXVldWUoKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIEl0ZXJhdGVzIG92ZXIgdGhlIHF1ZXVlIGFuZCBwcm9jZXNzZXMgbGlzdGVuZXJzLlxuXHRcdFx0XHRcdGNvbnN0IHByb2Nlc3NMaXN0ZW5lcnMgPSAoKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVbbm9ybWFsaXplZE9wdGlvbnNdO1xuXHRcdFx0XHRcdFx0aWYgKCFxdWV1ZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IG9yaWdpblNldCA9IHNlc3Npb25ba09yaWdpblNldF07XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBvcmlnaW5TZXQubGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG9yaWdpbiA9IG9yaWdpblNldFtpbmRleF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKG9yaWdpbiBpbiBxdWV1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHtsaXN0ZW5lcnMsIGNvbXBsZXRlZH0gPSBxdWV1ZVtvcmlnaW5dO1xuXG5cdFx0XHRcdFx0XHRcdFx0bGV0IGluZGV4ID0gMDtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFByZXZlbnRzIHNlc3Npb24gb3ZlcmxvYWRpbmcuXG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGluZGV4IDwgbGlzdGVuZXJzLmxlbmd0aCAmJiBpc0ZyZWUoKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gV2UgYXNzdW1lIGByZXNvbHZlKC4uLilgIGNhbGxzIGByZXF1ZXN0KC4uLilgICpkaXJlY3RseSosXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBvdGhlcndpc2UgdGhlIHNlc3Npb24gd2lsbCBnZXQgb3ZlcmxvYWRlZC5cblx0XHRcdFx0XHRcdFx0XHRcdGxpc3RlbmVyc1tpbmRleF0ucmVzb2x2ZShzZXNzaW9uKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRxdWV1ZVtvcmlnaW5dLmxpc3RlbmVycy5zcGxpY2UoMCwgaW5kZXgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHF1ZXVlW29yaWdpbl0ubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCAmJiAhY29tcGxldGVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZWxldGUgcXVldWVbb3JpZ2luXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKC0tcXVldWVba0xlbmd0aF0gPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMucXVldWVbbm9ybWFsaXplZE9wdGlvbnNdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXZSdyZSBubyBsb25nZXIgZnJlZSwgbm8gcG9pbnQgaW4gY29udGludWluZy5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIWlzRnJlZSgpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Ly8gVGhlIE9yaWdpbiBTZXQgY2Fubm90IHNocmluay4gTm8gbmVlZCB0byBjaGVjayBpZiBpdCBzdWRkZW5seSBiZWNhbWUgY292ZXJlZCBieSBhbm90aGVyIG9uZS5cblx0XHRcdFx0XHRzZXNzaW9uLm9uKCdvcmlnaW4nLCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRzZXNzaW9uW2tPcmlnaW5TZXRdID0gZ2V0T3JpZ2luU2V0KCkgfHwgW107XG5cdFx0XHRcdFx0XHRzZXNzaW9uW2tHcmFjZWZ1bGx5Q2xvc2luZ10gPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb3NlU2Vzc2lvbklmQ292ZXJlZCh0aGlzLnNlc3Npb25zW25vcm1hbGl6ZWRPcHRpb25zXSwgc2Vzc2lvbik7XG5cblx0XHRcdFx0XHRcdGlmIChzZXNzaW9uW2tHcmFjZWZ1bGx5Q2xvc2luZ10gfHwgIWlzRnJlZSgpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cHJvY2Vzc0xpc3RlbmVycygpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIWlzRnJlZSgpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gQ2xvc2UgY292ZXJlZCBzZXNzaW9ucyAoaWYgcG9zc2libGUpLlxuXHRcdFx0XHRcdFx0Y2xvc2VDb3ZlcmVkU2Vzc2lvbnModGhpcy5zZXNzaW9uc1tub3JtYWxpemVkT3B0aW9uc10sIHNlc3Npb24pO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0c2Vzc2lvbi5vbmNlKCdyZW1vdGVTZXR0aW5ncycsICgpID0+IHtcblx0XHRcdFx0XHRcdC8vIFRoZSBBZ2VudCBjb3VsZCBoYXZlIGJlZW4gZGVzdHJveWVkIGFscmVhZHkuXG5cdFx0XHRcdFx0XHRpZiAoZW50cnkuZGVzdHJveWVkKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdBZ2VudCBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGlzdGVuZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuXHRcdFx0XHRcdFx0XHRcdGxpc3RlbmVyc1tpbmRleF0ucmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHNlc3Npb24uZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzM4NDI2XG5cdFx0XHRcdFx0XHRpZiAoc2Vzc2lvbi5zZXRMb2NhbFdpbmRvd1NpemUpIHtcblx0XHRcdFx0XHRcdFx0c2Vzc2lvbi5zZXRMb2NhbFdpbmRvd1NpemUoMTAyNCAqIDEwMjQgKiA0KTsgLy8gNCBNQlxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzZXNzaW9uW2tPcmlnaW5TZXRdID0gZ2V0T3JpZ2luU2V0KCkgfHwgW107XG5cblx0XHRcdFx0XHRcdGlmIChzZXNzaW9uLnNvY2tldC5lbmNyeXB0ZWQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWFpbk9yaWdpbiA9IHNlc3Npb25ba09yaWdpblNldF1bMF07XG5cdFx0XHRcdFx0XHRcdGlmIChtYWluT3JpZ2luICE9PSBub3JtYWxpemVkT3JpZ2luKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFJlcXVlc3RlZCBvcmlnaW4gJHtub3JtYWxpemVkT3JpZ2lufSBkb2VzIG5vdCBtYXRjaCBzZXJ2ZXIgJHttYWluT3JpZ2lufWApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxpc3RlbmVycy5sZW5ndGg7IGluZGV4KyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3RlbmVyc1tpbmRleF0ucmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRzZXNzaW9uLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmVtb3ZlRnJvbVF1ZXVlKCk7XG5cblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgd2hlcmUgPSB0aGlzLnNlc3Npb25zO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChub3JtYWxpemVkT3B0aW9ucyBpbiB3aGVyZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHNlc3Npb25zID0gd2hlcmVbbm9ybWFsaXplZE9wdGlvbnNdO1xuXHRcdFx0XHRcdFx0XHRcdHNlc3Npb25zLnNwbGljZShnZXRTb3J0ZWRJbmRleChzZXNzaW9ucywgc2Vzc2lvbiwgY29tcGFyZVNlc3Npb25zKSwgMCwgc2Vzc2lvbik7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0d2hlcmVbbm9ybWFsaXplZE9wdGlvbnNdID0gW3Nlc3Npb25dO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJlY2VpdmVkU2V0dGluZ3MgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGhpcy5fZW1wdHlTZXNzaW9uQ291bnQrKztcblxuXHRcdFx0XHRcdFx0dGhpcy5lbWl0KCdzZXNzaW9uJywgc2Vzc2lvbik7XG5cdFx0XHRcdFx0XHR0aGlzLl9hY2NlcHQoc2Vzc2lvbiwgbGlzdGVuZXJzLCBub3JtYWxpemVkT3JpZ2luLCBvcHRpb25zKTtcblxuXHRcdFx0XHRcdFx0aWYgKHNlc3Npb25ba0N1cnJlbnRTdHJlYW1Db3VudF0gPT09IDAgJiYgdGhpcy5fZW1wdHlTZXNzaW9uQ291bnQgPiB0aGlzLm1heEVtcHR5U2Vzc2lvbnMpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5jbG9zZUVtcHR5U2Vzc2lvbnModGhpcy5fZW1wdHlTZXNzaW9uQ291bnQgLSB0aGlzLm1heEVtcHR5U2Vzc2lvbnMpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBgc2Vzc2lvbi5yZW1vdGVTZXR0aW5ncy5tYXhDb25jdXJyZW50U3RyZWFtc2AgbWlnaHQgZ2V0IGluY3JlYXNlZFxuXHRcdFx0XHRcdFx0c2Vzc2lvbi5vbigncmVtb3RlU2V0dGluZ3MnLCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmICghaXNGcmVlKCkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRwcm9jZXNzTGlzdGVuZXJzKCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFpc0ZyZWUoKSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIEluIGNhc2UgdGhlIE9yaWdpbiBTZXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0XHRjbG9zZUNvdmVyZWRTZXNzaW9ucyh0aGlzLnNlc3Npb25zW25vcm1hbGl6ZWRPcHRpb25zXSwgc2Vzc2lvbik7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIFNoaW0gYHNlc3Npb24ucmVxdWVzdCgpYCBpbiBvcmRlciB0byBjYXRjaCBhbGwgc3RyZWFtc1xuXHRcdFx0XHRcdHNlc3Npb25ba1JlcXVlc3RdID0gc2Vzc2lvbi5yZXF1ZXN0O1xuXHRcdFx0XHRcdHNlc3Npb24ucmVxdWVzdCA9IChoZWFkZXJzLCBzdHJlYW1PcHRpb25zKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoc2Vzc2lvbltrR3JhY2VmdWxseUNsb3NpbmddKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIHNlc3Npb24gaXMgZ3JhY2VmdWxseSBjbG9zaW5nLiBObyBuZXcgc3RyZWFtcyBhcmUgYWxsb3dlZC4nKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3Qgc3RyZWFtID0gc2Vzc2lvbltrUmVxdWVzdF0oaGVhZGVycywgc3RyZWFtT3B0aW9ucyk7XG5cblx0XHRcdFx0XHRcdC8vIFRoZSBwcm9jZXNzIHdvbid0IGV4aXQgdW50aWwgdGhlIHNlc3Npb24gaXMgY2xvc2VkIG9yIGFsbCByZXF1ZXN0cyBhcmUgZ29uZS5cblx0XHRcdFx0XHRcdHNlc3Npb24ucmVmKCk7XG5cblx0XHRcdFx0XHRcdGlmIChzZXNzaW9uW2tDdXJyZW50U3RyZWFtQ291bnRdKysgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZW1wdHlTZXNzaW9uQ291bnQtLTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAoLS1zZXNzaW9uW2tDdXJyZW50U3RyZWFtQ291bnRdID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZW1wdHlTZXNzaW9uQ291bnQrKztcblx0XHRcdFx0XHRcdFx0XHRzZXNzaW9uLnVucmVmKCk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5fZW1wdHlTZXNzaW9uQ291bnQgPiB0aGlzLm1heEVtcHR5U2Vzc2lvbnMgfHwgc2Vzc2lvbltrR3JhY2VmdWxseUNsb3NpbmddKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZXNzaW9uLmNsb3NlKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKHNlc3Npb24uZGVzdHJveWVkIHx8IHNlc3Npb24uY2xvc2VkKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKGlzRnJlZSgpICYmICFjbG9zZVNlc3Npb25JZkNvdmVyZWQodGhpcy5zZXNzaW9uc1tub3JtYWxpemVkT3B0aW9uc10sIHNlc3Npb24pKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xvc2VDb3ZlcmVkU2Vzc2lvbnModGhpcy5zZXNzaW9uc1tub3JtYWxpemVkT3B0aW9uc10sIHNlc3Npb24pO1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3NMaXN0ZW5lcnMoKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChzZXNzaW9uW2tDdXJyZW50U3RyZWFtQ291bnRdID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9wcm9jZXNzUXVldWUoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gc3RyZWFtO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0cmVtb3ZlRnJvbVF1ZXVlKCk7XG5cdFx0XHRcdFx0dGhpcy5fc2Vzc2lvbkNvdW50LS07XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGlzdGVuZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuXHRcdFx0XHRcdFx0bGlzdGVuZXJzW2luZGV4XS5yZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0ZW50cnkubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuXHRcdFx0ZW50cnkuY29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRlbnRyeS5kZXN0cm95ZWQgPSBmYWxzZTtcblxuXHRcdFx0dGhpcy5xdWV1ZVtub3JtYWxpemVkT3B0aW9uc11bbm9ybWFsaXplZE9yaWdpbl0gPSBlbnRyeTtcblx0XHRcdHRoaXMucXVldWVbbm9ybWFsaXplZE9wdGlvbnNdW2tMZW5ndGhdKys7XG5cdFx0XHR0aGlzLl9wcm9jZXNzUXVldWUoKTtcblx0XHR9KTtcblx0fVxuXG5cdHJlcXVlc3Qob3JpZ2luLCBvcHRpb25zLCBoZWFkZXJzLCBzdHJlYW1PcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdHRoaXMuZ2V0U2Vzc2lvbihvcmlnaW4sIG9wdGlvbnMsIFt7XG5cdFx0XHRcdHJlamVjdCxcblx0XHRcdFx0cmVzb2x2ZTogc2Vzc2lvbiA9PiB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGNvbnN0IHN0cmVhbSA9IHNlc3Npb24ucmVxdWVzdChoZWFkZXJzLCBzdHJlYW1PcHRpb25zKTtcblxuXHRcdFx0XHRcdFx0Ly8gRG8gbm90IHRocm93IGJlZm9yZSBgcmVxdWVzdCguLi4pYCBoYXMgYmVlbiBhd2FpdGVkXG5cdFx0XHRcdFx0XHRkZWxheUFzeW5jRGVzdHJveShzdHJlYW0pO1xuXG5cdFx0XHRcdFx0XHRyZXNvbHZlKHN0cmVhbSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XSk7XG5cdFx0fSk7XG5cdH1cblxuXHRhc3luYyBjcmVhdGVDb25uZWN0aW9uKG9yaWdpbiwgb3B0aW9ucykge1xuXHRcdHJldHVybiBBZ2VudC5jb25uZWN0KG9yaWdpbiwgb3B0aW9ucyk7XG5cdH1cblxuXHRzdGF0aWMgY29ubmVjdChvcmlnaW4sIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zLkFMUE5Qcm90b2NvbHMgPSBbJ2gyJ107XG5cblx0XHRjb25zdCBwb3J0ID0gb3JpZ2luLnBvcnQgfHwgNDQzO1xuXHRcdGNvbnN0IGhvc3QgPSBvcmlnaW4uaG9zdG5hbWU7XG5cblx0XHRpZiAodHlwZW9mIG9wdGlvbnMuc2VydmVybmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdG9wdGlvbnMuc2VydmVybmFtZSA9IGhvc3Q7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc29ja2V0ID0gdGxzLmNvbm5lY3QocG9ydCwgaG9zdCwgb3B0aW9ucyk7XG5cblx0XHRpZiAob3B0aW9ucy5zb2NrZXQpIHtcblx0XHRcdHNvY2tldC5fcGVlcm5hbWUgPSB7XG5cdFx0XHRcdGZhbWlseTogdW5kZWZpbmVkLFxuXHRcdFx0XHRhZGRyZXNzOiB1bmRlZmluZWQsXG5cdFx0XHRcdHBvcnRcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNvY2tldDtcblx0fVxuXG5cdGNsb3NlRW1wdHlTZXNzaW9ucyhtYXhDb3VudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuXHRcdGxldCBjbG9zZWRDb3VudCA9IDA7XG5cblx0XHRjb25zdCB7c2Vzc2lvbnN9ID0gdGhpcztcblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cblx0XHRmb3IgKGNvbnN0IGtleSBpbiBzZXNzaW9ucykge1xuXHRcdFx0Y29uc3QgdGhpc1Nlc3Npb25zID0gc2Vzc2lvbnNba2V5XTtcblxuXHRcdFx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXNTZXNzaW9ucy5sZW5ndGg7IGluZGV4KyspIHtcblx0XHRcdFx0Y29uc3Qgc2Vzc2lvbiA9IHRoaXNTZXNzaW9uc1tpbmRleF07XG5cblx0XHRcdFx0aWYgKHNlc3Npb25ba0N1cnJlbnRTdHJlYW1Db3VudF0gPT09IDApIHtcblx0XHRcdFx0XHRjbG9zZWRDb3VudCsrO1xuXHRcdFx0XHRcdHNlc3Npb24uY2xvc2UoKTtcblxuXHRcdFx0XHRcdGlmIChjbG9zZWRDb3VudCA+PSBtYXhDb3VudCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNsb3NlZENvdW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbG9zZWRDb3VudDtcblx0fVxuXG5cdGRlc3Ryb3kocmVhc29uKSB7XG5cdFx0Y29uc3Qge3Nlc3Npb25zLCBxdWV1ZX0gPSB0aGlzO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuXHRcdGZvciAoY29uc3Qga2V5IGluIHNlc3Npb25zKSB7XG5cdFx0XHRjb25zdCB0aGlzU2Vzc2lvbnMgPSBzZXNzaW9uc1trZXldO1xuXG5cdFx0XHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpc1Nlc3Npb25zLmxlbmd0aDsgaW5kZXgrKykge1xuXHRcdFx0XHR0aGlzU2Vzc2lvbnNbaW5kZXhdLmRlc3Ryb3kocmVhc29uKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG5cdFx0Zm9yIChjb25zdCBub3JtYWxpemVkT3B0aW9ucyBpbiBxdWV1ZSkge1xuXHRcdFx0Y29uc3QgZW50cmllcyA9IHF1ZXVlW25vcm1hbGl6ZWRPcHRpb25zXTtcblxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuXHRcdFx0Zm9yIChjb25zdCBub3JtYWxpemVkT3JpZ2luIGluIGVudHJpZXMpIHtcblx0XHRcdFx0ZW50cmllc1tub3JtYWxpemVkT3JpZ2luXS5kZXN0cm95ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE5ldyByZXF1ZXN0cyBzaG91bGQgTk9UIGF0dGFjaCB0byBkZXN0cm95ZWQgc2Vzc2lvbnNcblx0XHR0aGlzLnF1ZXVlID0ge307XG5cdFx0dGhpcy50bHNTZXNzaW9uQ2FjaGUuY2xlYXIoKTtcblx0fVxuXG5cdGdldCBlbXB0eVNlc3Npb25Db3VudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZW1wdHlTZXNzaW9uQ291bnQ7XG5cdH1cblxuXHRnZXQgcGVuZGluZ1Nlc3Npb25Db3VudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2Vzc2lvbkNvdW50IC0gdGhpcy5fZW1wdHlTZXNzaW9uQ291bnQ7XG5cdH1cblxuXHRnZXQgc2Vzc2lvbkNvdW50KCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXNzaW9uQ291bnQ7XG5cdH1cbn1cblxuQWdlbnQua0N1cnJlbnRTdHJlYW1Db3VudCA9IGtDdXJyZW50U3RyZWFtQ291bnQ7XG5BZ2VudC5rR3JhY2VmdWxseUNsb3NpbmcgPSBrR3JhY2VmdWxseUNsb3Npbmc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRBZ2VudCxcblx0Z2xvYmFsQWdlbnQ6IG5ldyBBZ2VudCgpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9qZXN0L2lzc3Vlcy8yNTQ5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9wcmVmZXItZ2xvYmFsL3VybFxuY29uc3Qge1VSTCwgdXJsVG9IdHRwT3B0aW9uc30gPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCByZXNvbHZlQUxQTiA9IHJlcXVpcmUoJ3Jlc29sdmUtYWxwbicpO1xuY29uc3QgUXVpY2tMUlUgPSByZXF1aXJlKCdxdWljay1scnUnKTtcbmNvbnN0IHtBZ2VudCwgZ2xvYmFsQWdlbnR9ID0gcmVxdWlyZSgnLi9hZ2VudC5qcycpO1xuY29uc3QgSHR0cDJDbGllbnRSZXF1ZXN0ID0gcmVxdWlyZSgnLi9jbGllbnQtcmVxdWVzdC5qcycpO1xuY29uc3QgY2FsY3VsYXRlU2VydmVyTmFtZSA9IHJlcXVpcmUoJy4vdXRpbHMvY2FsY3VsYXRlLXNlcnZlci1uYW1lLmpzJyk7XG5jb25zdCBkZWxheUFzeW5jRGVzdHJveSA9IHJlcXVpcmUoJy4vdXRpbHMvZGVsYXktYXN5bmMtZGVzdHJveS5qcycpO1xuXG5jb25zdCBjYWNoZSA9IG5ldyBRdWlja0xSVSh7bWF4U2l6ZTogMTAwfSk7XG5jb25zdCBxdWV1ZSA9IG5ldyBNYXAoKTtcblxuY29uc3QgaW5zdGFsbFNvY2tldCA9IChhZ2VudCwgc29ja2V0LCBvcHRpb25zKSA9PiB7XG5cdHNvY2tldC5faHR0cE1lc3NhZ2UgPSB7c2hvdWxkS2VlcEFsaXZlOiB0cnVlfTtcblxuXHRjb25zdCBvbkZyZWUgPSAoKSA9PiB7XG5cdFx0YWdlbnQuZW1pdCgnZnJlZScsIHNvY2tldCwgb3B0aW9ucyk7XG5cdH07XG5cblx0c29ja2V0Lm9uKCdmcmVlJywgb25GcmVlKTtcblxuXHRjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuXHRcdGFnZW50LnJlbW92ZVNvY2tldChzb2NrZXQsIG9wdGlvbnMpO1xuXHR9O1xuXG5cdHNvY2tldC5vbignY2xvc2UnLCBvbkNsb3NlKTtcblxuXHRjb25zdCBvblRpbWVvdXQgPSAoKSA9PiB7XG5cdFx0Y29uc3Qge2ZyZWVTb2NrZXRzfSA9IGFnZW50O1xuXG5cdFx0Zm9yIChjb25zdCBzb2NrZXRzIG9mIE9iamVjdC52YWx1ZXMoZnJlZVNvY2tldHMpKSB7XG5cdFx0XHRpZiAoc29ja2V0cy5pbmNsdWRlcyhzb2NrZXQpKSB7XG5cdFx0XHRcdHNvY2tldC5kZXN0cm95KCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0c29ja2V0Lm9uKCd0aW1lb3V0Jywgb25UaW1lb3V0KTtcblxuXHRjb25zdCBvblJlbW92ZSA9ICgpID0+IHtcblx0XHRhZ2VudC5yZW1vdmVTb2NrZXQoc29ja2V0LCBvcHRpb25zKTtcblx0XHRzb2NrZXQub2ZmKCdjbG9zZScsIG9uQ2xvc2UpO1xuXHRcdHNvY2tldC5vZmYoJ2ZyZWUnLCBvbkZyZWUpO1xuXHRcdHNvY2tldC5vZmYoJ3RpbWVvdXQnLCBvblRpbWVvdXQpO1xuXHRcdHNvY2tldC5vZmYoJ2FnZW50UmVtb3ZlJywgb25SZW1vdmUpO1xuXHR9O1xuXG5cdHNvY2tldC5vbignYWdlbnRSZW1vdmUnLCBvblJlbW92ZSk7XG5cblx0YWdlbnQuZW1pdCgnZnJlZScsIHNvY2tldCwgb3B0aW9ucyk7XG59O1xuXG5jb25zdCBjcmVhdGVSZXNvbHZlUHJvdG9jb2wgPSAoY2FjaGUsIHF1ZXVlID0gbmV3IE1hcCgpLCBjb25uZWN0ID0gdW5kZWZpbmVkKSA9PiB7XG5cdHJldHVybiBhc3luYyBvcHRpb25zID0+IHtcblx0XHRjb25zdCBuYW1lID0gYCR7b3B0aW9ucy5ob3N0fToke29wdGlvbnMucG9ydH06JHtvcHRpb25zLkFMUE5Qcm90b2NvbHMuc29ydCgpfWA7XG5cblx0XHRpZiAoIWNhY2hlLmhhcyhuYW1lKSkge1xuXHRcdFx0aWYgKHF1ZXVlLmhhcyhuYW1lKSkge1xuXHRcdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCBxdWV1ZS5nZXQobmFtZSk7XG5cdFx0XHRcdHJldHVybiB7YWxwblByb3RvY29sOiByZXN1bHQuYWxwblByb3RvY29sfTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qge3BhdGh9ID0gb3B0aW9ucztcblx0XHRcdG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcblxuXHRcdFx0Y29uc3QgcmVzdWx0UHJvbWlzZSA9IHJlc29sdmVBTFBOKG9wdGlvbnMsIGNvbm5lY3QpO1xuXHRcdFx0cXVldWUuc2V0KG5hbWUsIHJlc3VsdFByb21pc2UpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCByZXN1bHRQcm9taXNlO1xuXG5cdFx0XHRcdGNhY2hlLnNldChuYW1lLCByZXN1bHQuYWxwblByb3RvY29sKTtcblx0XHRcdFx0cXVldWUuZGVsZXRlKG5hbWUpO1xuXG5cdFx0XHRcdG9wdGlvbnMucGF0aCA9IHBhdGg7XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdHF1ZXVlLmRlbGV0ZShuYW1lKTtcblxuXHRcdFx0XHRvcHRpb25zLnBhdGggPSBwYXRoO1xuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7YWxwblByb3RvY29sOiBjYWNoZS5nZXQobmFtZSl9O1xuXHR9O1xufTtcblxuY29uc3QgZGVmYXVsdFJlc29sdmVQcm90b2NvbCA9IGNyZWF0ZVJlc29sdmVQcm90b2NvbChjYWNoZSwgcXVldWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jIChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcblx0aWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcblx0XHRpbnB1dCA9IHVybFRvSHR0cE9wdGlvbnMobmV3IFVSTChpbnB1dCkpO1xuXHR9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgVVJMKSB7XG5cdFx0aW5wdXQgPSB1cmxUb0h0dHBPcHRpb25zKGlucHV0KTtcblx0fSBlbHNlIHtcblx0XHRpbnB1dCA9IHsuLi5pbnB1dH07XG5cdH1cblxuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gKG9wdGlvbnMsIGNhbGxiYWNrKVxuXHRcdGNhbGxiYWNrID0gb3B0aW9ucztcblx0XHRvcHRpb25zID0gaW5wdXQ7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gKGlucHV0LCBvcHRpb25zLCBjYWxsYmFjaylcblx0XHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbihpbnB1dCwgb3B0aW9ucyk7XG5cdH1cblxuXHRvcHRpb25zLkFMUE5Qcm90b2NvbHMgPSBvcHRpb25zLkFMUE5Qcm90b2NvbHMgfHwgWydoMicsICdodHRwLzEuMSddO1xuXG5cdGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLkFMUE5Qcm90b2NvbHMpIHx8IG9wdGlvbnMuQUxQTlByb3RvY29scy5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgQUxQTlByb3RvY29sc2Agb3B0aW9uIG11c3QgYmUgYW4gQXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgZW50cnknKTtcblx0fVxuXG5cdG9wdGlvbnMucHJvdG9jb2wgPSBvcHRpb25zLnByb3RvY29sIHx8ICdodHRwczonO1xuXHRjb25zdCBpc0h0dHBzID0gb3B0aW9ucy5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG5cblx0b3B0aW9ucy5ob3N0ID0gb3B0aW9ucy5ob3N0bmFtZSB8fCBvcHRpb25zLmhvc3QgfHwgJ2xvY2FsaG9zdCc7XG5cdG9wdGlvbnMuc2Vzc2lvbiA9IG9wdGlvbnMudGxzU2Vzc2lvbjtcblx0b3B0aW9ucy5zZXJ2ZXJuYW1lID0gb3B0aW9ucy5zZXJ2ZXJuYW1lIHx8IGNhbGN1bGF0ZVNlcnZlck5hbWUoKG9wdGlvbnMuaGVhZGVycyAmJiBvcHRpb25zLmhlYWRlcnMuaG9zdCkgfHwgb3B0aW9ucy5ob3N0KTtcblx0b3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5wb3J0IHx8IChpc0h0dHBzID8gNDQzIDogODApO1xuXHRvcHRpb25zLl9kZWZhdWx0QWdlbnQgPSBpc0h0dHBzID8gaHR0cHMuZ2xvYmFsQWdlbnQgOiBodHRwLmdsb2JhbEFnZW50O1xuXG5cdGNvbnN0IHJlc29sdmVQcm90b2NvbCA9IG9wdGlvbnMucmVzb2x2ZVByb3RvY29sIHx8IGRlZmF1bHRSZXNvbHZlUHJvdG9jb2w7XG5cblx0Ly8gTm90ZTogV2UgZG9uJ3Qgc3VwcG9ydCBgaDJzZXNzaW9uYCBoZXJlXG5cblx0bGV0IHthZ2VudH0gPSBvcHRpb25zO1xuXHRpZiAoYWdlbnQgIT09IHVuZGVmaW5lZCAmJiBhZ2VudCAhPT0gZmFsc2UgJiYgYWdlbnQuY29uc3RydWN0b3IubmFtZSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgb3B0aW9ucy5hZ2VudGAgY2FuIGJlIG9ubHkgYW4gb2JqZWN0IGBodHRwYCwgYGh0dHBzYCBvciBgaHR0cDJgIHByb3BlcnRpZXMnKTtcblx0fVxuXG5cdGlmIChpc0h0dHBzKSB7XG5cdFx0b3B0aW9ucy5yZXNvbHZlU29ja2V0ID0gdHJ1ZTtcblxuXHRcdGxldCB7c29ja2V0LCBhbHBuUHJvdG9jb2wsIHRpbWVvdXR9ID0gYXdhaXQgcmVzb2x2ZVByb3RvY29sKG9wdGlvbnMpO1xuXG5cdFx0aWYgKHRpbWVvdXQpIHtcblx0XHRcdGlmIChzb2NrZXQpIHtcblx0XHRcdFx0c29ja2V0LmRlc3Ryb3koKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFRpbWVkIG91dCByZXNvbHZpbmcgQUxQTjogJHtvcHRpb25zLnRpbWVvdXR9IG1zYCk7XG5cdFx0XHRlcnJvci5jb2RlID0gJ0VUSU1FRE9VVCc7XG5cdFx0XHRlcnJvci5tcyA9IG9wdGlvbnMudGltZW91dDtcblxuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuJ3QgYWNjZXB0IGN1c3RvbSBgY3JlYXRlQ29ubmVjdGlvbmAgYmVjYXVzZSB0aGUgQVBJIGlzIGRpZmZlcmVudCBmb3IgSFRUUC8yXG5cdFx0aWYgKHNvY2tldCAmJiBvcHRpb25zLmNyZWF0ZUNvbm5lY3Rpb24pIHtcblx0XHRcdHNvY2tldC5kZXN0cm95KCk7XG5cdFx0XHRzb2NrZXQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIG9wdGlvbnMucmVzb2x2ZVNvY2tldDtcblxuXHRcdGNvbnN0IGlzSHR0cDIgPSBhbHBuUHJvdG9jb2wgPT09ICdoMic7XG5cblx0XHRpZiAoYWdlbnQpIHtcblx0XHRcdGFnZW50ID0gaXNIdHRwMiA/IGFnZW50Lmh0dHAyIDogYWdlbnQuaHR0cHM7XG5cdFx0XHRvcHRpb25zLmFnZW50ID0gYWdlbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKGFnZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGFnZW50ID0gaXNIdHRwMiA/IGdsb2JhbEFnZW50IDogaHR0cHMuZ2xvYmFsQWdlbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKHNvY2tldCkge1xuXHRcdFx0aWYgKGFnZW50ID09PSBmYWxzZSkge1xuXHRcdFx0XHRzb2NrZXQuZGVzdHJveSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgZGVmYXVsdENyZWF0ZUNvbm5lY3Rpb24gPSAoaXNIdHRwMiA/IEFnZW50IDogaHR0cHMuQWdlbnQpLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uO1xuXG5cdFx0XHRcdGlmIChhZ2VudC5jcmVhdGVDb25uZWN0aW9uID09PSBkZWZhdWx0Q3JlYXRlQ29ubmVjdGlvbikge1xuXHRcdFx0XHRcdGlmIChpc0h0dHAyKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zLl9yZXVzZVNvY2tldCA9IHNvY2tldDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aW5zdGFsbFNvY2tldChhZ2VudCwgc29ja2V0LCBvcHRpb25zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c29ja2V0LmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0h0dHAyKSB7XG5cdFx0XHRyZXR1cm4gZGVsYXlBc3luY0Rlc3Ryb3kobmV3IEh0dHAyQ2xpZW50UmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaykpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChhZ2VudCkge1xuXHRcdG9wdGlvbnMuYWdlbnQgPSBhZ2VudC5odHRwO1xuXHR9XG5cblx0cmV0dXJuIGRlbGF5QXN5bmNEZXN0cm95KGh0dHAucmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaykpO1xufTtcblxubW9kdWxlLmV4cG9ydHMucHJvdG9jb2xDYWNoZSA9IGNhY2hlO1xubW9kdWxlLmV4cG9ydHMucmVzb2x2ZVByb3RvY29sID0gZGVmYXVsdFJlc29sdmVQcm90b2NvbDtcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZVJlc29sdmVQcm90b2NvbCA9IGNyZWF0ZVJlc29sdmVQcm90b2NvbDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svamVzdC9pc3N1ZXMvMjU0OVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvcHJlZmVyLWdsb2JhbC91cmxcbmNvbnN0IHtVUkwsIHVybFRvSHR0cE9wdGlvbnN9ID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBodHRwMiA9IHJlcXVpcmUoJ2h0dHAyJyk7XG5jb25zdCB7V3JpdGFibGV9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7QWdlbnQsIGdsb2JhbEFnZW50fSA9IHJlcXVpcmUoJy4vYWdlbnQuanMnKTtcbmNvbnN0IEluY29taW5nTWVzc2FnZSA9IHJlcXVpcmUoJy4vaW5jb21pbmctbWVzc2FnZS5qcycpO1xuY29uc3QgcHJveHlFdmVudHMgPSByZXF1aXJlKCcuL3V0aWxzL3Byb3h5LWV2ZW50cy5qcycpO1xuY29uc3Qge1xuXHRFUlJfSU5WQUxJRF9BUkdfVFlQRSxcblx0RVJSX0lOVkFMSURfUFJPVE9DT0wsXG5cdEVSUl9IVFRQX0hFQURFUlNfU0VOVFxufSA9IHJlcXVpcmUoJy4vdXRpbHMvZXJyb3JzLmpzJyk7XG5jb25zdCB2YWxpZGF0ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL3V0aWxzL3ZhbGlkYXRlLWhlYWRlci1uYW1lLmpzJyk7XG5jb25zdCB2YWxpZGF0ZUhlYWRlclZhbHVlID0gcmVxdWlyZSgnLi91dGlscy92YWxpZGF0ZS1oZWFkZXItdmFsdWUuanMnKTtcbmNvbnN0IHByb3h5U29ja2V0SGFuZGxlciA9IHJlcXVpcmUoJy4vdXRpbHMvcHJveHktc29ja2V0LWhhbmRsZXIuanMnKTtcblxuY29uc3Qge1xuXHRIVFRQMl9IRUFERVJfU1RBVFVTLFxuXHRIVFRQMl9IRUFERVJfTUVUSE9ELFxuXHRIVFRQMl9IRUFERVJfUEFUSCxcblx0SFRUUDJfSEVBREVSX0FVVEhPUklUWSxcblx0SFRUUDJfTUVUSE9EX0NPTk5FQ1Rcbn0gPSBodHRwMi5jb25zdGFudHM7XG5cbmNvbnN0IGtIZWFkZXJzID0gU3ltYm9sKCdoZWFkZXJzJyk7XG5jb25zdCBrT3JpZ2luID0gU3ltYm9sKCdvcmlnaW4nKTtcbmNvbnN0IGtTZXNzaW9uID0gU3ltYm9sKCdzZXNzaW9uJyk7XG5jb25zdCBrT3B0aW9ucyA9IFN5bWJvbCgnb3B0aW9ucycpO1xuY29uc3Qga0ZsdXNoZWRIZWFkZXJzID0gU3ltYm9sKCdmbHVzaGVkSGVhZGVycycpO1xuY29uc3Qga0pvYnMgPSBTeW1ib2woJ2pvYnMnKTtcbmNvbnN0IGtQZW5kaW5nQWdlbnRQcm9taXNlID0gU3ltYm9sKCdwZW5kaW5nQWdlbnRQcm9taXNlJyk7XG5cbmNsYXNzIENsaWVudFJlcXVlc3QgZXh0ZW5kcyBXcml0YWJsZSB7XG5cdGNvbnN0cnVjdG9yKGlucHV0LCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdHN1cGVyKHtcblx0XHRcdGF1dG9EZXN0cm95OiBmYWxzZSxcblx0XHRcdGVtaXRDbG9zZTogZmFsc2Vcblx0XHR9KTtcblxuXHRcdGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpbnB1dCA9IHVybFRvSHR0cE9wdGlvbnMobmV3IFVSTChpbnB1dCkpO1xuXHRcdH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBVUkwpIHtcblx0XHRcdGlucHV0ID0gdXJsVG9IdHRwT3B0aW9ucyhpbnB1dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlucHV0ID0gey4uLmlucHV0fTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyAob3B0aW9ucywgY2FsbGJhY2spXG5cdFx0XHRjYWxsYmFjayA9IG9wdGlvbnM7XG5cdFx0XHRvcHRpb25zID0gaW5wdXQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spXG5cdFx0XHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbihpbnB1dCwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuaDJzZXNzaW9uKSB7XG5cdFx0XHR0aGlzW2tTZXNzaW9uXSA9IG9wdGlvbnMuaDJzZXNzaW9uO1xuXG5cdFx0XHRpZiAodGhpc1trU2Vzc2lvbl0uZGVzdHJveWVkKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIHNlc3Npb24gaGFzIGJlZW4gY2xvc2VkIGFscmVhZHknKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5wcm90b2NvbCA9IHRoaXNba1Nlc3Npb25dLnNvY2tldC5lbmNyeXB0ZWQgPyAnaHR0cHM6JyA6ICdodHRwOic7XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLmFnZW50ID09PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5hZ2VudCA9IG5ldyBBZ2VudCh7bWF4RW1wdHlTZXNzaW9uczogMH0pO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuYWdlbnQgPT09ICd1bmRlZmluZWQnIHx8IG9wdGlvbnMuYWdlbnQgPT09IG51bGwpIHtcblx0XHRcdHRoaXMuYWdlbnQgPSBnbG9iYWxBZ2VudDtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmFnZW50LnJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMuYWdlbnQgPSBvcHRpb25zLmFnZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMuYWdlbnQnLCBbJ2h0dHAyd3JhcHBlci5BZ2VudC1saWtlIE9iamVjdCcsICd1bmRlZmluZWQnLCAnZmFsc2UnXSwgb3B0aW9ucy5hZ2VudCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuYWdlbnQpIHtcblx0XHRcdHRoaXMucHJvdG9jb2wgPSB0aGlzLmFnZW50LnByb3RvY29sO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnByb3RvY29sICYmIG9wdGlvbnMucHJvdG9jb2wgIT09IHRoaXMucHJvdG9jb2wpIHtcblx0XHRcdHRocm93IG5ldyBFUlJfSU5WQUxJRF9QUk9UT0NPTChvcHRpb25zLnByb3RvY29sLCB0aGlzLnByb3RvY29sKTtcblx0XHR9XG5cblx0XHRpZiAoIW9wdGlvbnMucG9ydCkge1xuXHRcdFx0b3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5kZWZhdWx0UG9ydCB8fCAodGhpcy5hZ2VudCAmJiB0aGlzLmFnZW50LmRlZmF1bHRQb3J0KSB8fCA0NDM7XG5cdFx0fVxuXG5cdFx0b3B0aW9ucy5ob3N0ID0gb3B0aW9ucy5ob3N0bmFtZSB8fCBvcHRpb25zLmhvc3QgfHwgJ2xvY2FsaG9zdCc7XG5cblx0XHQvLyBVbnVzZWRcblx0XHRkZWxldGUgb3B0aW9ucy5ob3N0bmFtZTtcblxuXHRcdGNvbnN0IHt0aW1lb3V0fSA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucy50aW1lb3V0ID0gdW5kZWZpbmVkO1xuXG5cdFx0dGhpc1trSGVhZGVyc10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdHRoaXNba0pvYnNdID0gW107XG5cblx0XHR0aGlzW2tQZW5kaW5nQWdlbnRQcm9taXNlXSA9IHVuZGVmaW5lZDtcblxuXHRcdHRoaXMuc29ja2V0ID0gbnVsbDtcblx0XHR0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuXG5cdFx0dGhpcy5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJztcblxuXHRcdGlmICghKHRoaXMubWV0aG9kID09PSAnQ09OTkVDVCcgJiYgKG9wdGlvbnMucGF0aCA9PT0gJy8nIHx8IG9wdGlvbnMucGF0aCA9PT0gdW5kZWZpbmVkKSkpIHtcblx0XHRcdHRoaXMucGF0aCA9IG9wdGlvbnMucGF0aDtcblx0XHR9XG5cblx0XHR0aGlzLnJlcyA9IG51bGw7XG5cdFx0dGhpcy5hYm9ydGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZXVzZWRTb2NrZXQgPSBmYWxzZTtcblxuXHRcdGNvbnN0IHtoZWFkZXJzfSA9IG9wdGlvbnM7XG5cdFx0aWYgKGhlYWRlcnMpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cblx0XHRcdGZvciAoY29uc3QgaGVhZGVyIGluIGhlYWRlcnMpIHtcblx0XHRcdFx0dGhpcy5zZXRIZWFkZXIoaGVhZGVyLCBoZWFkZXJzW2hlYWRlcl0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmF1dGggJiYgISgnYXV0aG9yaXphdGlvbicgaW4gdGhpc1trSGVhZGVyc10pKSB7XG5cdFx0XHR0aGlzW2tIZWFkZXJzXS5hdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShvcHRpb25zLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcblx0XHR9XG5cblx0XHRvcHRpb25zLnNlc3Npb24gPSBvcHRpb25zLnRsc1Nlc3Npb247XG5cdFx0b3B0aW9ucy5wYXRoID0gb3B0aW9ucy5zb2NrZXRQYXRoO1xuXG5cdFx0dGhpc1trT3B0aW9uc10gPSBvcHRpb25zO1xuXG5cdFx0Ly8gQ2xpZW50cyB0aGF0IGdlbmVyYXRlIEhUVFAvMiByZXF1ZXN0cyBkaXJlY3RseSBTSE9VTEQgdXNlIHRoZSA6YXV0aG9yaXR5IHBzZXVkby1oZWFkZXIgZmllbGQgaW5zdGVhZCBvZiB0aGUgSG9zdCBoZWFkZXIgZmllbGQuXG5cdFx0dGhpc1trT3JpZ2luXSA9IG5ldyBVUkwoYCR7dGhpcy5wcm90b2NvbH0vLyR7b3B0aW9ucy5zZXJ2ZXJuYW1lIHx8IG9wdGlvbnMuaG9zdH06JHtvcHRpb25zLnBvcnR9YCk7XG5cblx0XHQvLyBBIHNvY2tldCBpcyBiZWluZyByZXVzZWRcblx0XHRjb25zdCByZXVzZVNvY2tldCA9IG9wdGlvbnMuX3JldXNlU29ja2V0O1xuXHRcdGlmIChyZXVzZVNvY2tldCkge1xuXHRcdFx0b3B0aW9ucy5jcmVhdGVDb25uZWN0aW9uID0gKC4uLmFyZ3MpID0+IHtcblx0XHRcdFx0aWYgKHJldXNlU29ja2V0LmRlc3Ryb3llZCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFnZW50LmNyZWF0ZUNvbm5lY3Rpb24oLi4uYXJncyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcmV1c2VTb2NrZXQ7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tdGhlblxuXHRcdFx0dGhpcy5hZ2VudC5nZXRTZXNzaW9uKHRoaXNba09yaWdpbl0sIHRoaXNba09wdGlvbnNdKS5jYXRjaCgoKSA9PiB7fSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRpbWVvdXQpIHtcblx0XHRcdHRoaXMuc2V0VGltZW91dCh0aW1lb3V0KTtcblx0XHR9XG5cblx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdHRoaXMub25jZSgncmVzcG9uc2UnLCBjYWxsYmFjayk7XG5cdFx0fVxuXG5cdFx0dGhpc1trRmx1c2hlZEhlYWRlcnNdID0gZmFsc2U7XG5cdH1cblxuXHRnZXQgbWV0aG9kKCkge1xuXHRcdHJldHVybiB0aGlzW2tIZWFkZXJzXVtIVFRQMl9IRUFERVJfTUVUSE9EXTtcblx0fVxuXG5cdHNldCBtZXRob2QodmFsdWUpIHtcblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdHRoaXNba0hlYWRlcnNdW0hUVFAyX0hFQURFUl9NRVRIT0RdID0gdmFsdWUudG9VcHBlckNhc2UoKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRjb25zdCBoZWFkZXIgPSB0aGlzLm1ldGhvZCA9PT0gJ0NPTk5FQ1QnID8gSFRUUDJfSEVBREVSX0FVVEhPUklUWSA6IEhUVFAyX0hFQURFUl9QQVRIO1xuXG5cdFx0cmV0dXJuIHRoaXNba0hlYWRlcnNdW2hlYWRlcl07XG5cdH1cblxuXHRzZXQgcGF0aCh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0Y29uc3QgaGVhZGVyID0gdGhpcy5tZXRob2QgPT09ICdDT05ORUNUJyA/IEhUVFAyX0hFQURFUl9BVVRIT1JJVFkgOiBIVFRQMl9IRUFERVJfUEFUSDtcblxuXHRcdFx0dGhpc1trSGVhZGVyc11baGVhZGVyXSA9IHZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdGdldCBob3N0KCkge1xuXHRcdHJldHVybiB0aGlzW2tPcmlnaW5dLmhvc3RuYW1lO1xuXHR9XG5cblx0c2V0IGhvc3QoX3ZhbHVlKSB7XG5cdFx0Ly8gRG8gbm90aGluZyBhcyB0aGlzIGlzIHJlYWQgb25seS5cblx0fVxuXG5cdGdldCBfbXVzdE5vdEhhdmVBQm9keSgpIHtcblx0XHRyZXR1cm4gdGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcgfHwgdGhpcy5tZXRob2QgPT09ICdERUxFVEUnO1xuXHR9XG5cblx0X3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi82NTRkZjA5YWUwYzVlMTdkMWI1MmE5MDBhNTQ1ZjA2NjRkOGM3NjI3L2xpYi9pbnRlcm5hbC9odHRwMi91dGlsLmpzI0wxNDgtTDE1NlxuXHRcdGlmICh0aGlzLl9tdXN0Tm90SGF2ZUFCb2R5KSB7XG5cdFx0XHRjYWxsYmFjayhuZXcgRXJyb3IoJ1RoZSBHRVQsIEhFQUQgYW5kIERFTEVURSBtZXRob2RzIG11c3QgTk9UIGhhdmUgYSBib2R5JykpO1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQ6IE5vZGUuanMgMTIgdGhyb3dzIGRpcmVjdGx5ICovXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5mbHVzaEhlYWRlcnMoKTtcblxuXHRcdGNvbnN0IGNhbGxXcml0ZSA9ICgpID0+IHRoaXMuX3JlcXVlc3Qud3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QpIHtcblx0XHRcdGNhbGxXcml0ZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzW2tKb2JzXS5wdXNoKGNhbGxXcml0ZSk7XG5cdFx0fVxuXHR9XG5cblx0X2ZpbmFsKGNhbGxiYWNrKSB7XG5cdFx0dGhpcy5mbHVzaEhlYWRlcnMoKTtcblxuXHRcdGNvbnN0IGNhbGxFbmQgPSAoKSA9PiB7XG5cdFx0XHQvLyBGb3IgR0VULCBIRUFEIGFuZCBERUxFVEUgYW5kIENPTk5FQ1Rcblx0XHRcdGlmICh0aGlzLl9tdXN0Tm90SGF2ZUFCb2R5IHx8IHRoaXMubWV0aG9kID09PSAnQ09OTkVDVCcpIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmVuZChjYWxsYmFjayk7XG5cdFx0fTtcblxuXHRcdGlmICh0aGlzLl9yZXF1ZXN0KSB7XG5cdFx0XHRjYWxsRW5kKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXNba0pvYnNdLnB1c2goY2FsbEVuZCk7XG5cdFx0fVxuXHR9XG5cblx0YWJvcnQoKSB7XG5cdFx0aWYgKHRoaXMucmVzICYmIHRoaXMucmVzLmNvbXBsZXRlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmFib3J0ZWQpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpcy5lbWl0KCdhYm9ydCcpKTtcblx0XHR9XG5cblx0XHR0aGlzLmFib3J0ZWQgPSB0cnVlO1xuXG5cdFx0dGhpcy5kZXN0cm95KCk7XG5cdH1cblxuXHRhc3luYyBfZGVzdHJveShlcnJvciwgY2FsbGJhY2spIHtcblx0XHRpZiAodGhpcy5yZXMpIHtcblx0XHRcdHRoaXMucmVzLl9kdW1wKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QuZGVzdHJveSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblx0XHRcdFx0dGhpcy5lbWl0KCdjbG9zZScpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IHRoaXNba1BlbmRpbmdBZ2VudFByb21pc2VdO1xuXHRcdH0gY2F0Y2ggKGludGVybmFsRXJyb3IpIHtcblx0XHRcdGlmICh0aGlzLmFib3J0ZWQpIHtcblx0XHRcdFx0ZXJyb3IgPSBpbnRlcm5hbEVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNhbGxiYWNrKGVycm9yKTtcblx0fVxuXG5cdGFzeW5jIGZsdXNoSGVhZGVycygpIHtcblx0XHRpZiAodGhpc1trRmx1c2hlZEhlYWRlcnNdIHx8IHRoaXMuZGVzdHJveWVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpc1trRmx1c2hlZEhlYWRlcnNdID0gdHJ1ZTtcblxuXHRcdGNvbnN0IGlzQ29ubmVjdE1ldGhvZCA9IHRoaXMubWV0aG9kID09PSBIVFRQMl9NRVRIT0RfQ09OTkVDVDtcblxuXHRcdC8vIFRoZSByZWFsIG1hZ2ljIGlzIGhlcmVcblx0XHRjb25zdCBvblN0cmVhbSA9IHN0cmVhbSA9PiB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gc3RyZWFtO1xuXG5cdFx0XHRpZiAodGhpcy5kZXN0cm95ZWQpIHtcblx0XHRcdFx0c3RyZWFtLmRlc3Ryb3koKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3J3YXJkcyBgdGltZW91dGAsIGBjb250aW51ZWAsIGBjbG9zZWAgYW5kIGBlcnJvcmAgZXZlbnRzIHRvIHRoaXMgaW5zdGFuY2UuXG5cdFx0XHRpZiAoIWlzQ29ubmVjdE1ldGhvZCkge1xuXHRcdFx0XHQvLyBUT0RPOiBTaG91bGQgd2UgcHJveHkgYGNsb3NlYCBoZXJlP1xuXHRcdFx0XHRwcm94eUV2ZW50cyhzdHJlYW0sIHRoaXMsIFsndGltZW91dCcsICdjb250aW51ZSddKTtcblx0XHRcdH1cblxuXHRcdFx0c3RyZWFtLm9uY2UoJ2Vycm9yJywgZXJyb3IgPT4ge1xuXHRcdFx0XHR0aGlzLmRlc3Ryb3koZXJyb3IpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHN0cmVhbS5vbmNlKCdhYm9ydGVkJywgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB7cmVzfSA9IHRoaXM7XG5cdFx0XHRcdGlmIChyZXMpIHtcblx0XHRcdFx0XHRyZXMuYWJvcnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0cmVzLmVtaXQoJ2Fib3J0ZWQnKTtcblx0XHRcdFx0XHRyZXMuZGVzdHJveSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuZGVzdHJveShuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgYWJvcnRlZCB0aGUgSFRUUC8yIHN0cmVhbScpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGNvbnN0IG9uUmVzcG9uc2UgPSAoaGVhZGVycywgZmxhZ3MsIHJhd0hlYWRlcnMpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2Ugd2VyZSB0byBlbWl0IHJhdyByZXF1ZXN0IHN0cmVhbSwgaXQgd291bGQgYmUgYXMgZmFzdCBhcyB0aGUgbmF0aXZlIGFwcHJvYWNoLlxuXHRcdFx0XHQvLyBOb3RlIHRoYXQgd3JhcHBpbmcgdGhlIHJhdyBzdHJlYW0gaW4gYSBQcm94eSBpbnN0YW5jZSB3b24ndCBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZSAoYWxyZWFkeSB0ZXN0ZWQgaXQpLlxuXHRcdFx0XHRjb25zdCByZXNwb25zZSA9IG5ldyBJbmNvbWluZ01lc3NhZ2UodGhpcy5zb2NrZXQsIHN0cmVhbS5yZWFkYWJsZUhpZ2hXYXRlck1hcmspO1xuXHRcdFx0XHR0aGlzLnJlcyA9IHJlc3BvbnNlO1xuXG5cdFx0XHRcdC8vIFVuZG9jdW1lbnRlZCwgYnV0IGl0IGlzIHVzZWQgYnkgYGNhY2hlYWJsZS1yZXF1ZXN0YFxuXHRcdFx0XHRyZXNwb25zZS51cmwgPSBgJHt0aGlzW2tPcmlnaW5dLm9yaWdpbn0ke3RoaXMucGF0aH1gO1xuXG5cdFx0XHRcdHJlc3BvbnNlLnJlcSA9IHRoaXM7XG5cdFx0XHRcdHJlc3BvbnNlLnN0YXR1c0NvZGUgPSBoZWFkZXJzW0hUVFAyX0hFQURFUl9TVEFUVVNdO1xuXHRcdFx0XHRyZXNwb25zZS5oZWFkZXJzID0gaGVhZGVycztcblx0XHRcdFx0cmVzcG9uc2UucmF3SGVhZGVycyA9IHJhd0hlYWRlcnM7XG5cblx0XHRcdFx0cmVzcG9uc2Uub25jZSgnZW5kJywgKCkgPT4ge1xuXHRcdFx0XHRcdHJlc3BvbnNlLmNvbXBsZXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vIEhhcyBubyBlZmZlY3QsIGp1c3QgYmUgY29uc2lzdGVudCB3aXRoIHRoZSBOb2RlLmpzIGJlaGF2aW9yXG5cdFx0XHRcdFx0cmVzcG9uc2Uuc29ja2V0ID0gbnVsbDtcblx0XHRcdFx0XHRyZXNwb25zZS5jb25uZWN0aW9uID0gbnVsbDtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKGlzQ29ubmVjdE1ldGhvZCkge1xuXHRcdFx0XHRcdHJlc3BvbnNlLnVwZ3JhZGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Ly8gVGhlIEhUVFAxIEFQSSBzYXlzIHRoZSBzb2NrZXQgaXMgZGV0YWNoZWQgaGVyZSxcblx0XHRcdFx0XHQvLyBidXQgd2UgY2FuJ3QgZG8gdGhhdCBzbyB3ZSBwYXNzIHRoZSBvcmlnaW5hbCBIVFRQMiByZXF1ZXN0LlxuXHRcdFx0XHRcdGlmICh0aGlzLmVtaXQoJ2Nvbm5lY3QnLCByZXNwb25zZSwgc3RyZWFtLCBCdWZmZXIuYWxsb2MoMCkpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVtaXQoJ2Nsb3NlJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIE5vIGxpc3RlbmVycyBhdHRhY2hlZCwgZGVzdHJveSB0aGUgb3JpZ2luYWwgcmVxdWVzdC5cblx0XHRcdFx0XHRcdHN0cmVhbS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEZvcndhcmRzIGRhdGFcblx0XHRcdFx0XHRzdHJlYW0ub24oJ2RhdGEnLCBjaHVuayA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoIXJlc3BvbnNlLl9kdW1wZWQgJiYgIXJlc3BvbnNlLnB1c2goY2h1bmspKSB7XG5cdFx0XHRcdFx0XHRcdHN0cmVhbS5wYXVzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0c3RyZWFtLm9uY2UoJ2VuZCcsICgpID0+IHtcblx0XHRcdFx0XHRcdGlmICghdGhpcy5hYm9ydGVkKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlLnB1c2gobnVsbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRpZiAoIXRoaXMuZW1pdCgncmVzcG9uc2UnLCByZXNwb25zZSkpIHtcblx0XHRcdFx0XHRcdC8vIE5vIGxpc3RlbmVycyBhdHRhY2hlZCwgZHVtcCB0aGUgcmVzcG9uc2UuXG5cdFx0XHRcdFx0XHRyZXNwb25zZS5fZHVtcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gVGhpcyBldmVudCB0ZWxscyB3ZSBhcmUgcmVhZHkgdG8gbGlzdGVuIGZvciB0aGUgZGF0YS5cblx0XHRcdHN0cmVhbS5vbmNlKCdyZXNwb25zZScsIG9uUmVzcG9uc2UpO1xuXG5cdFx0XHQvLyBFbWl0cyBgaW5mb3JtYXRpb25gIGV2ZW50XG5cdFx0XHRzdHJlYW0ub25jZSgnaGVhZGVycycsIGhlYWRlcnMgPT4gdGhpcy5lbWl0KCdpbmZvcm1hdGlvbicsIHtzdGF0dXNDb2RlOiBoZWFkZXJzW0hUVFAyX0hFQURFUl9TVEFUVVNdfSkpO1xuXG5cdFx0XHRzdHJlYW0ub25jZSgndHJhaWxlcnMnLCAodHJhaWxlcnMsIGZsYWdzLCByYXdUcmFpbGVycykgPT4ge1xuXHRcdFx0XHRjb25zdCB7cmVzfSA9IHRoaXM7XG5cblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80MTI1MVxuXHRcdFx0XHRpZiAocmVzID09PSBudWxsKSB7XG5cdFx0XHRcdFx0b25SZXNwb25zZSh0cmFpbGVycywgZmxhZ3MsIHJhd1RyYWlsZXJzKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBc3NpZ25zIHRyYWlsZXJzIHRvIHRoZSByZXNwb25zZSBvYmplY3QuXG5cdFx0XHRcdHJlcy50cmFpbGVycyA9IHRyYWlsZXJzO1xuXHRcdFx0XHRyZXMucmF3VHJhaWxlcnMgPSByYXdUcmFpbGVycztcblx0XHRcdH0pO1xuXG5cdFx0XHRzdHJlYW0ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHthYm9ydGVkLCByZXN9ID0gdGhpcztcblx0XHRcdFx0aWYgKHJlcykge1xuXHRcdFx0XHRcdGlmIChhYm9ydGVkKSB7XG5cdFx0XHRcdFx0XHRyZXMuYWJvcnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZXMuZW1pdCgnYWJvcnRlZCcpO1xuXHRcdFx0XHRcdFx0cmVzLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBmaW5pc2ggPSAoKSA9PiB7XG5cdFx0XHRcdFx0XHRyZXMuZW1pdCgnY2xvc2UnKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHR0aGlzLmVtaXQoJ2Nsb3NlJyk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmIChyZXMucmVhZGFibGUpIHtcblx0XHRcdFx0XHRcdHJlcy5vbmNlKCdlbmQnLCBmaW5pc2gpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmaW5pc2goKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG5cdFx0XHRcdFx0dGhpcy5kZXN0cm95KG5ldyBFcnJvcignVGhlIEhUVFAvMiBzdHJlYW0gaGFzIGJlZW4gZWFybHkgdGVybWluYXRlZCcpKTtcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ2Nsb3NlJyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdHRoaXMuZW1pdCgnY2xvc2UnKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLnNvY2tldCA9IG5ldyBQcm94eShzdHJlYW0sIHByb3h5U29ja2V0SGFuZGxlcik7XG5cblx0XHRcdGZvciAoY29uc3Qgam9iIG9mIHRoaXNba0pvYnNdKSB7XG5cdFx0XHRcdGpvYigpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzW2tKb2JzXS5sZW5ndGggPSAwO1xuXG5cdFx0XHR0aGlzLmVtaXQoJ3NvY2tldCcsIHRoaXMuc29ja2V0KTtcblx0XHR9O1xuXG5cdFx0aWYgKCEoSFRUUDJfSEVBREVSX0FVVEhPUklUWSBpbiB0aGlzW2tIZWFkZXJzXSkgJiYgIWlzQ29ubmVjdE1ldGhvZCkge1xuXHRcdFx0dGhpc1trSGVhZGVyc11bSFRUUDJfSEVBREVSX0FVVEhPUklUWV0gPSB0aGlzW2tPcmlnaW5dLmhvc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZXMgYSBIVFRQMiByZXF1ZXN0XG5cdFx0aWYgKHRoaXNba1Nlc3Npb25dKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRvblN0cmVhbSh0aGlzW2tTZXNzaW9uXS5yZXF1ZXN0KHRoaXNba0hlYWRlcnNdKSk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHR0aGlzLmRlc3Ryb3koZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnJldXNlZFNvY2tldCA9IHRydWU7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IHByb21pc2UgPSB0aGlzLmFnZW50LnJlcXVlc3QodGhpc1trT3JpZ2luXSwgdGhpc1trT3B0aW9uc10sIHRoaXNba0hlYWRlcnNdKTtcblx0XHRcdFx0dGhpc1trUGVuZGluZ0FnZW50UHJvbWlzZV0gPSBwcm9taXNlO1xuXG5cdFx0XHRcdG9uU3RyZWFtKGF3YWl0IHByb21pc2UpO1xuXG5cdFx0XHRcdHRoaXNba1BlbmRpbmdBZ2VudFByb21pc2VdID0gZmFsc2U7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHR0aGlzW2tQZW5kaW5nQWdlbnRQcm9taXNlXSA9IGZhbHNlO1xuXG5cdFx0XHRcdHRoaXMuZGVzdHJveShlcnJvcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Z2V0IGNvbm5lY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc29ja2V0O1xuXHR9XG5cblx0c2V0IGNvbm5lY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLnNvY2tldCA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0SGVhZGVyTmFtZXMoKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRoaXNba0hlYWRlcnNdKTtcblx0fVxuXG5cdGhhc0hlYWRlcihuYW1lKSB7XG5cdFx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuXHRcdFx0dGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCduYW1lJywgJ3N0cmluZycsIG5hbWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBCb29sZWFuKHRoaXNba0hlYWRlcnNdW25hbWUudG9Mb3dlckNhc2UoKV0pO1xuXHR9XG5cblx0Z2V0SGVhZGVyKG5hbWUpIHtcblx0XHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ25hbWUnLCAnc3RyaW5nJywgbmFtZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXNba0hlYWRlcnNdW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdH1cblxuXHRnZXQgaGVhZGVyc1NlbnQoKSB7XG5cdFx0cmV0dXJuIHRoaXNba0ZsdXNoZWRIZWFkZXJzXTtcblx0fVxuXG5cdHJlbW92ZUhlYWRlcihuYW1lKSB7XG5cdFx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuXHRcdFx0dGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCduYW1lJywgJ3N0cmluZycsIG5hbWUpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmhlYWRlcnNTZW50KSB7XG5cdFx0XHR0aHJvdyBuZXcgRVJSX0hUVFBfSEVBREVSU19TRU5UKCdyZW1vdmUnKTtcblx0XHR9XG5cblx0XHRkZWxldGUgdGhpc1trSGVhZGVyc11bbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0fVxuXG5cdHNldEhlYWRlcihuYW1lLCB2YWx1ZSkge1xuXHRcdGlmICh0aGlzLmhlYWRlcnNTZW50KSB7XG5cdFx0XHR0aHJvdyBuZXcgRVJSX0hUVFBfSEVBREVSU19TRU5UKCdzZXQnKTtcblx0XHR9XG5cblx0XHR2YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG5cdFx0dmFsaWRhdGVIZWFkZXJWYWx1ZShuYW1lLCB2YWx1ZSk7XG5cblx0XHRjb25zdCBsb3dlcmNhc2VkID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKGxvd2VyY2FzZWQgPT09ICdjb25uZWN0aW9uJykge1xuXHRcdFx0aWYgKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdrZWVwLWFsaXZlJykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAnY29ubmVjdGlvbicgaGVhZGVyOiAke3ZhbHVlfWApO1xuXHRcdH1cblxuXHRcdGlmIChsb3dlcmNhc2VkID09PSAnaG9zdCcgJiYgdGhpcy5tZXRob2QgPT09ICdDT05ORUNUJykge1xuXHRcdFx0dGhpc1trSGVhZGVyc11bSFRUUDJfSEVBREVSX0FVVEhPUklUWV0gPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpc1trSGVhZGVyc11bbG93ZXJjYXNlZF0gPSB2YWx1ZTtcblx0XHR9XG5cdH1cblxuXHRzZXROb0RlbGF5KCkge1xuXHRcdC8vIEhUVFAyIHNvY2tldHMgY2Fubm90IGJlIG1hbGZvcm1lZCwgZG8gbm90aGluZy5cblx0fVxuXG5cdHNldFNvY2tldEtlZXBBbGl2ZSgpIHtcblx0XHQvLyBIVFRQMiBzb2NrZXRzIGNhbm5vdCBiZSBtYWxmb3JtZWQsIGRvIG5vdGhpbmcuXG5cdH1cblxuXHRzZXRUaW1lb3V0KG1zLCBjYWxsYmFjaykge1xuXHRcdGNvbnN0IGFwcGx5VGltZW91dCA9ICgpID0+IHRoaXMuX3JlcXVlc3Quc2V0VGltZW91dChtcywgY2FsbGJhY2spO1xuXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QpIHtcblx0XHRcdGFwcGx5VGltZW91dCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzW2tKb2JzXS5wdXNoKGFwcGx5VGltZW91dCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRnZXQgbWF4SGVhZGVyc0NvdW50KCkge1xuXHRcdGlmICghdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5fcmVxdWVzdCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3Quc2Vzc2lvbi5sb2NhbFNldHRpbmdzLm1heEhlYWRlckxpc3RTaXplO1xuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHRzZXQgbWF4SGVhZGVyc0NvdW50KF92YWx1ZSkge1xuXHRcdC8vIFVwZGF0aW5nIEhUVFAyIHNldHRpbmdzIHdvdWxkIGFmZmVjdCBhbGwgcmVxdWVzdHMsIGRvIG5vdGhpbmcuXG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRSZXF1ZXN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3Qge1JlYWRhYmxlfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jbGFzcyBJbmNvbWluZ01lc3NhZ2UgZXh0ZW5kcyBSZWFkYWJsZSB7XG5cdGNvbnN0cnVjdG9yKHNvY2tldCwgaGlnaFdhdGVyTWFyaykge1xuXHRcdHN1cGVyKHtcblx0XHRcdGVtaXRDbG9zZTogZmFsc2UsXG5cdFx0XHRhdXRvRGVzdHJveTogdHJ1ZSxcblx0XHRcdGhpZ2hXYXRlck1hcmtcblx0XHR9KTtcblxuXHRcdHRoaXMuc3RhdHVzQ29kZSA9IG51bGw7XG5cdFx0dGhpcy5zdGF0dXNNZXNzYWdlID0gJyc7XG5cdFx0dGhpcy5odHRwVmVyc2lvbiA9ICcyLjAnO1xuXHRcdHRoaXMuaHR0cFZlcnNpb25NYWpvciA9IDI7XG5cdFx0dGhpcy5odHRwVmVyc2lvbk1pbm9yID0gMDtcblx0XHR0aGlzLmhlYWRlcnMgPSB7fTtcblx0XHR0aGlzLnRyYWlsZXJzID0ge307XG5cdFx0dGhpcy5yZXEgPSBudWxsO1xuXG5cdFx0dGhpcy5hYm9ydGVkID0gZmFsc2U7XG5cdFx0dGhpcy5jb21wbGV0ZSA9IGZhbHNlO1xuXHRcdHRoaXMudXBncmFkZSA9IG51bGw7XG5cblx0XHR0aGlzLnJhd0hlYWRlcnMgPSBbXTtcblx0XHR0aGlzLnJhd1RyYWlsZXJzID0gW107XG5cblx0XHR0aGlzLnNvY2tldCA9IHNvY2tldDtcblxuXHRcdHRoaXMuX2R1bXBlZCA9IGZhbHNlO1xuXHR9XG5cblx0Z2V0IGNvbm5lY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc29ja2V0O1xuXHR9XG5cblx0c2V0IGNvbm5lY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLnNvY2tldCA9IHZhbHVlO1xuXHR9XG5cblx0X2Rlc3Ryb3koZXJyb3IsIGNhbGxiYWNrKSB7XG5cdFx0aWYgKCF0aGlzLnJlYWRhYmxlRW5kZWQpIHtcblx0XHRcdHRoaXMuYWJvcnRlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzUzMDNcblx0XHRjYWxsYmFjaygpO1xuXG5cdFx0dGhpcy5yZXEuX3JlcXVlc3QuZGVzdHJveShlcnJvcik7XG5cdH1cblxuXHRzZXRUaW1lb3V0KG1zLCBjYWxsYmFjaykge1xuXHRcdHRoaXMucmVxLnNldFRpbWVvdXQobXMsIGNhbGxiYWNrKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdF9kdW1wKCkge1xuXHRcdGlmICghdGhpcy5fZHVtcGVkKSB7XG5cdFx0XHR0aGlzLl9kdW1wZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xuXHRcdFx0dGhpcy5yZXN1bWUoKTtcblx0XHR9XG5cdH1cblxuXHRfcmVhZCgpIHtcblx0XHRpZiAodGhpcy5yZXEpIHtcblx0XHRcdHRoaXMucmVxLl9yZXF1ZXN0LnJlc3VtZSgpO1xuXHRcdH1cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEluY29taW5nTWVzc2FnZTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGh0dHAyID0gcmVxdWlyZSgnaHR0cDInKTtcbmNvbnN0IHtcblx0QWdlbnQsXG5cdGdsb2JhbEFnZW50XG59ID0gcmVxdWlyZSgnLi9hZ2VudC5qcycpO1xuY29uc3QgQ2xpZW50UmVxdWVzdCA9IHJlcXVpcmUoJy4vY2xpZW50LXJlcXVlc3QuanMnKTtcbmNvbnN0IEluY29taW5nTWVzc2FnZSA9IHJlcXVpcmUoJy4vaW5jb21pbmctbWVzc2FnZS5qcycpO1xuY29uc3QgYXV0byA9IHJlcXVpcmUoJy4vYXV0by5qcycpO1xuY29uc3Qge1xuXHRIdHRwT3Zlckh0dHAyLFxuXHRIdHRwc092ZXJIdHRwMlxufSA9IHJlcXVpcmUoJy4vcHJveGllcy9oMS1vdmVyLWgyLmpzJyk7XG5jb25zdCBIdHRwMk92ZXJIdHRwMiA9IHJlcXVpcmUoJy4vcHJveGllcy9oMi1vdmVyLWgyLmpzJyk7XG5jb25zdCB7XG5cdEh0dHAyT3Zlckh0dHAsXG5cdEh0dHAyT3Zlckh0dHBzXG59ID0gcmVxdWlyZSgnLi9wcm94aWVzL2gyLW92ZXItaDEuanMnKTtcbmNvbnN0IHZhbGlkYXRlSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vdXRpbHMvdmFsaWRhdGUtaGVhZGVyLW5hbWUuanMnKTtcbmNvbnN0IHZhbGlkYXRlSGVhZGVyVmFsdWUgPSByZXF1aXJlKCcuL3V0aWxzL3ZhbGlkYXRlLWhlYWRlci12YWx1ZS5qcycpO1xuXG5jb25zdCByZXF1ZXN0ID0gKHVybCwgb3B0aW9ucywgY2FsbGJhY2spID0+IG5ldyBDbGllbnRSZXF1ZXN0KHVybCwgb3B0aW9ucywgY2FsbGJhY2spO1xuXG5jb25zdCBnZXQgPSAodXJsLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmV2ZW50LWFiYnJldmlhdGlvbnNcblx0Y29uc3QgcmVxID0gbmV3IENsaWVudFJlcXVlc3QodXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG5cdHJlcS5lbmQoKTtcblxuXHRyZXR1cm4gcmVxO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdC4uLmh0dHAyLFxuXHRDbGllbnRSZXF1ZXN0LFxuXHRJbmNvbWluZ01lc3NhZ2UsXG5cdEFnZW50LFxuXHRnbG9iYWxBZ2VudCxcblx0cmVxdWVzdCxcblx0Z2V0LFxuXHRhdXRvLFxuXHRwcm94aWVzOiB7XG5cdFx0SHR0cE92ZXJIdHRwMixcblx0XHRIdHRwc092ZXJIdHRwMixcblx0XHRIdHRwMk92ZXJIdHRwMixcblx0XHRIdHRwMk92ZXJIdHRwLFxuXHRcdEh0dHAyT3Zlckh0dHBzXG5cdH0sXG5cdHZhbGlkYXRlSGVhZGVyTmFtZSxcblx0dmFsaWRhdGVIZWFkZXJWYWx1ZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBzZWxmID0+IHtcblx0Y29uc3Qge3VzZXJuYW1lLCBwYXNzd29yZH0gPSBzZWxmLnByb3h5T3B0aW9ucy51cmw7XG5cblx0aWYgKHVzZXJuYW1lIHx8IHBhc3N3b3JkKSB7XG5cdFx0Y29uc3QgZGF0YSA9IGAke3VzZXJuYW1lfToke3Bhc3N3b3JkfWA7XG5cdFx0Y29uc3QgYXV0aG9yaXphdGlvbiA9IGBCYXNpYyAke0J1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCdiYXNlNjQnKX1gO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdCdwcm94eS1hdXRob3JpemF0aW9uJzogYXV0aG9yaXphdGlvbixcblx0XHRcdGF1dGhvcml6YXRpb25cblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHt9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IEpTU3RyZWFtU29ja2V0ID0gcmVxdWlyZSgnLi4vdXRpbHMvanMtc3RyZWFtLXNvY2tldC5qcycpO1xuY29uc3Qge2dsb2JhbEFnZW50fSA9IHJlcXVpcmUoJy4uL2FnZW50LmpzJyk7XG5jb25zdCBVbmV4cGVjdGVkU3RhdHVzQ29kZUVycm9yID0gcmVxdWlyZSgnLi91bmV4cGVjdGVkLXN0YXR1cy1jb2RlLWVycm9yLmpzJyk7XG5jb25zdCBpbml0aWFsaXplID0gcmVxdWlyZSgnLi9pbml0aWFsaXplLmpzJyk7XG5jb25zdCBnZXRBdXRob3JpemF0aW9uSGVhZGVycyA9IHJlcXVpcmUoJy4vZ2V0LWF1dGgtaGVhZGVycy5qcycpO1xuXG5jb25zdCBjcmVhdGVDb25uZWN0aW9uID0gKHNlbGYsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG5cdChhc3luYyAoKSA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHtwcm94eU9wdGlvbnN9ID0gc2VsZjtcblx0XHRcdGNvbnN0IHt1cmwsIGhlYWRlcnMsIHJhd30gPSBwcm94eU9wdGlvbnM7XG5cblx0XHRcdGNvbnN0IHN0cmVhbSA9IGF3YWl0IGdsb2JhbEFnZW50LnJlcXVlc3QodXJsLCBwcm94eU9wdGlvbnMsIHtcblx0XHRcdFx0Li4uZ2V0QXV0aG9yaXphdGlvbkhlYWRlcnMoc2VsZiksXG5cdFx0XHRcdC4uLmhlYWRlcnMsXG5cdFx0XHRcdCc6bWV0aG9kJzogJ0NPTk5FQ1QnLFxuXHRcdFx0XHQnOmF1dGhvcml0eSc6IGAke29wdGlvbnMuaG9zdH06JHtvcHRpb25zLnBvcnR9YFxuXHRcdFx0fSk7XG5cblx0XHRcdHN0cmVhbS5vbmNlKCdlcnJvcicsIGNhbGxiYWNrKTtcblx0XHRcdHN0cmVhbS5vbmNlKCdyZXNwb25zZScsIGhlYWRlcnMgPT4ge1xuXHRcdFx0XHRjb25zdCBzdGF0dXNDb2RlID0gaGVhZGVyc1snOnN0YXR1cyddO1xuXG5cdFx0XHRcdGlmIChzdGF0dXNDb2RlICE9PSAyMDApIHtcblx0XHRcdFx0XHRjYWxsYmFjayhuZXcgVW5leHBlY3RlZFN0YXR1c0NvZGVFcnJvcihzdGF0dXNDb2RlLCAnJykpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGVuY3J5cHRlZCA9IHNlbGYgaW5zdGFuY2VvZiBodHRwcy5BZ2VudDtcblxuXHRcdFx0XHRpZiAocmF3ICYmIGVuY3J5cHRlZCkge1xuXHRcdFx0XHRcdG9wdGlvbnMuc29ja2V0ID0gc3RyZWFtO1xuXHRcdFx0XHRcdGNvbnN0IHNlY3VyZVN0cmVhbSA9IHRscy5jb25uZWN0KG9wdGlvbnMpO1xuXG5cdFx0XHRcdFx0c2VjdXJlU3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3RyZWFtLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHNlY3VyZVN0cmVhbSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3Qgc29ja2V0ID0gbmV3IEpTU3RyZWFtU29ja2V0KHN0cmVhbSk7XG5cdFx0XHRcdHNvY2tldC5lbmNyeXB0ZWQgPSBmYWxzZTtcblx0XHRcdFx0c29ja2V0Ll9oYW5kbGUuZ2V0cGVlcm5hbWUgPSBvdXQgPT4ge1xuXHRcdFx0XHRcdG91dC5mYW1pbHkgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0b3V0LmFkZHJlc3MgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0b3V0LnBvcnQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgc29ja2V0KTtcblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjYWxsYmFjayhlcnJvcik7XG5cdFx0fVxuXHR9KSgpO1xufTtcblxuY2xhc3MgSHR0cE92ZXJIdHRwMiBleHRlbmRzIGh0dHAuQWdlbnQge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cblx0XHRpbml0aWFsaXplKHRoaXMsIG9wdGlvbnMucHJveHlPcHRpb25zKTtcblx0fVxuXG5cdGNyZWF0ZUNvbm5lY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHRjcmVhdGVDb25uZWN0aW9uKHRoaXMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcblx0fVxufVxuXG5jbGFzcyBIdHRwc092ZXJIdHRwMiBleHRlbmRzIGh0dHBzLkFnZW50IHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXG5cdFx0aW5pdGlhbGl6ZSh0aGlzLCBvcHRpb25zLnByb3h5T3B0aW9ucyk7XG5cdH1cblxuXHRjcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0Y3JlYXRlQ29ubmVjdGlvbih0aGlzLCBvcHRpb25zLCBjYWxsYmFjayk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdEh0dHBPdmVySHR0cDIsXG5cdEh0dHBzT3Zlckh0dHAyXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IEh0dHAyT3Zlckh0dHBYID0gcmVxdWlyZSgnLi9oMi1vdmVyLWh4LmpzJyk7XG5jb25zdCBnZXRBdXRob3JpemF0aW9uSGVhZGVycyA9IHJlcXVpcmUoJy4vZ2V0LWF1dGgtaGVhZGVycy5qcycpO1xuXG5jb25zdCBnZXRTdHJlYW0gPSByZXF1ZXN0ID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0Y29uc3Qgb25Db25uZWN0ID0gKHJlc3BvbnNlLCBzb2NrZXQsIGhlYWQpID0+IHtcblx0XHRzb2NrZXQudW5zaGlmdChoZWFkKTtcblxuXHRcdHJlcXVlc3Qub2ZmKCdlcnJvcicsIHJlamVjdCk7XG5cdFx0cmVzb2x2ZShbc29ja2V0LCByZXNwb25zZS5zdGF0dXNDb2RlLCByZXNwb25zZS5zdGF0dXNNZXNzYWdlXSk7XG5cdH07XG5cblx0cmVxdWVzdC5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG5cdHJlcXVlc3Qub25jZSgnY29ubmVjdCcsIG9uQ29ubmVjdCk7XG59KTtcblxuY2xhc3MgSHR0cDJPdmVySHR0cCBleHRlbmRzIEh0dHAyT3Zlckh0dHBYIHtcblx0YXN5bmMgX2dldFByb3h5U3RyZWFtKGF1dGhvcml0eSkge1xuXHRcdGNvbnN0IHtwcm94eU9wdGlvbnN9ID0gdGhpcztcblx0XHRjb25zdCB7dXJsLCBoZWFkZXJzfSA9IHRoaXMucHJveHlPcHRpb25zO1xuXG5cdFx0Y29uc3QgbmV0d29yayA9IHVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBodHRwcyA6IGh0dHA7XG5cblx0XHQvLyBgbmV3IFVSTCgnaHR0cHM6Ly9sb2NhbGhvc3QvaHR0cGJpbi5vcmc6NDQzJylgIHJlc3VsdHMgaW5cblx0XHQvLyBhIGAvaHR0cGJpbi5vcmc6NDQzYCBwYXRoLCB3aGljaCBoYXMgYW4gaW52YWxpZCBsZWFkaW5nIHNsYXNoLlxuXHRcdGNvbnN0IHJlcXVlc3QgPSBuZXR3b3JrLnJlcXVlc3Qoe1xuXHRcdFx0Li4ucHJveHlPcHRpb25zLFxuXHRcdFx0aG9zdG5hbWU6IHVybC5ob3N0bmFtZSxcblx0XHRcdHBvcnQ6IHVybC5wb3J0LFxuXHRcdFx0cGF0aDogYXV0aG9yaXR5LFxuXHRcdFx0aGVhZGVyczoge1xuXHRcdFx0XHQuLi5nZXRBdXRob3JpemF0aW9uSGVhZGVycyh0aGlzKSxcblx0XHRcdFx0Li4uaGVhZGVycyxcblx0XHRcdFx0aG9zdDogYXV0aG9yaXR5XG5cdFx0XHR9LFxuXHRcdFx0bWV0aG9kOiAnQ09OTkVDVCdcblx0XHR9KS5lbmQoKTtcblxuXHRcdHJldHVybiBnZXRTdHJlYW0ocmVxdWVzdCk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdEh0dHAyT3Zlckh0dHAsXG5cdEh0dHAyT3Zlckh0dHBzOiBIdHRwMk92ZXJIdHRwXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3Qge2dsb2JhbEFnZW50fSA9IHJlcXVpcmUoJy4uL2FnZW50LmpzJyk7XG5jb25zdCBIdHRwMk92ZXJIdHRwWCA9IHJlcXVpcmUoJy4vaDItb3Zlci1oeC5qcycpO1xuY29uc3QgZ2V0QXV0aG9yaXphdGlvbkhlYWRlcnMgPSByZXF1aXJlKCcuL2dldC1hdXRoLWhlYWRlcnMuanMnKTtcblxuY29uc3QgZ2V0U3RhdHVzQ29kZSA9IHN0cmVhbSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdHN0cmVhbS5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG5cdHN0cmVhbS5vbmNlKCdyZXNwb25zZScsIGhlYWRlcnMgPT4ge1xuXHRcdHN0cmVhbS5vZmYoJ2Vycm9yJywgcmVqZWN0KTtcblx0XHRyZXNvbHZlKGhlYWRlcnNbJzpzdGF0dXMnXSk7XG5cdH0pO1xufSk7XG5cbmNsYXNzIEh0dHAyT3Zlckh0dHAyIGV4dGVuZHMgSHR0cDJPdmVySHR0cFgge1xuXHRhc3luYyBfZ2V0UHJveHlTdHJlYW0oYXV0aG9yaXR5KSB7XG5cdFx0Y29uc3Qge3Byb3h5T3B0aW9uc30gPSB0aGlzO1xuXG5cdFx0Y29uc3QgaGVhZGVycyA9IHtcblx0XHRcdC4uLmdldEF1dGhvcml6YXRpb25IZWFkZXJzKHRoaXMpLFxuXHRcdFx0Li4ucHJveHlPcHRpb25zLmhlYWRlcnMsXG5cdFx0XHQnOm1ldGhvZCc6ICdDT05ORUNUJyxcblx0XHRcdCc6YXV0aG9yaXR5JzogYXV0aG9yaXR5XG5cdFx0fTtcblxuXHRcdGNvbnN0IHN0cmVhbSA9IGF3YWl0IGdsb2JhbEFnZW50LnJlcXVlc3QocHJveHlPcHRpb25zLnVybCwgcHJveHlPcHRpb25zLCBoZWFkZXJzKTtcblx0XHRjb25zdCBzdGF0dXNDb2RlID0gYXdhaXQgZ2V0U3RhdHVzQ29kZShzdHJlYW0pO1xuXG5cdFx0cmV0dXJuIFtzdHJlYW0sIHN0YXR1c0NvZGUsICcnXTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEh0dHAyT3Zlckh0dHAyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3Qge0FnZW50fSA9IHJlcXVpcmUoJy4uL2FnZW50LmpzJyk7XG5jb25zdCBKU1N0cmVhbVNvY2tldCA9IHJlcXVpcmUoJy4uL3V0aWxzL2pzLXN0cmVhbS1zb2NrZXQuanMnKTtcbmNvbnN0IFVuZXhwZWN0ZWRTdGF0dXNDb2RlRXJyb3IgPSByZXF1aXJlKCcuL3VuZXhwZWN0ZWQtc3RhdHVzLWNvZGUtZXJyb3IuanMnKTtcbmNvbnN0IGluaXRpYWxpemUgPSByZXF1aXJlKCcuL2luaXRpYWxpemUuanMnKTtcblxuY2xhc3MgSHR0cDJPdmVySHR0cFggZXh0ZW5kcyBBZ2VudCB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRzdXBlcihvcHRpb25zKTtcblxuXHRcdGluaXRpYWxpemUodGhpcywgb3B0aW9ucy5wcm94eU9wdGlvbnMpO1xuXHR9XG5cblx0YXN5bmMgY3JlYXRlQ29ubmVjdGlvbihvcmlnaW4sIG9wdGlvbnMpIHtcblx0XHRjb25zdCBhdXRob3JpdHkgPSBgJHtvcmlnaW4uaG9zdG5hbWV9OiR7b3JpZ2luLnBvcnQgfHwgNDQzfWA7XG5cblx0XHRjb25zdCBbc3RyZWFtLCBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlXSA9IGF3YWl0IHRoaXMuX2dldFByb3h5U3RyZWFtKGF1dGhvcml0eSk7XG5cdFx0aWYgKHN0YXR1c0NvZGUgIT09IDIwMCkge1xuXHRcdFx0dGhyb3cgbmV3IFVuZXhwZWN0ZWRTdGF0dXNDb2RlRXJyb3Ioc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucHJveHlPcHRpb25zLnJhdykge1xuXHRcdFx0b3B0aW9ucy5zb2NrZXQgPSBzdHJlYW07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IHNvY2tldCA9IG5ldyBKU1N0cmVhbVNvY2tldChzdHJlYW0pO1xuXHRcdFx0c29ja2V0LmVuY3J5cHRlZCA9IGZhbHNlO1xuXHRcdFx0c29ja2V0Ll9oYW5kbGUuZ2V0cGVlcm5hbWUgPSBvdXQgPT4ge1xuXHRcdFx0XHRvdXQuZmFtaWx5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRvdXQuYWRkcmVzcyA9IHVuZGVmaW5lZDtcblx0XHRcdFx0b3V0LnBvcnQgPSB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gc29ja2V0O1xuXHRcdH1cblxuXHRcdHJldHVybiBzdXBlci5jcmVhdGVDb25uZWN0aW9uKG9yaWdpbiwgb3B0aW9ucyk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIdHRwMk92ZXJIdHRwWDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svamVzdC9pc3N1ZXMvMjU0OVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvcHJlZmVyLWdsb2JhbC91cmxcbmNvbnN0IHtVUkx9ID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBjaGVja1R5cGUgPSByZXF1aXJlKCcuLi91dGlscy9jaGVjay10eXBlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKHNlbGYsIHByb3h5T3B0aW9ucykgPT4ge1xuXHRjaGVja1R5cGUoJ3Byb3h5T3B0aW9ucycsIHByb3h5T3B0aW9ucywgWydvYmplY3QnXSk7XG5cdGNoZWNrVHlwZSgncHJveHlPcHRpb25zLmhlYWRlcnMnLCBwcm94eU9wdGlvbnMuaGVhZGVycywgWydvYmplY3QnLCAndW5kZWZpbmVkJ10pO1xuXHRjaGVja1R5cGUoJ3Byb3h5T3B0aW9ucy5yYXcnLCBwcm94eU9wdGlvbnMucmF3LCBbJ2Jvb2xlYW4nLCAndW5kZWZpbmVkJ10pO1xuXHRjaGVja1R5cGUoJ3Byb3h5T3B0aW9ucy51cmwnLCBwcm94eU9wdGlvbnMudXJsLCBbVVJMLCAnc3RyaW5nJ10pO1xuXG5cdGNvbnN0IHVybCA9IG5ldyBVUkwocHJveHlPcHRpb25zLnVybCk7XG5cblx0c2VsZi5wcm94eU9wdGlvbnMgPSB7XG5cdFx0cmF3OiB0cnVlLFxuXHRcdC4uLnByb3h5T3B0aW9ucyxcblx0XHRoZWFkZXJzOiB7Li4ucHJveHlPcHRpb25zLmhlYWRlcnN9LFxuXHRcdHVybFxuXHR9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY2xhc3MgVW5leHBlY3RlZFN0YXR1c0NvZGVFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3Ioc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSA9ICcnKSB7XG5cdFx0c3VwZXIoYFRoZSBwcm94eSBzZXJ2ZXIgcmVqZWN0ZWQgdGhlIHJlcXVlc3Qgd2l0aCBzdGF0dXMgY29kZSAke3N0YXR1c0NvZGV9ICgke3N0YXR1c01lc3NhZ2UgfHwgJ2VtcHR5IHN0YXR1cyBtZXNzYWdlJ30pYCk7XG5cdFx0dGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcblx0XHR0aGlzLnN0YXR1c01lc3NhZ2UgPSBzdGF0dXNNZXNzYWdlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVW5leHBlY3RlZFN0YXR1c0NvZGVFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHtpc0lQfSA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbmNvbnN0IGdldEhvc3QgPSBob3N0ID0+IHtcblx0aWYgKGhvc3RbMF0gPT09ICdbJykge1xuXHRcdGNvbnN0IGlkeCA9IGhvc3QuaW5kZXhPZignXScpO1xuXG5cdFx0YXNzZXJ0KGlkeCAhPT0gLTEpO1xuXHRcdHJldHVybiBob3N0LnNsaWNlKDEsIGlkeCk7XG5cdH1cblxuXHRjb25zdCBpZHggPSBob3N0LmluZGV4T2YoJzonKTtcblx0aWYgKGlkeCA9PT0gLTEpIHtcblx0XHRyZXR1cm4gaG9zdDtcblx0fVxuXG5cdHJldHVybiBob3N0LnNsaWNlKDAsIGlkeCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhvc3QgPT4ge1xuXHRjb25zdCBzZXJ2ZXJuYW1lID0gZ2V0SG9zdChob3N0KTtcblxuXHRpZiAoaXNJUChzZXJ2ZXJuYW1lKSkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdHJldHVybiBzZXJ2ZXJuYW1lO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2hlY2tUeXBlID0gKG5hbWUsIHZhbHVlLCB0eXBlcykgPT4ge1xuXHRjb25zdCB2YWxpZCA9IHR5cGVzLnNvbWUodHlwZSA9PiB7XG5cdFx0Y29uc3QgdHlwZW9mVHlwZSA9IHR5cGVvZiB0eXBlO1xuXHRcdGlmICh0eXBlb2ZUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gdHlwZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuXHR9KTtcblxuXHRpZiAoIXZhbGlkKSB7XG5cdFx0Y29uc3QgbmFtZXMgPSB0eXBlcy5tYXAodHlwZSA9PiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlIDogdHlwZS5uYW1lKTtcblxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkICcke25hbWV9JyB0byBiZSBhIHR5cGUgb2YgJHtuYW1lcy5qb2luKCcgb3IgJyl9LCBnb3QgJHt0eXBlb2YgdmFsdWV9YCk7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tUeXBlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmVhbSA9PiB7XG5cdGlmIChzdHJlYW0ubGlzdGVuZXJDb3VudCgnZXJyb3InKSAhPT0gMCkge1xuXHRcdHJldHVybiBzdHJlYW07XG5cdH1cblxuXHRzdHJlYW0uX19kZXN0cm95ID0gc3RyZWFtLl9kZXN0cm95O1xuXHRzdHJlYW0uX2Rlc3Ryb3kgPSAoLi4uYXJncykgPT4ge1xuXHRcdGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKTtcblxuXHRcdHN0cmVhbS5fX2Rlc3Ryb3koLi4uYXJncywgYXN5bmMgZXJyb3IgPT4ge1xuXHRcdFx0YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHRjYWxsYmFjayhlcnJvcik7XG5cdFx0fSk7XG5cdH07XG5cblx0Y29uc3Qgb25FcnJvciA9IGVycm9yID0+IHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tdGhlblxuXHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0c3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdHN0cmVhbS5vbmNlKCdlcnJvcicsIG9uRXJyb3IpO1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuXG5cdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdHN0cmVhbS5vZmYoJ2Vycm9yJywgb25FcnJvcik7XG5cdH0pO1xuXG5cdHJldHVybiBzdHJlYW07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogaXN0YW5idWwgaWdub3JlIGZpbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvaW50ZXJuYWwvZXJyb3JzLmpzICovXG5cbmNvbnN0IG1ha2VFcnJvciA9IChCYXNlLCBrZXksIGdldE1lc3NhZ2UpID0+IHtcblx0bW9kdWxlLmV4cG9ydHNba2V5XSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuXHRcdGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcblx0XHRcdHN1cGVyKHR5cGVvZiBnZXRNZXNzYWdlID09PSAnc3RyaW5nJyA/IGdldE1lc3NhZ2UgOiBnZXRNZXNzYWdlKGFyZ3MpKTtcblx0XHRcdHRoaXMubmFtZSA9IGAke3N1cGVyLm5hbWV9IFske2tleX1dYDtcblx0XHRcdHRoaXMuY29kZSA9IGtleTtcblx0XHR9XG5cdH07XG59O1xuXG5tYWtlRXJyb3IoVHlwZUVycm9yLCAnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBhcmdzID0+IHtcblx0Y29uc3QgdHlwZSA9IGFyZ3NbMF0uaW5jbHVkZXMoJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuXG5cdGxldCB2YWxpZCA9IGFyZ3NbMV07XG5cdGNvbnN0IGlzTWFueVR5cGVzID0gQXJyYXkuaXNBcnJheSh2YWxpZCk7XG5cblx0aWYgKGlzTWFueVR5cGVzKSB7XG5cdFx0dmFsaWQgPSBgJHt2YWxpZC5zbGljZSgwLCAtMSkuam9pbignLCAnKX0gb3IgJHt2YWxpZC5zbGljZSgtMSl9YDtcblx0fVxuXG5cdHJldHVybiBgVGhlIFwiJHthcmdzWzBdfVwiICR7dHlwZX0gbXVzdCBiZSAke2lzTWFueVR5cGVzID8gJ29uZSBvZicgOiAnb2YnfSB0eXBlICR7dmFsaWR9LiBSZWNlaXZlZCAke3R5cGVvZiBhcmdzWzJdfWA7XG59KTtcblxubWFrZUVycm9yKFR5cGVFcnJvciwgJ0VSUl9JTlZBTElEX1BST1RPQ09MJywgYXJncyA9PlxuXHRgUHJvdG9jb2wgXCIke2FyZ3NbMF19XCIgbm90IHN1cHBvcnRlZC4gRXhwZWN0ZWQgXCIke2FyZ3NbMV19XCJgXG4pO1xuXG5tYWtlRXJyb3IoRXJyb3IsICdFUlJfSFRUUF9IRUFERVJTX1NFTlQnLCBhcmdzID0+XG5cdGBDYW5ub3QgJHthcmdzWzBdfSBoZWFkZXJzIGFmdGVyIHRoZXkgYXJlIHNlbnQgdG8gdGhlIGNsaWVudGBcbik7XG5cbm1ha2VFcnJvcihUeXBlRXJyb3IsICdFUlJfSU5WQUxJRF9IVFRQX1RPS0VOJywgYXJncyA9PlxuXHRgJHthcmdzWzBdfSBtdXN0IGJlIGEgdmFsaWQgSFRUUCB0b2tlbiBbJHthcmdzWzFdfV1gXG4pO1xuXG5tYWtlRXJyb3IoVHlwZUVycm9yLCAnRVJSX0hUVFBfSU5WQUxJRF9IRUFERVJfVkFMVUUnLCBhcmdzID0+XG5cdGBJbnZhbGlkIHZhbHVlIFwiJHthcmdzWzBdfSBmb3IgaGVhZGVyIFwiJHthcmdzWzFdfVwiYFxuKTtcblxubWFrZUVycm9yKFR5cGVFcnJvciwgJ0VSUl9JTlZBTElEX0NIQVInLCBhcmdzID0+XG5cdGBJbnZhbGlkIGNoYXJhY3RlciBpbiAke2FyZ3NbMF19IFske2FyZ3NbMV19XWBcbik7XG5cbm1ha2VFcnJvcihcblx0RXJyb3IsXG5cdCdFUlJfSFRUUDJfTk9fU09DS0VUX01BTklQVUxBVElPTicsXG5cdCdIVFRQLzIgc29ja2V0cyBzaG91bGQgbm90IGJlIGRpcmVjdGx5IG1hbmlwdWxhdGVkIChlLmcuIHJlYWQgYW5kIHdyaXR0ZW4pJ1xuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBoZWFkZXIgPT4ge1xuXHRzd2l0Y2ggKGhlYWRlcikge1xuXHRcdGNhc2UgJzptZXRob2QnOlxuXHRcdGNhc2UgJzpzY2hlbWUnOlxuXHRcdGNhc2UgJzphdXRob3JpdHknOlxuXHRcdGNhc2UgJzpwYXRoJzpcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuXG4vLyBSZWFsbHkgYXdlc29tZSBoYWNrLlxuY29uc3QgSlNTdHJlYW1Tb2NrZXQgPSAobmV3IHRscy5UTFNTb2NrZXQobmV3IHN0cmVhbS5QYXNzVGhyb3VnaCgpKSkuX2hhbmRsZS5fcGFyZW50V3JhcC5jb25zdHJ1Y3RvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBKU1N0cmVhbVNvY2tldDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoZnJvbSwgdG8sIGV2ZW50cykgPT4ge1xuXHRmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuXHRcdGZyb20ub24oZXZlbnQsICguLi5hcmdzKSA9PiB0by5lbWl0KGV2ZW50LCAuLi5hcmdzKSk7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCB7RVJSX0hUVFAyX05PX1NPQ0tFVF9NQU5JUFVMQVRJT059ID0gcmVxdWlyZSgnLi9lcnJvcnMuanMnKTtcblxuLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cbi8qIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzZlZWM4NThmMzRhNDBmZmE0ODljMWVjNTRiYjI0ZGE3MmEyOGM3ODEvbGliL2ludGVybmFsL2h0dHAyL2NvbXBhdC5qcyNMMTk1LUwyNzIgKi9cblxuY29uc3QgcHJveHlTb2NrZXRIYW5kbGVyID0ge1xuXHRoYXMoc3RyZWFtLCBwcm9wZXJ0eSkge1xuXHRcdC8vIFJlcGxhY2VkIFtrU29ja2V0XSB3aXRoIC5zb2NrZXRcblx0XHRjb25zdCByZWZlcmVuY2UgPSBzdHJlYW0uc2Vzc2lvbiA9PT0gdW5kZWZpbmVkID8gc3RyZWFtIDogc3RyZWFtLnNlc3Npb24uc29ja2V0O1xuXHRcdHJldHVybiAocHJvcGVydHkgaW4gc3RyZWFtKSB8fCAocHJvcGVydHkgaW4gcmVmZXJlbmNlKTtcblx0fSxcblxuXHRnZXQoc3RyZWFtLCBwcm9wZXJ0eSkge1xuXHRcdHN3aXRjaCAocHJvcGVydHkpIHtcblx0XHRcdGNhc2UgJ29uJzpcblx0XHRcdGNhc2UgJ29uY2UnOlxuXHRcdFx0Y2FzZSAnZW5kJzpcblx0XHRcdGNhc2UgJ2VtaXQnOlxuXHRcdFx0Y2FzZSAnZGVzdHJveSc6XG5cdFx0XHRcdHJldHVybiBzdHJlYW1bcHJvcGVydHldLmJpbmQoc3RyZWFtKTtcblx0XHRcdGNhc2UgJ3dyaXRhYmxlJzpcblx0XHRcdGNhc2UgJ2Rlc3Ryb3llZCc6XG5cdFx0XHRcdHJldHVybiBzdHJlYW1bcHJvcGVydHldO1xuXHRcdFx0Y2FzZSAncmVhZGFibGUnOlxuXHRcdFx0XHRpZiAoc3RyZWFtLmRlc3Ryb3llZCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBzdHJlYW0ucmVhZGFibGU7XG5cdFx0XHRjYXNlICdzZXRUaW1lb3V0Jzoge1xuXHRcdFx0XHRjb25zdCB7c2Vzc2lvbn0gPSBzdHJlYW07XG5cdFx0XHRcdGlmIChzZXNzaW9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2Vzc2lvbi5zZXRUaW1lb3V0LmJpbmQoc2Vzc2lvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gc3RyZWFtLnNldFRpbWVvdXQuYmluZChzdHJlYW0pO1xuXHRcdFx0fVxuXG5cdFx0XHRjYXNlICd3cml0ZSc6XG5cdFx0XHRjYXNlICdyZWFkJzpcblx0XHRcdGNhc2UgJ3BhdXNlJzpcblx0XHRcdGNhc2UgJ3Jlc3VtZSc6XG5cdFx0XHRcdHRocm93IG5ldyBFUlJfSFRUUDJfTk9fU09DS0VUX01BTklQVUxBVElPTigpO1xuXHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHQvLyBSZXBsYWNlZCBba1NvY2tldF0gd2l0aCAuc29ja2V0XG5cdFx0XHRcdGNvbnN0IHJlZmVyZW5jZSA9IHN0cmVhbS5zZXNzaW9uID09PSB1bmRlZmluZWQgPyBzdHJlYW0gOiBzdHJlYW0uc2Vzc2lvbi5zb2NrZXQ7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gcmVmZXJlbmNlW3Byb3BlcnR5XTtcblxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUuYmluZChyZWZlcmVuY2UpIDogdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFByb3RvdHlwZU9mKHN0cmVhbSkge1xuXHRcdGlmIChzdHJlYW0uc2Vzc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyBSZXBsYWNlZCBba1NvY2tldF0gd2l0aCAuc29ja2V0XG5cdFx0XHRyZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzdHJlYW0uc2Vzc2lvbi5zb2NrZXQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHN0cmVhbSk7XG5cdH0sXG5cblx0c2V0KHN0cmVhbSwgcHJvcGVydHksIHZhbHVlKSB7XG5cdFx0c3dpdGNoIChwcm9wZXJ0eSkge1xuXHRcdFx0Y2FzZSAnd3JpdGFibGUnOlxuXHRcdFx0Y2FzZSAncmVhZGFibGUnOlxuXHRcdFx0Y2FzZSAnZGVzdHJveWVkJzpcblx0XHRcdGNhc2UgJ29uJzpcblx0XHRcdGNhc2UgJ29uY2UnOlxuXHRcdFx0Y2FzZSAnZW5kJzpcblx0XHRcdGNhc2UgJ2VtaXQnOlxuXHRcdFx0Y2FzZSAnZGVzdHJveSc6XG5cdFx0XHRcdHN0cmVhbVtwcm9wZXJ0eV0gPSB2YWx1ZTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRjYXNlICdzZXRUaW1lb3V0Jzoge1xuXHRcdFx0XHRjb25zdCB7c2Vzc2lvbn0gPSBzdHJlYW07XG5cdFx0XHRcdGlmIChzZXNzaW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzdHJlYW0uc2V0VGltZW91dCA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlc3Npb24uc2V0VGltZW91dCA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGNhc2UgJ3dyaXRlJzpcblx0XHRcdGNhc2UgJ3JlYWQnOlxuXHRcdFx0Y2FzZSAncGF1c2UnOlxuXHRcdFx0Y2FzZSAncmVzdW1lJzpcblx0XHRcdFx0dGhyb3cgbmV3IEVSUl9IVFRQMl9OT19TT0NLRVRfTUFOSVBVTEFUSU9OKCk7XG5cdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdC8vIFJlcGxhY2VkIFtrU29ja2V0XSB3aXRoIC5zb2NrZXRcblx0XHRcdFx0Y29uc3QgcmVmZXJlbmNlID0gc3RyZWFtLnNlc3Npb24gPT09IHVuZGVmaW5lZCA/IHN0cmVhbSA6IHN0cmVhbS5zZXNzaW9uLnNvY2tldDtcblx0XHRcdFx0cmVmZXJlbmNlW3Byb3BlcnR5XSA9IHZhbHVlO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcHJveHlTb2NrZXRIYW5kbGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3Qge0VSUl9JTlZBTElEX0hUVFBfVE9LRU59ID0gcmVxdWlyZSgnLi9lcnJvcnMuanMnKTtcbmNvbnN0IGlzUmVxdWVzdFBzZXVkb0hlYWRlciA9IHJlcXVpcmUoJy4vaXMtcmVxdWVzdC1wc2V1ZG8taGVhZGVyLmpzJyk7XG5cbmNvbnN0IGlzVmFsaWRIdHRwVG9rZW4gPSAvXltcXF5gXFwtXFx3ISMkJSYqKy58fl0rJC87XG5cbm1vZHVsZS5leHBvcnRzID0gbmFtZSA9PiB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgKCFpc1ZhbGlkSHR0cFRva2VuLnRlc3QobmFtZSkgJiYgIWlzUmVxdWVzdFBzZXVkb0hlYWRlcihuYW1lKSkpIHtcblx0XHR0aHJvdyBuZXcgRVJSX0lOVkFMSURfSFRUUF9UT0tFTignSGVhZGVyIG5hbWUnLCBuYW1lKTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHtcblx0RVJSX0hUVFBfSU5WQUxJRF9IRUFERVJfVkFMVUUsXG5cdEVSUl9JTlZBTElEX0NIQVJcbn0gPSByZXF1aXJlKCcuL2Vycm9ycy5qcycpO1xuXG5jb25zdCBpc0ludmFsaWRIZWFkZXJWYWx1ZSA9IC9bXlxcdFxcdTAwMjAtXFx1MDA3RVxcdTAwODAtXFx1MDBGRl0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuXHRcdHRocm93IG5ldyBFUlJfSFRUUF9JTlZBTElEX0hFQURFUl9WQUxVRSh2YWx1ZSwgbmFtZSk7XG5cdH1cblxuXHRpZiAoaXNJbnZhbGlkSGVhZGVyVmFsdWUudGVzdCh2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgRVJSX0lOVkFMSURfQ0hBUignaGVhZGVyIGNvbnRlbnQnLCBuYW1lKTtcblx0fVxufTtcbiIsIi8vVE9ETzogaGFuZGxlIHJldml2ZXIvZGVoeWRyYXRlIGZ1bmN0aW9uIGxpa2Ugbm9ybWFsXG4vL2FuZCBoYW5kbGUgaW5kZW50YXRpb24sIGxpa2Ugbm9ybWFsLlxuLy9pZiBhbnlvbmUgbmVlZHMgdGhpcy4uLiBwbGVhc2Ugc2VuZCBwdWxsIHJlcXVlc3QuXG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5IChvKSB7XG4gIGlmKCd1bmRlZmluZWQnID09IHR5cGVvZiBvKSByZXR1cm4gb1xuXG4gIGlmKG8gJiYgQnVmZmVyLmlzQnVmZmVyKG8pKVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgnOmJhc2U2NDonICsgby50b1N0cmluZygnYmFzZTY0JykpXG5cbiAgaWYobyAmJiBvLnRvSlNPTilcbiAgICBvID0gIG8udG9KU09OKClcblxuICBpZihvICYmICdvYmplY3QnID09PSB0eXBlb2Ygbykge1xuICAgIHZhciBzID0gJydcbiAgICB2YXIgYXJyYXkgPSBBcnJheS5pc0FycmF5KG8pXG4gICAgcyA9IGFycmF5ID8gJ1snIDogJ3snXG4gICAgdmFyIGZpcnN0ID0gdHJ1ZVxuXG4gICAgZm9yKHZhciBrIGluIG8pIHtcbiAgICAgIHZhciBpZ25vcmUgPSAnZnVuY3Rpb24nID09IHR5cGVvZiBvW2tdIHx8ICghYXJyYXkgJiYgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiBvW2tdKVxuICAgICAgaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobywgaykgJiYgIWlnbm9yZSkge1xuICAgICAgICBpZighZmlyc3QpXG4gICAgICAgICAgcyArPSAnLCdcbiAgICAgICAgZmlyc3QgPSBmYWxzZVxuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBpZihvW2tdID09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHMgKz0gJ251bGwnXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcyArPSBzdHJpbmdpZnkob1trXSlcbiAgICAgICAgfSBlbHNlIGlmIChvW2tdICE9PSB2b2lkKDApKSB7XG4gICAgICAgICAgcyArPSBzdHJpbmdpZnkoaykgKyAnOicgKyBzdHJpbmdpZnkob1trXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHMgKz0gYXJyYXkgPyAnXScgOiAnfSdcblxuICAgIHJldHVybiBzXG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBvKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KC9eOi8udGVzdChvKSA/ICc6JyArIG8gOiBvKVxuICB9IGVsc2UgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2Ygbykge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH0gZWxzZVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvKVxufVxuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHMpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UocywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZignc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICBpZigvXjpiYXNlNjQ6Ly50ZXN0KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLnN1YnN0cmluZyg4KSwgJ2Jhc2U2NCcpXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAvXjovLnRlc3QodmFsdWUpID8gdmFsdWUuc3Vic3RyaW5nKDEpIDogdmFsdWUgXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IEpTT05CID0gcmVxdWlyZSgnanNvbi1idWZmZXInKTtcblxuY29uc3QgbG9hZFN0b3JlID0gb3B0aW9ucyA9PiB7XG5cdGNvbnN0IGFkYXB0ZXJzID0ge1xuXHRcdHJlZGlzOiAnQGtleXYvcmVkaXMnLFxuXHRcdHJlZGlzczogJ0BrZXl2L3JlZGlzJyxcblx0XHRtb25nb2RiOiAnQGtleXYvbW9uZ28nLFxuXHRcdG1vbmdvOiAnQGtleXYvbW9uZ28nLFxuXHRcdHNxbGl0ZTogJ0BrZXl2L3NxbGl0ZScsXG5cdFx0cG9zdGdyZXNxbDogJ0BrZXl2L3Bvc3RncmVzJyxcblx0XHRwb3N0Z3JlczogJ0BrZXl2L3Bvc3RncmVzJyxcblx0XHRteXNxbDogJ0BrZXl2L215c3FsJyxcblx0XHRldGNkOiAnQGtleXYvZXRjZCcsXG5cdFx0b2ZmbGluZTogJ0BrZXl2L29mZmxpbmUnLFxuXHRcdHRpZXJlZDogJ0BrZXl2L3RpZXJlZCcsXG5cdH07XG5cdGlmIChvcHRpb25zLmFkYXB0ZXIgfHwgb3B0aW9ucy51cmkpIHtcblx0XHRjb25zdCBhZGFwdGVyID0gb3B0aW9ucy5hZGFwdGVyIHx8IC9eW146K10qLy5leGVjKG9wdGlvbnMudXJpKVswXTtcblx0XHRyZXR1cm4gbmV3IChyZXF1aXJlKGFkYXB0ZXJzW2FkYXB0ZXJdKSkob3B0aW9ucyk7XG5cdH1cblxuXHRyZXR1cm4gbmV3IE1hcCgpO1xufTtcblxuY29uc3QgaXRlcmFibGVBZGFwdGVycyA9IFtcblx0J3NxbGl0ZScsXG5cdCdwb3N0Z3JlcycsXG5cdCdteXNxbCcsXG5cdCdtb25nbycsXG5cdCdyZWRpcycsXG5cdCd0aWVyZWQnLFxuXTtcblxuY2xhc3MgS2V5diBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cdGNvbnN0cnVjdG9yKHVyaSwge2VtaXRFcnJvcnMgPSB0cnVlLCAuLi5vcHRpb25zfSA9IHt9KSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLm9wdHMgPSB7XG5cdFx0XHRuYW1lc3BhY2U6ICdrZXl2Jyxcblx0XHRcdHNlcmlhbGl6ZTogSlNPTkIuc3RyaW5naWZ5LFxuXHRcdFx0ZGVzZXJpYWxpemU6IEpTT05CLnBhcnNlLFxuXHRcdFx0Li4uKCh0eXBlb2YgdXJpID09PSAnc3RyaW5nJykgPyB7dXJpfSA6IHVyaSksXG5cdFx0XHQuLi5vcHRpb25zLFxuXHRcdH07XG5cblx0XHRpZiAoIXRoaXMub3B0cy5zdG9yZSkge1xuXHRcdFx0Y29uc3QgYWRhcHRlck9wdGlvbnMgPSB7Li4udGhpcy5vcHRzfTtcblx0XHRcdHRoaXMub3B0cy5zdG9yZSA9IGxvYWRTdG9yZShhZGFwdGVyT3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0cy5jb21wcmVzc2lvbikge1xuXHRcdFx0Y29uc3QgY29tcHJlc3Npb24gPSB0aGlzLm9wdHMuY29tcHJlc3Npb247XG5cdFx0XHR0aGlzLm9wdHMuc2VyaWFsaXplID0gY29tcHJlc3Npb24uc2VyaWFsaXplLmJpbmQoY29tcHJlc3Npb24pO1xuXHRcdFx0dGhpcy5vcHRzLmRlc2VyaWFsaXplID0gY29tcHJlc3Npb24uZGVzZXJpYWxpemUuYmluZChjb21wcmVzc2lvbik7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB0aGlzLm9wdHMuc3RvcmUub24gPT09ICdmdW5jdGlvbicgJiYgZW1pdEVycm9ycykge1xuXHRcdFx0dGhpcy5vcHRzLnN0b3JlLm9uKCdlcnJvcicsIGVycm9yID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcikpO1xuXHRcdH1cblxuXHRcdHRoaXMub3B0cy5zdG9yZS5uYW1lc3BhY2UgPSB0aGlzLm9wdHMubmFtZXNwYWNlO1xuXG5cdFx0Y29uc3QgZ2VuZXJhdGVJdGVyYXRvciA9IGl0ZXJhdG9yID0+IGFzeW5jIGZ1bmN0aW9uICogKCkge1xuXHRcdFx0Zm9yIGF3YWl0IChjb25zdCBba2V5LCByYXddIG9mIHR5cGVvZiBpdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHQ/IGl0ZXJhdG9yKHRoaXMub3B0cy5zdG9yZS5uYW1lc3BhY2UpXG5cdFx0XHRcdDogaXRlcmF0b3IpIHtcblx0XHRcdFx0Y29uc3QgZGF0YSA9IHRoaXMub3B0cy5kZXNlcmlhbGl6ZShyYXcpO1xuXHRcdFx0XHRpZiAodGhpcy5vcHRzLnN0b3JlLm5hbWVzcGFjZSAmJiAha2V5LmluY2x1ZGVzKHRoaXMub3B0cy5zdG9yZS5uYW1lc3BhY2UpKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodHlwZW9mIGRhdGEuZXhwaXJlcyA9PT0gJ251bWJlcicgJiYgRGF0ZS5ub3coKSA+IGRhdGEuZXhwaXJlcykge1xuXHRcdFx0XHRcdHRoaXMuZGVsZXRlKGtleSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR5aWVsZCBbdGhpcy5fZ2V0S2V5VW5wcmVmaXgoa2V5KSwgZGF0YS52YWx1ZV07XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBpdGVyYXRvcnNcblx0XHRpZiAodHlwZW9mIHRoaXMub3B0cy5zdG9yZVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nICYmIHRoaXMub3B0cy5zdG9yZSBpbnN0YW5jZW9mIE1hcCkge1xuXHRcdFx0dGhpcy5pdGVyYXRvciA9IGdlbmVyYXRlSXRlcmF0b3IodGhpcy5vcHRzLnN0b3JlKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm9wdHMuc3RvcmUuaXRlcmF0b3IgPT09ICdmdW5jdGlvbicgJiYgdGhpcy5vcHRzLnN0b3JlLm9wdHNcblx0XHRcdCYmIHRoaXMuX2NoZWNrSXRlcmFibGVBZGFwdGFyKCkpIHtcblx0XHRcdHRoaXMuaXRlcmF0b3IgPSBnZW5lcmF0ZUl0ZXJhdG9yKHRoaXMub3B0cy5zdG9yZS5pdGVyYXRvci5iaW5kKHRoaXMub3B0cy5zdG9yZSkpO1xuXHRcdH1cblx0fVxuXG5cdF9jaGVja0l0ZXJhYmxlQWRhcHRhcigpIHtcblx0XHRyZXR1cm4gaXRlcmFibGVBZGFwdGVycy5pbmNsdWRlcyh0aGlzLm9wdHMuc3RvcmUub3B0cy5kaWFsZWN0KVxuXHRcdFx0fHwgaXRlcmFibGVBZGFwdGVycy5maW5kSW5kZXgoZWxlbWVudCA9PiB0aGlzLm9wdHMuc3RvcmUub3B0cy51cmwuaW5jbHVkZXMoZWxlbWVudCkpID49IDA7XG5cdH1cblxuXHRfZ2V0S2V5UHJlZml4KGtleSkge1xuXHRcdHJldHVybiBgJHt0aGlzLm9wdHMubmFtZXNwYWNlfToke2tleX1gO1xuXHR9XG5cblx0X2dldEtleVByZWZpeEFycmF5KGtleXMpIHtcblx0XHRyZXR1cm4ga2V5cy5tYXAoa2V5ID0+IGAke3RoaXMub3B0cy5uYW1lc3BhY2V9OiR7a2V5fWApO1xuXHR9XG5cblx0X2dldEtleVVucHJlZml4KGtleSkge1xuXHRcdHJldHVybiBrZXlcblx0XHRcdC5zcGxpdCgnOicpXG5cdFx0XHQuc3BsaWNlKDEpXG5cdFx0XHQuam9pbignOicpO1xuXHR9XG5cblx0Z2V0KGtleSwgb3B0aW9ucykge1xuXHRcdGNvbnN0IHtzdG9yZX0gPSB0aGlzLm9wdHM7XG5cdFx0Y29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoa2V5KTtcblx0XHRjb25zdCBrZXlQcmVmaXhlZCA9IGlzQXJyYXkgPyB0aGlzLl9nZXRLZXlQcmVmaXhBcnJheShrZXkpIDogdGhpcy5fZ2V0S2V5UHJlZml4KGtleSk7XG5cdFx0aWYgKGlzQXJyYXkgJiYgc3RvcmUuZ2V0TWFueSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCBwcm9taXNlcyA9IFtdO1xuXHRcdFx0Zm9yIChjb25zdCBrZXkgb2Yga2V5UHJlZml4ZWQpIHtcblx0XHRcdFx0cHJvbWlzZXMucHVzaChQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0XHRcdC50aGVuKCgpID0+IHN0b3JlLmdldChrZXkpKVxuXHRcdFx0XHRcdC50aGVuKGRhdGEgPT4gKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgPyB0aGlzLm9wdHMuZGVzZXJpYWxpemUoZGF0YSkgOiAodGhpcy5vcHRzLmNvbXByZXNzaW9uID8gdGhpcy5vcHRzLmRlc2VyaWFsaXplKGRhdGEpIDogZGF0YSkpXG5cdFx0XHRcdFx0LnRoZW4oZGF0YSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBkYXRhLmV4cGlyZXMgPT09ICdudW1iZXInICYmIERhdGUubm93KCkgPiBkYXRhLmV4cGlyZXMpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuZGVsZXRlKGtleSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gKG9wdGlvbnMgJiYgb3B0aW9ucy5yYXcpID8gZGF0YSA6IGRhdGEudmFsdWU7XG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpXG5cdFx0XHRcdC50aGVuKHZhbHVlcyA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgZGF0YSA9IFtdO1xuXHRcdFx0XHRcdGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG5cdFx0XHRcdFx0XHRkYXRhLnB1c2godmFsdWUudmFsdWUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+IGlzQXJyYXkgPyBzdG9yZS5nZXRNYW55KGtleVByZWZpeGVkKSA6IHN0b3JlLmdldChrZXlQcmVmaXhlZCkpXG5cdFx0XHQudGhlbihkYXRhID0+ICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpID8gdGhpcy5vcHRzLmRlc2VyaWFsaXplKGRhdGEpIDogKHRoaXMub3B0cy5jb21wcmVzc2lvbiA/IHRoaXMub3B0cy5kZXNlcmlhbGl6ZShkYXRhKSA6IGRhdGEpKVxuXHRcdFx0LnRoZW4oZGF0YSA9PiB7XG5cdFx0XHRcdGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgZGF0YSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNBcnJheSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgcm93IG9mIGRhdGEpIHtcblx0XHRcdFx0XHRcdGlmICgodHlwZW9mIHJvdyA9PT0gJ3N0cmluZycpKSB7XG5cdFx0XHRcdFx0XHRcdHJvdyA9IHRoaXMub3B0cy5kZXNlcmlhbGl6ZShyb3cpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAocm93ID09PSB1bmRlZmluZWQgfHwgcm93ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKHVuZGVmaW5lZCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHJvdy5leHBpcmVzID09PSAnbnVtYmVyJyAmJiBEYXRlLm5vdygpID4gcm93LmV4cGlyZXMpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5kZWxldGUoa2V5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKHVuZGVmaW5lZCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgob3B0aW9ucyAmJiBvcHRpb25zLnJhdykgPyByb3cgOiByb3cudmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodHlwZW9mIGRhdGEuZXhwaXJlcyA9PT0gJ251bWJlcicgJiYgRGF0ZS5ub3coKSA+IGRhdGEuZXhwaXJlcykge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmRlbGV0ZShrZXkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAob3B0aW9ucyAmJiBvcHRpb25zLnJhdykgPyBkYXRhIDogZGF0YS52YWx1ZTtcblx0XHRcdH0pO1xuXHR9XG5cblx0c2V0KGtleSwgdmFsdWUsIHR0bCkge1xuXHRcdGNvbnN0IGtleVByZWZpeGVkID0gdGhpcy5fZ2V0S2V5UHJlZml4KGtleSk7XG5cdFx0aWYgKHR5cGVvZiB0dGwgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0dGwgPSB0aGlzLm9wdHMudHRsO1xuXHRcdH1cblxuXHRcdGlmICh0dGwgPT09IDApIHtcblx0XHRcdHR0bCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRjb25zdCB7c3RvcmV9ID0gdGhpcy5vcHRzO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGV4cGlyZXMgPSAodHlwZW9mIHR0bCA9PT0gJ251bWJlcicpID8gKERhdGUubm93KCkgKyB0dGwpIDogbnVsbDtcblx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ2Vycm9yJywgJ3N5bWJvbCBjYW5ub3QgYmUgc2VyaWFsaXplZCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFsdWUgPSB7dmFsdWUsIGV4cGlyZXN9O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRzLnNlcmlhbGl6ZSh2YWx1ZSk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4odmFsdWUgPT4gc3RvcmUuc2V0KGtleVByZWZpeGVkLCB2YWx1ZSwgdHRsKSlcblx0XHRcdC50aGVuKCgpID0+IHRydWUpO1xuXHR9XG5cblx0ZGVsZXRlKGtleSkge1xuXHRcdGNvbnN0IHtzdG9yZX0gPSB0aGlzLm9wdHM7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuXHRcdFx0Y29uc3Qga2V5UHJlZml4ZWQgPSB0aGlzLl9nZXRLZXlQcmVmaXhBcnJheShrZXkpO1xuXHRcdFx0aWYgKHN0b3JlLmRlbGV0ZU1hbnkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zdCBwcm9taXNlcyA9IFtdO1xuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBvZiBrZXlQcmVmaXhlZCkge1xuXHRcdFx0XHRcdHByb21pc2VzLnB1c2goc3RvcmUuZGVsZXRlKGtleSkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcylcblx0XHRcdFx0XHQudGhlbih2YWx1ZXMgPT4gdmFsdWVzLmV2ZXJ5KHggPT4geC52YWx1ZSA9PT0gdHJ1ZSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdFx0LnRoZW4oKCkgPT4gc3RvcmUuZGVsZXRlTWFueShrZXlQcmVmaXhlZCkpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGtleVByZWZpeGVkID0gdGhpcy5fZ2V0S2V5UHJlZml4KGtleSk7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PiBzdG9yZS5kZWxldGUoa2V5UHJlZml4ZWQpKTtcblx0fVxuXG5cdGNsZWFyKCkge1xuXHRcdGNvbnN0IHtzdG9yZX0gPSB0aGlzLm9wdHM7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PiBzdG9yZS5jbGVhcigpKTtcblx0fVxuXG5cdGhhcyhrZXkpIHtcblx0XHRjb25zdCBrZXlQcmVmaXhlZCA9IHRoaXMuX2dldEtleVByZWZpeChrZXkpO1xuXHRcdGNvbnN0IHtzdG9yZX0gPSB0aGlzLm9wdHM7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbihhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygc3RvcmUuaGFzID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0b3JlLmhhcyhrZXlQcmVmaXhlZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGF3YWl0IHN0b3JlLmdldChrZXlQcmVmaXhlZCk7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRkaXNjb25uZWN0KCkge1xuXHRcdGNvbnN0IHtzdG9yZX0gPSB0aGlzLm9wdHM7XG5cdFx0aWYgKHR5cGVvZiBzdG9yZS5kaXNjb25uZWN0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gc3RvcmUuZGlzY29ubmVjdCgpO1xuXHRcdH1cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEtleXY7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNsYXNzIFF1aWNrTFJVIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdFx0aWYgKCEob3B0aW9ucy5tYXhTaXplICYmIG9wdGlvbnMubWF4U2l6ZSA+IDApKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdgbWF4U2l6ZWAgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpO1xuXHRcdH1cblxuXHRcdHRoaXMubWF4U2l6ZSA9IG9wdGlvbnMubWF4U2l6ZTtcblx0XHR0aGlzLm9uRXZpY3Rpb24gPSBvcHRpb25zLm9uRXZpY3Rpb247XG5cdFx0dGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLm9sZENhY2hlID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMuX3NpemUgPSAwO1xuXHR9XG5cblx0X3NldChrZXksIHZhbHVlKSB7XG5cdFx0dGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0dGhpcy5fc2l6ZSsrO1xuXG5cdFx0aWYgKHRoaXMuX3NpemUgPj0gdGhpcy5tYXhTaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gMDtcblxuXHRcdFx0aWYgKHR5cGVvZiB0aGlzLm9uRXZpY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5vbGRDYWNoZS5lbnRyaWVzKCkpIHtcblx0XHRcdFx0XHR0aGlzLm9uRXZpY3Rpb24oa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5vbGRDYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFx0XHR0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuXHRcdH1cblx0fVxuXG5cdGdldChrZXkpIHtcblx0XHRpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGtleSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdGNvbnN0IHZhbHVlID0gdGhpcy5vbGRDYWNoZS5nZXQoa2V5KTtcblx0XHRcdHRoaXMub2xkQ2FjaGUuZGVsZXRlKGtleSk7XG5cdFx0XHR0aGlzLl9zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0c2V0KGtleSwgdmFsdWUpIHtcblx0XHRpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0dGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NldChrZXksIHZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGhhcyhrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5jYWNoZS5oYXMoa2V5KSB8fCB0aGlzLm9sZENhY2hlLmhhcyhrZXkpO1xuXHR9XG5cblx0cGVlayhrZXkpIHtcblx0XHRpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGtleSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdHJldHVybiB0aGlzLm9sZENhY2hlLmdldChrZXkpO1xuXHRcdH1cblx0fVxuXG5cdGRlbGV0ZShrZXkpIHtcblx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcblx0XHRpZiAoZGVsZXRlZCkge1xuXHRcdFx0dGhpcy5fc2l6ZS0tO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpIHx8IGRlbGV0ZWQ7XG5cdH1cblxuXHRjbGVhcigpIHtcblx0XHR0aGlzLmNhY2hlLmNsZWFyKCk7XG5cdFx0dGhpcy5vbGRDYWNoZS5jbGVhcigpO1xuXHRcdHRoaXMuX3NpemUgPSAwO1xuXHR9XG5cblx0KiBrZXlzKCkge1xuXHRcdGZvciAoY29uc3QgW2tleV0gb2YgdGhpcykge1xuXHRcdFx0eWllbGQga2V5O1xuXHRcdH1cblx0fVxuXG5cdCogdmFsdWVzKCkge1xuXHRcdGZvciAoY29uc3QgWywgdmFsdWVdIG9mIHRoaXMpIHtcblx0XHRcdHlpZWxkIHZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdCogW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0Zm9yIChjb25zdCBpdGVtIG9mIHRoaXMuY2FjaGUpIHtcblx0XHRcdHlpZWxkIGl0ZW07XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBpdGVtIG9mIHRoaXMub2xkQ2FjaGUpIHtcblx0XHRcdGNvbnN0IFtrZXldID0gaXRlbTtcblx0XHRcdGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0XHR5aWVsZCBpdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGdldCBzaXplKCkge1xuXHRcdGxldCBvbGRDYWNoZVNpemUgPSAwO1xuXHRcdGZvciAoY29uc3Qga2V5IG9mIHRoaXMub2xkQ2FjaGUua2V5cygpKSB7XG5cdFx0XHRpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdFx0b2xkQ2FjaGVTaXplKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGgubWluKHRoaXMuX3NpemUgKyBvbGRDYWNoZVNpemUsIHRoaXMubWF4U2l6ZSk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWlja0xSVTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChvcHRpb25zID0ge30sIGNvbm5lY3QgPSB0bHMuY29ubmVjdCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRsZXQgdGltZW91dCA9IGZhbHNlO1xuXG5cdGxldCBzb2NrZXQ7XG5cblx0Y29uc3QgY2FsbGJhY2sgPSBhc3luYyAoKSA9PiB7XG5cdFx0YXdhaXQgc29ja2V0UHJvbWlzZTtcblxuXHRcdHNvY2tldC5vZmYoJ3RpbWVvdXQnLCBvblRpbWVvdXQpO1xuXHRcdHNvY2tldC5vZmYoJ2Vycm9yJywgcmVqZWN0KTtcblxuXHRcdGlmIChvcHRpb25zLnJlc29sdmVTb2NrZXQpIHtcblx0XHRcdHJlc29sdmUoe2FscG5Qcm90b2NvbDogc29ja2V0LmFscG5Qcm90b2NvbCwgc29ja2V0LCB0aW1lb3V0fSk7XG5cblx0XHRcdGlmICh0aW1lb3V0KSB7XG5cdFx0XHRcdGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdFx0XHRzb2NrZXQuZW1pdCgndGltZW91dCcpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzb2NrZXQuZGVzdHJveSgpO1xuXHRcdFx0cmVzb2x2ZSh7YWxwblByb3RvY29sOiBzb2NrZXQuYWxwblByb3RvY29sLCB0aW1lb3V0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IG9uVGltZW91dCA9IGFzeW5jICgpID0+IHtcblx0XHR0aW1lb3V0ID0gdHJ1ZTtcblx0XHRjYWxsYmFjaygpO1xuXHR9O1xuXG5cdGNvbnN0IHNvY2tldFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRzb2NrZXQgPSBhd2FpdCBjb25uZWN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcblxuXHRcdFx0c29ja2V0Lm9uKCdlcnJvcicsIHJlamVjdCk7XG5cdFx0XHRzb2NrZXQub25jZSgndGltZW91dCcsIG9uVGltZW91dCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0fVxuXHR9KSgpO1xufSk7XG4iLCJjb25zdCB0eXBlZEFycmF5VHlwZU5hbWVzID0gW1xuICAgICdJbnQ4QXJyYXknLFxuICAgICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLFxuICAgICdJbnQxNkFycmF5JyxcbiAgICAnVWludDE2QXJyYXknLFxuICAgICdJbnQzMkFycmF5JyxcbiAgICAnVWludDMyQXJyYXknLFxuICAgICdGbG9hdDMyQXJyYXknLFxuICAgICdGbG9hdDY0QXJyYXknLFxuICAgICdCaWdJbnQ2NEFycmF5JyxcbiAgICAnQmlnVWludDY0QXJyYXknLFxuXTtcbmZ1bmN0aW9uIGlzVHlwZWRBcnJheU5hbWUobmFtZSkge1xuICAgIHJldHVybiB0eXBlZEFycmF5VHlwZU5hbWVzLmluY2x1ZGVzKG5hbWUpO1xufVxuY29uc3Qgb2JqZWN0VHlwZU5hbWVzID0gW1xuICAgICdGdW5jdGlvbicsXG4gICAgJ0dlbmVyYXRvcicsXG4gICAgJ0FzeW5jR2VuZXJhdG9yJyxcbiAgICAnR2VuZXJhdG9yRnVuY3Rpb24nLFxuICAgICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJyxcbiAgICAnQXN5bmNGdW5jdGlvbicsXG4gICAgJ09ic2VydmFibGUnLFxuICAgICdBcnJheScsXG4gICAgJ0J1ZmZlcicsXG4gICAgJ0Jsb2InLFxuICAgICdPYmplY3QnLFxuICAgICdSZWdFeHAnLFxuICAgICdEYXRlJyxcbiAgICAnRXJyb3InLFxuICAgICdNYXAnLFxuICAgICdTZXQnLFxuICAgICdXZWFrTWFwJyxcbiAgICAnV2Vha1NldCcsXG4gICAgJ1dlYWtSZWYnLFxuICAgICdBcnJheUJ1ZmZlcicsXG4gICAgJ1NoYXJlZEFycmF5QnVmZmVyJyxcbiAgICAnRGF0YVZpZXcnLFxuICAgICdQcm9taXNlJyxcbiAgICAnVVJMJyxcbiAgICAnRm9ybURhdGEnLFxuICAgICdVUkxTZWFyY2hQYXJhbXMnLFxuICAgICdIVE1MRWxlbWVudCcsXG4gICAgJ05hTicsXG4gICAgLi4udHlwZWRBcnJheVR5cGVOYW1lcyxcbl07XG5mdW5jdGlvbiBpc09iamVjdFR5cGVOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gb2JqZWN0VHlwZU5hbWVzLmluY2x1ZGVzKG5hbWUpO1xufVxuY29uc3QgcHJpbWl0aXZlVHlwZU5hbWVzID0gW1xuICAgICdudWxsJyxcbiAgICAndW5kZWZpbmVkJyxcbiAgICAnc3RyaW5nJyxcbiAgICAnbnVtYmVyJyxcbiAgICAnYmlnaW50JyxcbiAgICAnYm9vbGVhbicsXG4gICAgJ3N5bWJvbCcsXG5dO1xuZnVuY3Rpb24gaXNQcmltaXRpdmVUeXBlTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZVR5cGVOYW1lcy5pbmNsdWRlcyhuYW1lKTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5mdW5jdGlvbiBpc09mVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSB0eXBlO1xufVxuY29uc3QgeyB0b1N0cmluZyB9ID0gT2JqZWN0LnByb3RvdHlwZTtcbmNvbnN0IGdldE9iamVjdFR5cGUgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBvYmplY3RUeXBlTmFtZSA9IHRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAoL0hUTUxcXHcrRWxlbWVudC8udGVzdChvYmplY3RUeXBlTmFtZSkgJiYgaXMuZG9tRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdIVE1MRWxlbWVudCc7XG4gICAgfVxuICAgIGlmIChpc09iamVjdFR5cGVOYW1lKG9iamVjdFR5cGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0VHlwZU5hbWU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgaXNPYmplY3RPZlR5cGUgPSAodHlwZSkgPT4gKHZhbHVlKSA9PiBnZXRPYmplY3RUeXBlKHZhbHVlKSA9PT0gdHlwZTtcbmZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKHZhbHVlKSA/ICdOYU4nIDogJ251bWJlcic7XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgcmV0dXJuICdib29sZWFuJztcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuICdGdW5jdGlvbic7XG4gICAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgICAgICByZXR1cm4gJ2JpZ2ludCc7XG4gICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICAgIGlmIChpcy5vYnNlcnZhYmxlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ09ic2VydmFibGUnO1xuICAgIH1cbiAgICBpZiAoaXMuYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnQXJyYXknO1xuICAgIH1cbiAgICBpZiAoaXMuYnVmZmVyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ0J1ZmZlcic7XG4gICAgfVxuICAgIGNvbnN0IHRhZ1R5cGUgPSBnZXRPYmplY3RUeXBlKHZhbHVlKTtcbiAgICBpZiAodGFnVHlwZSkge1xuICAgICAgICByZXR1cm4gdGFnVHlwZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbiB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgZG9uXFwndCB1c2Ugb2JqZWN0IHdyYXBwZXJzIGZvciBwcmltaXRpdmUgdHlwZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuICdPYmplY3QnO1xufVxuaXMudW5kZWZpbmVkID0gaXNPZlR5cGUoJ3VuZGVmaW5lZCcpO1xuaXMuc3RyaW5nID0gaXNPZlR5cGUoJ3N0cmluZycpO1xuY29uc3QgaXNOdW1iZXJUeXBlID0gaXNPZlR5cGUoJ251bWJlcicpO1xuaXMubnVtYmVyID0gKHZhbHVlKSA9PiBpc051bWJlclR5cGUodmFsdWUpICYmICFpcy5uYW4odmFsdWUpO1xuaXMuYmlnaW50ID0gaXNPZlR5cGUoJ2JpZ2ludCcpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmlzLmZ1bmN0aW9uXyA9IGlzT2ZUeXBlKCdmdW5jdGlvbicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmlzLm51bGxfID0gKHZhbHVlKSA9PiB2YWx1ZSA9PT0gbnVsbDtcbmlzLmNsYXNzXyA9ICh2YWx1ZSkgPT4gaXMuZnVuY3Rpb25fKHZhbHVlKSAmJiB2YWx1ZS50b1N0cmluZygpLnN0YXJ0c1dpdGgoJ2NsYXNzICcpO1xuaXMuYm9vbGVhbiA9ICh2YWx1ZSkgPT4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xuaXMuc3ltYm9sID0gaXNPZlR5cGUoJ3N5bWJvbCcpO1xuaXMubnVtZXJpY1N0cmluZyA9ICh2YWx1ZSkgPT4gaXMuc3RyaW5nKHZhbHVlKSAmJiAhaXMuZW1wdHlTdHJpbmdPcldoaXRlc3BhY2UodmFsdWUpICYmICFOdW1iZXIuaXNOYU4oTnVtYmVyKHZhbHVlKSk7XG5pcy5hcnJheSA9ICh2YWx1ZSwgYXNzZXJ0aW9uKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXMuZnVuY3Rpb25fKGFzc2VydGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5ldmVyeShlbGVtZW50ID0+IGFzc2VydGlvbihlbGVtZW50KSk7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbmlzLmJ1ZmZlciA9ICh2YWx1ZSkgPT4gdmFsdWU/LmNvbnN0cnVjdG9yPy5pc0J1ZmZlcj8uKHZhbHVlKSA/PyBmYWxzZTtcbmlzLmJsb2IgPSAodmFsdWUpID0+IGlzT2JqZWN0T2ZUeXBlKCdCbG9iJykodmFsdWUpO1xuaXMubnVsbE9yVW5kZWZpbmVkID0gKHZhbHVlKSA9PiBpcy5udWxsXyh2YWx1ZSkgfHwgaXMudW5kZWZpbmVkKHZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5pcy5vYmplY3QgPSAodmFsdWUpID0+ICFpcy5udWxsXyh2YWx1ZSkgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgaXMuZnVuY3Rpb25fKHZhbHVlKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuaXMuaXRlcmFibGUgPSAodmFsdWUpID0+IGlzLmZ1bmN0aW9uXyh2YWx1ZT8uW1N5bWJvbC5pdGVyYXRvcl0pO1xuaXMuYXN5bmNJdGVyYWJsZSA9ICh2YWx1ZSkgPT4gaXMuZnVuY3Rpb25fKHZhbHVlPy5bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKTtcbmlzLmdlbmVyYXRvciA9ICh2YWx1ZSkgPT4gaXMuaXRlcmFibGUodmFsdWUpICYmIGlzLmZ1bmN0aW9uXyh2YWx1ZT8ubmV4dCkgJiYgaXMuZnVuY3Rpb25fKHZhbHVlPy50aHJvdyk7XG5pcy5hc3luY0dlbmVyYXRvciA9ICh2YWx1ZSkgPT4gaXMuYXN5bmNJdGVyYWJsZSh2YWx1ZSkgJiYgaXMuZnVuY3Rpb25fKHZhbHVlLm5leHQpICYmIGlzLmZ1bmN0aW9uXyh2YWx1ZS50aHJvdyk7XG5pcy5uYXRpdmVQcm9taXNlID0gKHZhbHVlKSA9PiBpc09iamVjdE9mVHlwZSgnUHJvbWlzZScpKHZhbHVlKTtcbmNvbnN0IGhhc1Byb21pc2VBcGkgPSAodmFsdWUpID0+IGlzLmZ1bmN0aW9uXyh2YWx1ZT8udGhlbilcbiAgICAmJiBpcy5mdW5jdGlvbl8odmFsdWU/LmNhdGNoKTtcbmlzLnByb21pc2UgPSAodmFsdWUpID0+IGlzLm5hdGl2ZVByb21pc2UodmFsdWUpIHx8IGhhc1Byb21pc2VBcGkodmFsdWUpO1xuaXMuZ2VuZXJhdG9yRnVuY3Rpb24gPSBpc09iamVjdE9mVHlwZSgnR2VuZXJhdG9yRnVuY3Rpb24nKTtcbmlzLmFzeW5jR2VuZXJhdG9yRnVuY3Rpb24gPSAodmFsdWUpID0+IGdldE9iamVjdFR5cGUodmFsdWUpID09PSAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbic7XG5pcy5hc3luY0Z1bmN0aW9uID0gKHZhbHVlKSA9PiBnZXRPYmplY3RUeXBlKHZhbHVlKSA9PT0gJ0FzeW5jRnVuY3Rpb24nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucywgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuaXMuYm91bmRGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gaXMuZnVuY3Rpb25fKHZhbHVlKSAmJiAhdmFsdWUuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpO1xuaXMucmVnRXhwID0gaXNPYmplY3RPZlR5cGUoJ1JlZ0V4cCcpO1xuaXMuZGF0ZSA9IGlzT2JqZWN0T2ZUeXBlKCdEYXRlJyk7XG5pcy5lcnJvciA9IGlzT2JqZWN0T2ZUeXBlKCdFcnJvcicpO1xuaXMubWFwID0gKHZhbHVlKSA9PiBpc09iamVjdE9mVHlwZSgnTWFwJykodmFsdWUpO1xuaXMuc2V0ID0gKHZhbHVlKSA9PiBpc09iamVjdE9mVHlwZSgnU2V0JykodmFsdWUpO1xuaXMud2Vha01hcCA9ICh2YWx1ZSkgPT4gaXNPYmplY3RPZlR5cGUoJ1dlYWtNYXAnKSh2YWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuaXMud2Vha1NldCA9ICh2YWx1ZSkgPT4gaXNPYmplY3RPZlR5cGUoJ1dlYWtTZXQnKSh2YWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuaXMud2Vha1JlZiA9ICh2YWx1ZSkgPT4gaXNPYmplY3RPZlR5cGUoJ1dlYWtSZWYnKSh2YWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuaXMuaW50OEFycmF5ID0gaXNPYmplY3RPZlR5cGUoJ0ludDhBcnJheScpO1xuaXMudWludDhBcnJheSA9IGlzT2JqZWN0T2ZUeXBlKCdVaW50OEFycmF5Jyk7XG5pcy51aW50OENsYW1wZWRBcnJheSA9IGlzT2JqZWN0T2ZUeXBlKCdVaW50OENsYW1wZWRBcnJheScpO1xuaXMuaW50MTZBcnJheSA9IGlzT2JqZWN0T2ZUeXBlKCdJbnQxNkFycmF5Jyk7XG5pcy51aW50MTZBcnJheSA9IGlzT2JqZWN0T2ZUeXBlKCdVaW50MTZBcnJheScpO1xuaXMuaW50MzJBcnJheSA9IGlzT2JqZWN0T2ZUeXBlKCdJbnQzMkFycmF5Jyk7XG5pcy51aW50MzJBcnJheSA9IGlzT2JqZWN0T2ZUeXBlKCdVaW50MzJBcnJheScpO1xuaXMuZmxvYXQzMkFycmF5ID0gaXNPYmplY3RPZlR5cGUoJ0Zsb2F0MzJBcnJheScpO1xuaXMuZmxvYXQ2NEFycmF5ID0gaXNPYmplY3RPZlR5cGUoJ0Zsb2F0NjRBcnJheScpO1xuaXMuYmlnSW50NjRBcnJheSA9IGlzT2JqZWN0T2ZUeXBlKCdCaWdJbnQ2NEFycmF5Jyk7XG5pcy5iaWdVaW50NjRBcnJheSA9IGlzT2JqZWN0T2ZUeXBlKCdCaWdVaW50NjRBcnJheScpO1xuaXMuYXJyYXlCdWZmZXIgPSBpc09iamVjdE9mVHlwZSgnQXJyYXlCdWZmZXInKTtcbmlzLnNoYXJlZEFycmF5QnVmZmVyID0gaXNPYmplY3RPZlR5cGUoJ1NoYXJlZEFycmF5QnVmZmVyJyk7XG5pcy5kYXRhVmlldyA9IGlzT2JqZWN0T2ZUeXBlKCdEYXRhVmlldycpO1xuaXMuZW51bUNhc2UgPSAodmFsdWUsIHRhcmdldEVudW0pID0+IE9iamVjdC52YWx1ZXModGFyZ2V0RW51bSkuaW5jbHVkZXModmFsdWUpO1xuaXMuZGlyZWN0SW5zdGFuY2VPZiA9IChpbnN0YW5jZSwgY2xhc3NfKSA9PiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdGFuY2UpID09PSBjbGFzc18ucHJvdG90eXBlO1xuaXMudXJsSW5zdGFuY2UgPSAodmFsdWUpID0+IGlzT2JqZWN0T2ZUeXBlKCdVUkwnKSh2YWx1ZSk7XG5pcy51cmxTdHJpbmcgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIWlzLnN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBuZXcgVVJMKHZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG4vLyBFeGFtcGxlOiBgaXMudHJ1dGh5ID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgKG5vdCBmYWxzZSB8IG5vdCAwIHwgbm90ICcnIHwgbm90IHVuZGVmaW5lZCB8IG5vdCBudWxsKSA9PiBCb29sZWFuKHZhbHVlKTtgXG5pcy50cnV0aHkgPSAodmFsdWUpID0+IEJvb2xlYW4odmFsdWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHVuaWNvcm4vcHJlZmVyLW5hdGl2ZS1jb2VyY2lvbi1mdW5jdGlvbnNcbi8vIEV4YW1wbGU6IGBpcy5mYWxzeSA9ICh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIChub3QgdHJ1ZSB8IDAgfCAnJyB8IHVuZGVmaW5lZCB8IG51bGwpID0+IEJvb2xlYW4odmFsdWUpO2BcbmlzLmZhbHN5ID0gKHZhbHVlKSA9PiAhdmFsdWU7XG5pcy5uYW4gPSAodmFsdWUpID0+IE51bWJlci5pc05hTih2YWx1ZSk7XG5pcy5wcmltaXRpdmUgPSAodmFsdWUpID0+IGlzLm51bGxfKHZhbHVlKSB8fCBpc1ByaW1pdGl2ZVR5cGVOYW1lKHR5cGVvZiB2YWx1ZSk7XG5pcy5pbnRlZ2VyID0gKHZhbHVlKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbmlzLnNhZmVJbnRlZ2VyID0gKHZhbHVlKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSk7XG5pcy5wbGFpbk9iamVjdCA9ICh2YWx1ZSkgPT4ge1xuICAgIC8vIEZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvaXMtcGxhaW4tb2JqL2Jsb2IvbWFpbi9pbmRleC5qc1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgcmV0dXJuIChwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpID09PSBudWxsKSAmJiAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpO1xufTtcbmlzLnR5cGVkQXJyYXkgPSAodmFsdWUpID0+IGlzVHlwZWRBcnJheU5hbWUoZ2V0T2JqZWN0VHlwZSh2YWx1ZSkpO1xuY29uc3QgaXNWYWxpZExlbmd0aCA9ICh2YWx1ZSkgPT4gaXMuc2FmZUludGVnZXIodmFsdWUpICYmIHZhbHVlID49IDA7XG5pcy5hcnJheUxpa2UgPSAodmFsdWUpID0+ICFpcy5udWxsT3JVbmRlZmluZWQodmFsdWUpICYmICFpcy5mdW5jdGlvbl8odmFsdWUpICYmIGlzVmFsaWRMZW5ndGgodmFsdWUubGVuZ3RoKTtcbmlzLmluUmFuZ2UgPSAodmFsdWUsIHJhbmdlKSA9PiB7XG4gICAgaWYgKGlzLm51bWJlcihyYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID49IE1hdGgubWluKDAsIHJhbmdlKSAmJiB2YWx1ZSA8PSBNYXRoLm1heChyYW5nZSwgMCk7XG4gICAgfVxuICAgIGlmIChpcy5hcnJheShyYW5nZSkgJiYgcmFuZ2UubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSBNYXRoLm1pbiguLi5yYW5nZSkgJiYgdmFsdWUgPD0gTWF0aC5tYXgoLi4ucmFuZ2UpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHJhbmdlOiAke0pTT04uc3RyaW5naWZ5KHJhbmdlKX1gKTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5jb25zdCBOT0RFX1RZUEVfRUxFTUVOVCA9IDE7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5jb25zdCBET01fUFJPUEVSVElFU19UT19DSEVDSyA9IFtcbiAgICAnaW5uZXJIVE1MJyxcbiAgICAnb3duZXJEb2N1bWVudCcsXG4gICAgJ3N0eWxlJyxcbiAgICAnYXR0cmlidXRlcycsXG4gICAgJ25vZGVWYWx1ZScsXG5dO1xuaXMuZG9tRWxlbWVudCA9ICh2YWx1ZSkgPT4gaXMub2JqZWN0KHZhbHVlKVxuICAgICYmIHZhbHVlLm5vZGVUeXBlID09PSBOT0RFX1RZUEVfRUxFTUVOVFxuICAgICYmIGlzLnN0cmluZyh2YWx1ZS5ub2RlTmFtZSlcbiAgICAmJiAhaXMucGxhaW5PYmplY3QodmFsdWUpXG4gICAgJiYgRE9NX1BST1BFUlRJRVNfVE9fQ0hFQ0suZXZlcnkocHJvcGVydHkgPT4gcHJvcGVydHkgaW4gdmFsdWUpO1xuaXMub2JzZXJ2YWJsZSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWV4dGVuZC1uYXRpdmUvbm8tdXNlLWV4dGVuZC1uYXRpdmUsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgIGlmICh2YWx1ZSA9PT0gdmFsdWVbU3ltYm9sLm9ic2VydmFibGVdPy4oKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgIGlmICh2YWx1ZSA9PT0gdmFsdWVbJ0BAb2JzZXJ2YWJsZSddPy4oKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmlzLm5vZGVTdHJlYW0gPSAodmFsdWUpID0+IGlzLm9iamVjdCh2YWx1ZSkgJiYgaXMuZnVuY3Rpb25fKHZhbHVlLnBpcGUpICYmICFpcy5vYnNlcnZhYmxlKHZhbHVlKTtcbmlzLmluZmluaXRlID0gKHZhbHVlKSA9PiB2YWx1ZSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IHZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5jb25zdCBpc0Fic29sdXRlTW9kMiA9IChyZW1haW5kZXIpID0+ICh2YWx1ZSkgPT4gaXMuaW50ZWdlcih2YWx1ZSkgJiYgTWF0aC5hYnModmFsdWUgJSAyKSA9PT0gcmVtYWluZGVyO1xuaXMuZXZlbkludGVnZXIgPSBpc0Fic29sdXRlTW9kMigwKTtcbmlzLm9kZEludGVnZXIgPSBpc0Fic29sdXRlTW9kMigxKTtcbmlzLmVtcHR5QXJyYXkgPSAodmFsdWUpID0+IGlzLmFycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDA7XG5pcy5ub25FbXB0eUFycmF5ID0gKHZhbHVlKSA9PiBpcy5hcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbmlzLmVtcHR5U3RyaW5nID0gKHZhbHVlKSA9PiBpcy5zdHJpbmcodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcbmNvbnN0IGlzV2hpdGVTcGFjZVN0cmluZyA9ICh2YWx1ZSkgPT4gaXMuc3RyaW5nKHZhbHVlKSAmJiAhL1xcUy8udGVzdCh2YWx1ZSk7XG5pcy5lbXB0eVN0cmluZ09yV2hpdGVzcGFjZSA9ICh2YWx1ZSkgPT4gaXMuZW1wdHlTdHJpbmcodmFsdWUpIHx8IGlzV2hpdGVTcGFjZVN0cmluZyh2YWx1ZSk7XG4vLyBUT0RPOiBVc2UgYG5vdCAnJ2Agd2hlbiB0aGUgYG5vdGAgb3BlcmF0b3IgaXMgYXZhaWxhYmxlLlxuaXMubm9uRW1wdHlTdHJpbmcgPSAodmFsdWUpID0+IGlzLnN0cmluZyh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbi8vIFRPRE86IFVzZSBgbm90ICcnYCB3aGVuIHRoZSBgbm90YCBvcGVyYXRvciBpcyBhdmFpbGFibGUuXG5pcy5ub25FbXB0eVN0cmluZ0FuZE5vdFdoaXRlc3BhY2UgPSAodmFsdWUpID0+IGlzLnN0cmluZyh2YWx1ZSkgJiYgIWlzLmVtcHR5U3RyaW5nT3JXaGl0ZXNwYWNlKHZhbHVlKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWFycmF5LWNhbGxiYWNrLXJlZmVyZW5jZVxuaXMuZW1wdHlPYmplY3QgPSAodmFsdWUpID0+IGlzLm9iamVjdCh2YWx1ZSkgJiYgIWlzLm1hcCh2YWx1ZSkgJiYgIWlzLnNldCh2YWx1ZSkgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMDtcbi8vIFRPRE86IFVzZSBgbm90YCBvcGVyYXRvciBoZXJlIHRvIHJlbW92ZSBgTWFwYCBhbmQgYFNldGAgZnJvbSB0eXBlIGd1YXJkOlxuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvcHVsbC8yOTMxN1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tYXJyYXktY2FsbGJhY2stcmVmZXJlbmNlXG5pcy5ub25FbXB0eU9iamVjdCA9ICh2YWx1ZSkgPT4gaXMub2JqZWN0KHZhbHVlKSAmJiAhaXMubWFwKHZhbHVlKSAmJiAhaXMuc2V0KHZhbHVlKSAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gMDtcbmlzLmVtcHR5U2V0ID0gKHZhbHVlKSA9PiBpcy5zZXQodmFsdWUpICYmIHZhbHVlLnNpemUgPT09IDA7XG5pcy5ub25FbXB0eVNldCA9ICh2YWx1ZSkgPT4gaXMuc2V0KHZhbHVlKSAmJiB2YWx1ZS5zaXplID4gMDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWFycmF5LWNhbGxiYWNrLXJlZmVyZW5jZVxuaXMuZW1wdHlNYXAgPSAodmFsdWUpID0+IGlzLm1hcCh2YWx1ZSkgJiYgdmFsdWUuc2l6ZSA9PT0gMDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWFycmF5LWNhbGxiYWNrLXJlZmVyZW5jZVxuaXMubm9uRW1wdHlNYXAgPSAodmFsdWUpID0+IGlzLm1hcCh2YWx1ZSkgJiYgdmFsdWUuc2l6ZSA+IDA7XG4vLyBgUHJvcGVydHlLZXlgIGlzIGFueSB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9iamVjdCBrZXkgKHN0cmluZywgbnVtYmVyLCBvciBzeW1ib2wpXG5pcy5wcm9wZXJ0eUtleSA9ICh2YWx1ZSkgPT4gaXMuYW55KFtpcy5zdHJpbmcsIGlzLm51bWJlciwgaXMuc3ltYm9sXSwgdmFsdWUpO1xuaXMuZm9ybURhdGEgPSAodmFsdWUpID0+IGlzT2JqZWN0T2ZUeXBlKCdGb3JtRGF0YScpKHZhbHVlKTtcbmlzLnVybFNlYXJjaFBhcmFtcyA9ICh2YWx1ZSkgPT4gaXNPYmplY3RPZlR5cGUoJ1VSTFNlYXJjaFBhcmFtcycpKHZhbHVlKTtcbmNvbnN0IHByZWRpY2F0ZU9uQXJyYXkgPSAobWV0aG9kLCBwcmVkaWNhdGUsIHZhbHVlcykgPT4ge1xuICAgIGlmICghaXMuZnVuY3Rpb25fKHByZWRpY2F0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwcmVkaWNhdGU6ICR7SlNPTi5zdHJpbmdpZnkocHJlZGljYXRlKX1gKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBudW1iZXIgb2YgdmFsdWVzJyk7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2QuY2FsbCh2YWx1ZXMsIHByZWRpY2F0ZSk7XG59O1xuaXMuYW55ID0gKHByZWRpY2F0ZSwgLi4udmFsdWVzKSA9PiB7XG4gICAgY29uc3QgcHJlZGljYXRlcyA9IGlzLmFycmF5KHByZWRpY2F0ZSkgPyBwcmVkaWNhdGUgOiBbcHJlZGljYXRlXTtcbiAgICByZXR1cm4gcHJlZGljYXRlcy5zb21lKHNpbmdsZVByZWRpY2F0ZSA9PiBwcmVkaWNhdGVPbkFycmF5KEFycmF5LnByb3RvdHlwZS5zb21lLCBzaW5nbGVQcmVkaWNhdGUsIHZhbHVlcykpO1xufTtcbmlzLmFsbCA9IChwcmVkaWNhdGUsIC4uLnZhbHVlcykgPT4gcHJlZGljYXRlT25BcnJheShBcnJheS5wcm90b3R5cGUuZXZlcnksIHByZWRpY2F0ZSwgdmFsdWVzKTtcbmNvbnN0IGFzc2VydFR5cGUgPSAoY29uZGl0aW9uLCBkZXNjcmlwdGlvbiwgdmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgbXVsdGlwbGVWYWx1ZXMgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHZhbHVlc01lc3NhZ2UgPSBtdWx0aXBsZVZhbHVlc1xuICAgICAgICAgICAgPyBgcmVjZWl2ZWQgdmFsdWVzIG9mIHR5cGVzICR7W1xuICAgICAgICAgICAgICAgIC4uLm5ldyBTZXQodmFsdWUubWFwKHNpbmdsZVZhbHVlID0+IGBcXGAke2lzKHNpbmdsZVZhbHVlKX1cXGBgKSksXG4gICAgICAgICAgICBdLmpvaW4oJywgJyl9YFxuICAgICAgICAgICAgOiBgcmVjZWl2ZWQgdmFsdWUgb2YgdHlwZSBcXGAke2lzKHZhbHVlKX1cXGBgO1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB2YWx1ZSB3aGljaCBpcyBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgJHt2YWx1ZXNNZXNzYWdlfS5gKTtcbiAgICB9XG59O1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWNvbmZ1c2luZy12b2lkLWV4cHJlc3Npb24gKi9cbmV4cG9ydCBjb25zdCBhc3NlcnQgPSB7XG4gICAgLy8gVW5rbm93bnMuXG4gICAgdW5kZWZpbmVkOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMudW5kZWZpbmVkKHZhbHVlKSwgJ3VuZGVmaW5lZCcsIHZhbHVlKSxcbiAgICBzdHJpbmc6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5zdHJpbmcodmFsdWUpLCAnc3RyaW5nJywgdmFsdWUpLFxuICAgIG51bWJlcjogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLm51bWJlcih2YWx1ZSksICdudW1iZXInLCB2YWx1ZSksXG4gICAgYmlnaW50OiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuYmlnaW50KHZhbHVlKSwgJ2JpZ2ludCcsIHZhbHVlKSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIGZ1bmN0aW9uXzogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLmZ1bmN0aW9uXyh2YWx1ZSksICdGdW5jdGlvbicsIHZhbHVlKSxcbiAgICBudWxsXzogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLm51bGxfKHZhbHVlKSwgJ251bGwnLCB2YWx1ZSksXG4gICAgY2xhc3NfOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuY2xhc3NfKHZhbHVlKSwgXCJDbGFzc1wiIC8qIEFzc2VydGlvblR5cGVEZXNjcmlwdGlvbi5jbGFzc18gKi8sIHZhbHVlKSxcbiAgICBib29sZWFuOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuYm9vbGVhbih2YWx1ZSksICdib29sZWFuJywgdmFsdWUpLFxuICAgIHN5bWJvbDogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLnN5bWJvbCh2YWx1ZSksICdzeW1ib2wnLCB2YWx1ZSksXG4gICAgbnVtZXJpY1N0cmluZzogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLm51bWVyaWNTdHJpbmcodmFsdWUpLCBcInN0cmluZyB3aXRoIGEgbnVtYmVyXCIgLyogQXNzZXJ0aW9uVHlwZURlc2NyaXB0aW9uLm51bWVyaWNTdHJpbmcgKi8sIHZhbHVlKSxcbiAgICBhcnJheTogKHZhbHVlLCBhc3NlcnRpb24pID0+IHtcbiAgICAgICAgY29uc3QgYXNzZXJ0ID0gYXNzZXJ0VHlwZTtcbiAgICAgICAgYXNzZXJ0KGlzLmFycmF5KHZhbHVlKSwgJ0FycmF5JywgdmFsdWUpO1xuICAgICAgICBpZiAoYXNzZXJ0aW9uKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1hcnJheS1mb3ItZWFjaCwgdW5pY29ybi9uby1hcnJheS1jYWxsYmFjay1yZWZlcmVuY2VcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goYXNzZXJ0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYnVmZmVyOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuYnVmZmVyKHZhbHVlKSwgJ0J1ZmZlcicsIHZhbHVlKSxcbiAgICBibG9iOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuYmxvYih2YWx1ZSksICdCbG9iJywgdmFsdWUpLFxuICAgIG51bGxPclVuZGVmaW5lZDogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLm51bGxPclVuZGVmaW5lZCh2YWx1ZSksIFwibnVsbCBvciB1bmRlZmluZWRcIiAvKiBBc3NlcnRpb25UeXBlRGVzY3JpcHRpb24ubnVsbE9yVW5kZWZpbmVkICovLCB2YWx1ZSksXG4gICAgb2JqZWN0OiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMub2JqZWN0KHZhbHVlKSwgJ09iamVjdCcsIHZhbHVlKSxcbiAgICBpdGVyYWJsZTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLml0ZXJhYmxlKHZhbHVlKSwgXCJJdGVyYWJsZVwiIC8qIEFzc2VydGlvblR5cGVEZXNjcmlwdGlvbi5pdGVyYWJsZSAqLywgdmFsdWUpLFxuICAgIGFzeW5jSXRlcmFibGU6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5hc3luY0l0ZXJhYmxlKHZhbHVlKSwgXCJBc3luY0l0ZXJhYmxlXCIgLyogQXNzZXJ0aW9uVHlwZURlc2NyaXB0aW9uLmFzeW5jSXRlcmFibGUgKi8sIHZhbHVlKSxcbiAgICBnZW5lcmF0b3I6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5nZW5lcmF0b3IodmFsdWUpLCAnR2VuZXJhdG9yJywgdmFsdWUpLFxuICAgIGFzeW5jR2VuZXJhdG9yOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuYXN5bmNHZW5lcmF0b3IodmFsdWUpLCAnQXN5bmNHZW5lcmF0b3InLCB2YWx1ZSksXG4gICAgbmF0aXZlUHJvbWlzZTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLm5hdGl2ZVByb21pc2UodmFsdWUpLCBcIm5hdGl2ZSBQcm9taXNlXCIgLyogQXNzZXJ0aW9uVHlwZURlc2NyaXB0aW9uLm5hdGl2ZVByb21pc2UgKi8sIHZhbHVlKSxcbiAgICBwcm9taXNlOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMucHJvbWlzZSh2YWx1ZSksICdQcm9taXNlJywgdmFsdWUpLFxuICAgIGdlbmVyYXRvckZ1bmN0aW9uOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuZ2VuZXJhdG9yRnVuY3Rpb24odmFsdWUpLCAnR2VuZXJhdG9yRnVuY3Rpb24nLCB2YWx1ZSksXG4gICAgYXN5bmNHZW5lcmF0b3JGdW5jdGlvbjogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLmFzeW5jR2VuZXJhdG9yRnVuY3Rpb24odmFsdWUpLCAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsIHZhbHVlKSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIGFzeW5jRnVuY3Rpb246ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5hc3luY0Z1bmN0aW9uKHZhbHVlKSwgJ0FzeW5jRnVuY3Rpb24nLCB2YWx1ZSksXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgICBib3VuZEZ1bmN0aW9uOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuYm91bmRGdW5jdGlvbih2YWx1ZSksICdGdW5jdGlvbicsIHZhbHVlKSxcbiAgICByZWdFeHA6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5yZWdFeHAodmFsdWUpLCAnUmVnRXhwJywgdmFsdWUpLFxuICAgIGRhdGU6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5kYXRlKHZhbHVlKSwgJ0RhdGUnLCB2YWx1ZSksXG4gICAgZXJyb3I6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5lcnJvcih2YWx1ZSksICdFcnJvcicsIHZhbHVlKSxcbiAgICBtYXA6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5tYXAodmFsdWUpLCAnTWFwJywgdmFsdWUpLFxuICAgIHNldDogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLnNldCh2YWx1ZSksICdTZXQnLCB2YWx1ZSksXG4gICAgd2Vha01hcDogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLndlYWtNYXAodmFsdWUpLCAnV2Vha01hcCcsIHZhbHVlKSxcbiAgICB3ZWFrU2V0OiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMud2Vha1NldCh2YWx1ZSksICdXZWFrU2V0JywgdmFsdWUpLFxuICAgIHdlYWtSZWY6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy53ZWFrUmVmKHZhbHVlKSwgJ1dlYWtSZWYnLCB2YWx1ZSksXG4gICAgaW50OEFycmF5OiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuaW50OEFycmF5KHZhbHVlKSwgJ0ludDhBcnJheScsIHZhbHVlKSxcbiAgICB1aW50OEFycmF5OiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMudWludDhBcnJheSh2YWx1ZSksICdVaW50OEFycmF5JywgdmFsdWUpLFxuICAgIHVpbnQ4Q2xhbXBlZEFycmF5OiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMudWludDhDbGFtcGVkQXJyYXkodmFsdWUpLCAnVWludDhDbGFtcGVkQXJyYXknLCB2YWx1ZSksXG4gICAgaW50MTZBcnJheTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLmludDE2QXJyYXkodmFsdWUpLCAnSW50MTZBcnJheScsIHZhbHVlKSxcbiAgICB1aW50MTZBcnJheTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLnVpbnQxNkFycmF5KHZhbHVlKSwgJ1VpbnQxNkFycmF5JywgdmFsdWUpLFxuICAgIGludDMyQXJyYXk6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5pbnQzMkFycmF5KHZhbHVlKSwgJ0ludDMyQXJyYXknLCB2YWx1ZSksXG4gICAgdWludDMyQXJyYXk6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy51aW50MzJBcnJheSh2YWx1ZSksICdVaW50MzJBcnJheScsIHZhbHVlKSxcbiAgICBmbG9hdDMyQXJyYXk6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5mbG9hdDMyQXJyYXkodmFsdWUpLCAnRmxvYXQzMkFycmF5JywgdmFsdWUpLFxuICAgIGZsb2F0NjRBcnJheTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLmZsb2F0NjRBcnJheSh2YWx1ZSksICdGbG9hdDY0QXJyYXknLCB2YWx1ZSksXG4gICAgYmlnSW50NjRBcnJheTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLmJpZ0ludDY0QXJyYXkodmFsdWUpLCAnQmlnSW50NjRBcnJheScsIHZhbHVlKSxcbiAgICBiaWdVaW50NjRBcnJheTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLmJpZ1VpbnQ2NEFycmF5KHZhbHVlKSwgJ0JpZ1VpbnQ2NEFycmF5JywgdmFsdWUpLFxuICAgIGFycmF5QnVmZmVyOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuYXJyYXlCdWZmZXIodmFsdWUpLCAnQXJyYXlCdWZmZXInLCB2YWx1ZSksXG4gICAgc2hhcmVkQXJyYXlCdWZmZXI6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5zaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSksICdTaGFyZWRBcnJheUJ1ZmZlcicsIHZhbHVlKSxcbiAgICBkYXRhVmlldzogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLmRhdGFWaWV3KHZhbHVlKSwgJ0RhdGFWaWV3JywgdmFsdWUpLFxuICAgIGVudW1DYXNlOiAodmFsdWUsIHRhcmdldEVudW0pID0+IGFzc2VydFR5cGUoaXMuZW51bUNhc2UodmFsdWUsIHRhcmdldEVudW0pLCAnRW51bUNhc2UnLCB2YWx1ZSksXG4gICAgdXJsSW5zdGFuY2U6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy51cmxJbnN0YW5jZSh2YWx1ZSksICdVUkwnLCB2YWx1ZSksXG4gICAgdXJsU3RyaW5nOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMudXJsU3RyaW5nKHZhbHVlKSwgXCJzdHJpbmcgd2l0aCBhIFVSTFwiIC8qIEFzc2VydGlvblR5cGVEZXNjcmlwdGlvbi51cmxTdHJpbmcgKi8sIHZhbHVlKSxcbiAgICB0cnV0aHk6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy50cnV0aHkodmFsdWUpLCBcInRydXRoeVwiIC8qIEFzc2VydGlvblR5cGVEZXNjcmlwdGlvbi50cnV0aHkgKi8sIHZhbHVlKSxcbiAgICBmYWxzeTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLmZhbHN5KHZhbHVlKSwgXCJmYWxzeVwiIC8qIEFzc2VydGlvblR5cGVEZXNjcmlwdGlvbi5mYWxzeSAqLywgdmFsdWUpLFxuICAgIG5hbjogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLm5hbih2YWx1ZSksIFwiTmFOXCIgLyogQXNzZXJ0aW9uVHlwZURlc2NyaXB0aW9uLm5hbiAqLywgdmFsdWUpLFxuICAgIHByaW1pdGl2ZTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLnByaW1pdGl2ZSh2YWx1ZSksIFwicHJpbWl0aXZlXCIgLyogQXNzZXJ0aW9uVHlwZURlc2NyaXB0aW9uLnByaW1pdGl2ZSAqLywgdmFsdWUpLFxuICAgIGludGVnZXI6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5pbnRlZ2VyKHZhbHVlKSwgXCJpbnRlZ2VyXCIgLyogQXNzZXJ0aW9uVHlwZURlc2NyaXB0aW9uLmludGVnZXIgKi8sIHZhbHVlKSxcbiAgICBzYWZlSW50ZWdlcjogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLnNhZmVJbnRlZ2VyKHZhbHVlKSwgXCJpbnRlZ2VyXCIgLyogQXNzZXJ0aW9uVHlwZURlc2NyaXB0aW9uLnNhZmVJbnRlZ2VyICovLCB2YWx1ZSksXG4gICAgcGxhaW5PYmplY3Q6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5wbGFpbk9iamVjdCh2YWx1ZSksIFwicGxhaW4gb2JqZWN0XCIgLyogQXNzZXJ0aW9uVHlwZURlc2NyaXB0aW9uLnBsYWluT2JqZWN0ICovLCB2YWx1ZSksXG4gICAgdHlwZWRBcnJheTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLnR5cGVkQXJyYXkodmFsdWUpLCBcIlR5cGVkQXJyYXlcIiAvKiBBc3NlcnRpb25UeXBlRGVzY3JpcHRpb24udHlwZWRBcnJheSAqLywgdmFsdWUpLFxuICAgIGFycmF5TGlrZTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLmFycmF5TGlrZSh2YWx1ZSksIFwiYXJyYXktbGlrZVwiIC8qIEFzc2VydGlvblR5cGVEZXNjcmlwdGlvbi5hcnJheUxpa2UgKi8sIHZhbHVlKSxcbiAgICBkb21FbGVtZW50OiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuZG9tRWxlbWVudCh2YWx1ZSksIFwiSFRNTEVsZW1lbnRcIiAvKiBBc3NlcnRpb25UeXBlRGVzY3JpcHRpb24uZG9tRWxlbWVudCAqLywgdmFsdWUpLFxuICAgIG9ic2VydmFibGU6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5vYnNlcnZhYmxlKHZhbHVlKSwgJ09ic2VydmFibGUnLCB2YWx1ZSksXG4gICAgbm9kZVN0cmVhbTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLm5vZGVTdHJlYW0odmFsdWUpLCBcIk5vZGUuanMgU3RyZWFtXCIgLyogQXNzZXJ0aW9uVHlwZURlc2NyaXB0aW9uLm5vZGVTdHJlYW0gKi8sIHZhbHVlKSxcbiAgICBpbmZpbml0ZTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLmluZmluaXRlKHZhbHVlKSwgXCJpbmZpbml0ZSBudW1iZXJcIiAvKiBBc3NlcnRpb25UeXBlRGVzY3JpcHRpb24uaW5maW5pdGUgKi8sIHZhbHVlKSxcbiAgICBlbXB0eUFycmF5OiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuZW1wdHlBcnJheSh2YWx1ZSksIFwiZW1wdHkgYXJyYXlcIiAvKiBBc3NlcnRpb25UeXBlRGVzY3JpcHRpb24uZW1wdHlBcnJheSAqLywgdmFsdWUpLFxuICAgIG5vbkVtcHR5QXJyYXk6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5ub25FbXB0eUFycmF5KHZhbHVlKSwgXCJub24tZW1wdHkgYXJyYXlcIiAvKiBBc3NlcnRpb25UeXBlRGVzY3JpcHRpb24ubm9uRW1wdHlBcnJheSAqLywgdmFsdWUpLFxuICAgIGVtcHR5U3RyaW5nOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuZW1wdHlTdHJpbmcodmFsdWUpLCBcImVtcHR5IHN0cmluZ1wiIC8qIEFzc2VydGlvblR5cGVEZXNjcmlwdGlvbi5lbXB0eVN0cmluZyAqLywgdmFsdWUpLFxuICAgIGVtcHR5U3RyaW5nT3JXaGl0ZXNwYWNlOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuZW1wdHlTdHJpbmdPcldoaXRlc3BhY2UodmFsdWUpLCBcImVtcHR5IHN0cmluZyBvciB3aGl0ZXNwYWNlXCIgLyogQXNzZXJ0aW9uVHlwZURlc2NyaXB0aW9uLmVtcHR5U3RyaW5nT3JXaGl0ZXNwYWNlICovLCB2YWx1ZSksXG4gICAgbm9uRW1wdHlTdHJpbmc6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5ub25FbXB0eVN0cmluZyh2YWx1ZSksIFwibm9uLWVtcHR5IHN0cmluZ1wiIC8qIEFzc2VydGlvblR5cGVEZXNjcmlwdGlvbi5ub25FbXB0eVN0cmluZyAqLywgdmFsdWUpLFxuICAgIG5vbkVtcHR5U3RyaW5nQW5kTm90V2hpdGVzcGFjZTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLm5vbkVtcHR5U3RyaW5nQW5kTm90V2hpdGVzcGFjZSh2YWx1ZSksIFwibm9uLWVtcHR5IHN0cmluZyBhbmQgbm90IHdoaXRlc3BhY2VcIiAvKiBBc3NlcnRpb25UeXBlRGVzY3JpcHRpb24ubm9uRW1wdHlTdHJpbmdBbmROb3RXaGl0ZXNwYWNlICovLCB2YWx1ZSksXG4gICAgZW1wdHlPYmplY3Q6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5lbXB0eU9iamVjdCh2YWx1ZSksIFwiZW1wdHkgb2JqZWN0XCIgLyogQXNzZXJ0aW9uVHlwZURlc2NyaXB0aW9uLmVtcHR5T2JqZWN0ICovLCB2YWx1ZSksXG4gICAgbm9uRW1wdHlPYmplY3Q6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5ub25FbXB0eU9iamVjdCh2YWx1ZSksIFwibm9uLWVtcHR5IG9iamVjdFwiIC8qIEFzc2VydGlvblR5cGVEZXNjcmlwdGlvbi5ub25FbXB0eU9iamVjdCAqLywgdmFsdWUpLFxuICAgIGVtcHR5U2V0OiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMuZW1wdHlTZXQodmFsdWUpLCBcImVtcHR5IHNldFwiIC8qIEFzc2VydGlvblR5cGVEZXNjcmlwdGlvbi5lbXB0eVNldCAqLywgdmFsdWUpLFxuICAgIG5vbkVtcHR5U2V0OiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMubm9uRW1wdHlTZXQodmFsdWUpLCBcIm5vbi1lbXB0eSBzZXRcIiAvKiBBc3NlcnRpb25UeXBlRGVzY3JpcHRpb24ubm9uRW1wdHlTZXQgKi8sIHZhbHVlKSxcbiAgICBlbXB0eU1hcDogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLmVtcHR5TWFwKHZhbHVlKSwgXCJlbXB0eSBtYXBcIiAvKiBBc3NlcnRpb25UeXBlRGVzY3JpcHRpb24uZW1wdHlNYXAgKi8sIHZhbHVlKSxcbiAgICBub25FbXB0eU1hcDogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLm5vbkVtcHR5TWFwKHZhbHVlKSwgXCJub24tZW1wdHkgbWFwXCIgLyogQXNzZXJ0aW9uVHlwZURlc2NyaXB0aW9uLm5vbkVtcHR5TWFwICovLCB2YWx1ZSksXG4gICAgcHJvcGVydHlLZXk6ICh2YWx1ZSkgPT4gYXNzZXJ0VHlwZShpcy5wcm9wZXJ0eUtleSh2YWx1ZSksICdQcm9wZXJ0eUtleScsIHZhbHVlKSxcbiAgICBmb3JtRGF0YTogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLmZvcm1EYXRhKHZhbHVlKSwgJ0Zvcm1EYXRhJywgdmFsdWUpLFxuICAgIHVybFNlYXJjaFBhcmFtczogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLnVybFNlYXJjaFBhcmFtcyh2YWx1ZSksICdVUkxTZWFyY2hQYXJhbXMnLCB2YWx1ZSksXG4gICAgLy8gTnVtYmVycy5cbiAgICBldmVuSW50ZWdlcjogKHZhbHVlKSA9PiBhc3NlcnRUeXBlKGlzLmV2ZW5JbnRlZ2VyKHZhbHVlKSwgXCJldmVuIGludGVnZXJcIiAvKiBBc3NlcnRpb25UeXBlRGVzY3JpcHRpb24uZXZlbkludGVnZXIgKi8sIHZhbHVlKSxcbiAgICBvZGRJbnRlZ2VyOiAodmFsdWUpID0+IGFzc2VydFR5cGUoaXMub2RkSW50ZWdlcih2YWx1ZSksIFwib2RkIGludGVnZXJcIiAvKiBBc3NlcnRpb25UeXBlRGVzY3JpcHRpb24ub2RkSW50ZWdlciAqLywgdmFsdWUpLFxuICAgIC8vIFR3byBhcmd1bWVudHMuXG4gICAgZGlyZWN0SW5zdGFuY2VPZjogKGluc3RhbmNlLCBjbGFzc18pID0+IGFzc2VydFR5cGUoaXMuZGlyZWN0SW5zdGFuY2VPZihpbnN0YW5jZSwgY2xhc3NfKSwgXCJUXCIgLyogQXNzZXJ0aW9uVHlwZURlc2NyaXB0aW9uLmRpcmVjdEluc3RhbmNlT2YgKi8sIGluc3RhbmNlKSxcbiAgICBpblJhbmdlOiAodmFsdWUsIHJhbmdlKSA9PiBhc3NlcnRUeXBlKGlzLmluUmFuZ2UodmFsdWUsIHJhbmdlKSwgXCJpbiByYW5nZVwiIC8qIEFzc2VydGlvblR5cGVEZXNjcmlwdGlvbi5pblJhbmdlICovLCB2YWx1ZSksXG4gICAgLy8gVmFyaWFkaWMgZnVuY3Rpb25zLlxuICAgIGFueTogKHByZWRpY2F0ZSwgLi4udmFsdWVzKSA9PiBhc3NlcnRUeXBlKGlzLmFueShwcmVkaWNhdGUsIC4uLnZhbHVlcyksIFwicHJlZGljYXRlIHJldHVybnMgdHJ1dGh5IGZvciBhbnkgdmFsdWVcIiAvKiBBc3NlcnRpb25UeXBlRGVzY3JpcHRpb24uYW55ICovLCB2YWx1ZXMsIHsgbXVsdGlwbGVWYWx1ZXM6IHRydWUgfSksXG4gICAgYWxsOiAocHJlZGljYXRlLCAuLi52YWx1ZXMpID0+IGFzc2VydFR5cGUoaXMuYWxsKHByZWRpY2F0ZSwgLi4udmFsdWVzKSwgXCJwcmVkaWNhdGUgcmV0dXJucyB0cnV0aHkgZm9yIGFsbCB2YWx1ZXNcIiAvKiBBc3NlcnRpb25UeXBlRGVzY3JpcHRpb24uYWxsICovLCB2YWx1ZXMsIHsgbXVsdGlwbGVWYWx1ZXM6IHRydWUgfSksXG59O1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tY29uZnVzaW5nLXZvaWQtZXhwcmVzc2lvbiAqL1xuLy8gU29tZSBmZXcga2V5d29yZHMgYXJlIHJlc2VydmVkLCBidXQgd2UnbGwgcG9wdWxhdGUgdGhlbSBmb3IgTm9kZS5qcyB1c2Vyc1xuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjUzNlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaXMsIHtcbiAgICBjbGFzczoge1xuICAgICAgICB2YWx1ZTogaXMuY2xhc3NfLFxuICAgIH0sXG4gICAgZnVuY3Rpb246IHtcbiAgICAgICAgdmFsdWU6IGlzLmZ1bmN0aW9uXyxcbiAgICB9LFxuICAgIG51bGw6IHtcbiAgICAgICAgdmFsdWU6IGlzLm51bGxfLFxuICAgIH0sXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGFzc2VydCwge1xuICAgIGNsYXNzOiB7XG4gICAgICAgIHZhbHVlOiBhc3NlcnQuY2xhc3NfLFxuICAgIH0sXG4gICAgZnVuY3Rpb246IHtcbiAgICAgICAgdmFsdWU6IGFzc2VydC5mdW5jdGlvbl8sXG4gICAgfSxcbiAgICBudWxsOiB7XG4gICAgICAgIHZhbHVlOiBhc3NlcnQubnVsbF8sXG4gICAgfSxcbn0pO1xuZXhwb3J0IGRlZmF1bHQgaXM7XG4iLCJpbXBvcnQgeyBlcnJvck1vbml0b3IgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgdHlwZXMgfSBmcm9tICd1dGlsJztcbmltcG9ydCBkZWZlclRvQ29ubmVjdCBmcm9tICdkZWZlci10by1jb25uZWN0JztcbmNvbnN0IHRpbWVyID0gKHJlcXVlc3QpID0+IHtcbiAgICBpZiAocmVxdWVzdC50aW1pbmdzKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0LnRpbWluZ3M7XG4gICAgfVxuICAgIGNvbnN0IHRpbWluZ3MgPSB7XG4gICAgICAgIHN0YXJ0OiBEYXRlLm5vdygpLFxuICAgICAgICBzb2NrZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgbG9va3VwOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbm5lY3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VjdXJlQ29ubmVjdDogdW5kZWZpbmVkLFxuICAgICAgICB1cGxvYWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVzcG9uc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgZW5kOiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIGFib3J0OiB1bmRlZmluZWQsXG4gICAgICAgIHBoYXNlczoge1xuICAgICAgICAgICAgd2FpdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG5zOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0Y3A6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRsczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVxdWVzdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlyc3RCeXRlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkb3dubG9hZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdG90YWw6IHVuZGVmaW5lZCxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJlcXVlc3QudGltaW5ncyA9IHRpbWluZ3M7XG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSAob3JpZ2luKSA9PiB7XG4gICAgICAgIG9yaWdpbi5vbmNlKGVycm9yTW9uaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgdGltaW5ncy5lcnJvciA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB0aW1pbmdzLnBoYXNlcy50b3RhbCA9IHRpbWluZ3MuZXJyb3IgLSB0aW1pbmdzLnN0YXJ0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGhhbmRsZUVycm9yKHJlcXVlc3QpO1xuICAgIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB7XG4gICAgICAgIHRpbWluZ3MuYWJvcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aW1pbmdzLnBoYXNlcy50b3RhbCA9IHRpbWluZ3MuYWJvcnQgLSB0aW1pbmdzLnN0YXJ0O1xuICAgIH07XG4gICAgcmVxdWVzdC5wcmVwZW5kT25jZUxpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQpO1xuICAgIGNvbnN0IG9uU29ja2V0ID0gKHNvY2tldCkgPT4ge1xuICAgICAgICB0aW1pbmdzLnNvY2tldCA9IERhdGUubm93KCk7XG4gICAgICAgIHRpbWluZ3MucGhhc2VzLndhaXQgPSB0aW1pbmdzLnNvY2tldCAtIHRpbWluZ3Muc3RhcnQ7XG4gICAgICAgIGlmICh0eXBlcy5pc1Byb3h5KHNvY2tldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb29rdXBMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRpbWluZ3MubG9va3VwID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRpbWluZ3MucGhhc2VzLmRucyA9IHRpbWluZ3MubG9va3VwIC0gdGltaW5ncy5zb2NrZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHNvY2tldC5wcmVwZW5kT25jZUxpc3RlbmVyKCdsb29rdXAnLCBsb29rdXBMaXN0ZW5lcik7XG4gICAgICAgIGRlZmVyVG9Db25uZWN0KHNvY2tldCwge1xuICAgICAgICAgICAgY29ubmVjdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRpbWluZ3MuY29ubmVjdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWluZ3MubG9va3VwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdsb29rdXAnLCBsb29rdXBMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHRpbWluZ3MubG9va3VwID0gdGltaW5ncy5jb25uZWN0O1xuICAgICAgICAgICAgICAgICAgICB0aW1pbmdzLnBoYXNlcy5kbnMgPSB0aW1pbmdzLmxvb2t1cCAtIHRpbWluZ3Muc29ja2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aW1pbmdzLnBoYXNlcy50Y3AgPSB0aW1pbmdzLmNvbm5lY3QgLSB0aW1pbmdzLmxvb2t1cDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWN1cmVDb25uZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGltaW5ncy5zZWN1cmVDb25uZWN0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICB0aW1pbmdzLnBoYXNlcy50bHMgPSB0aW1pbmdzLnNlY3VyZUNvbm5lY3QgLSB0aW1pbmdzLmNvbm5lY3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChyZXF1ZXN0LnNvY2tldCkge1xuICAgICAgICBvblNvY2tldChyZXF1ZXN0LnNvY2tldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXF1ZXN0LnByZXBlbmRPbmNlTGlzdGVuZXIoJ3NvY2tldCcsIG9uU29ja2V0KTtcbiAgICB9XG4gICAgY29uc3Qgb25VcGxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHRpbWluZ3MudXBsb2FkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGltaW5ncy5waGFzZXMucmVxdWVzdCA9IHRpbWluZ3MudXBsb2FkIC0gKHRpbWluZ3Muc2VjdXJlQ29ubmVjdCA/PyB0aW1pbmdzLmNvbm5lY3QpO1xuICAgIH07XG4gICAgaWYgKHJlcXVlc3Qud3JpdGFibGVGaW5pc2hlZCkge1xuICAgICAgICBvblVwbG9hZCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVxdWVzdC5wcmVwZW5kT25jZUxpc3RlbmVyKCdmaW5pc2gnLCBvblVwbG9hZCk7XG4gICAgfVxuICAgIHJlcXVlc3QucHJlcGVuZE9uY2VMaXN0ZW5lcigncmVzcG9uc2UnLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgdGltaW5ncy5yZXNwb25zZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRpbWluZ3MucGhhc2VzLmZpcnN0Qnl0ZSA9IHRpbWluZ3MucmVzcG9uc2UgLSB0aW1pbmdzLnVwbG9hZDtcbiAgICAgICAgcmVzcG9uc2UudGltaW5ncyA9IHRpbWluZ3M7XG4gICAgICAgIGhhbmRsZUVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgcmVzcG9uc2UucHJlcGVuZE9uY2VMaXN0ZW5lcignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5vZmYoJ2Fib3J0Jywgb25BYm9ydCk7XG4gICAgICAgICAgICByZXNwb25zZS5vZmYoJ2Fib3J0ZWQnLCBvbkFib3J0KTtcbiAgICAgICAgICAgIGlmICh0aW1pbmdzLnBoYXNlcy50b3RhbCkge1xuICAgICAgICAgICAgICAgIC8vIEFib3J0ZWQgb3IgZXJyb3JlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbWluZ3MuZW5kID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRpbWluZ3MucGhhc2VzLmRvd25sb2FkID0gdGltaW5ncy5lbmQgLSB0aW1pbmdzLnJlc3BvbnNlO1xuICAgICAgICAgICAgdGltaW5ncy5waGFzZXMudG90YWwgPSB0aW1pbmdzLmVuZCAtIHRpbWluZ3Muc3RhcnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNwb25zZS5wcmVwZW5kT25jZUxpc3RlbmVyKCdhYm9ydGVkJywgb25BYm9ydCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRpbWluZ3M7XG59O1xuZXhwb3J0IGRlZmF1bHQgdGltZXI7XG4iLCJpbXBvcnQge1xuXHRWNE1BUFBFRCxcblx0QUREUkNPTkZJRyxcblx0QUxMLFxuXHRwcm9taXNlcyBhcyBkbnNQcm9taXNlcyxcblx0bG9va3VwIGFzIGRuc0xvb2t1cFxufSBmcm9tICdub2RlOmRucyc7XG5pbXBvcnQge3Byb21pc2lmeX0gZnJvbSAnbm9kZTp1dGlsJztcbmltcG9ydCBvcyBmcm9tICdub2RlOm9zJztcblxuY29uc3Qge1Jlc29sdmVyOiBBc3luY1Jlc29sdmVyfSA9IGRuc1Byb21pc2VzO1xuXG5jb25zdCBrQ2FjaGVhYmxlTG9va3VwQ3JlYXRlQ29ubmVjdGlvbiA9IFN5bWJvbCgnY2FjaGVhYmxlTG9va3VwQ3JlYXRlQ29ubmVjdGlvbicpO1xuY29uc3Qga0NhY2hlYWJsZUxvb2t1cEluc3RhbmNlID0gU3ltYm9sKCdjYWNoZWFibGVMb29rdXBJbnN0YW5jZScpO1xuY29uc3Qga0V4cGlyZXMgPSBTeW1ib2woJ2V4cGlyZXMnKTtcblxuY29uc3Qgc3VwcG9ydHNBTEwgPSB0eXBlb2YgQUxMID09PSAnbnVtYmVyJztcblxuY29uc3QgdmVyaWZ5QWdlbnQgPSBhZ2VudCA9PiB7XG5cdGlmICghKGFnZW50ICYmIHR5cGVvZiBhZ2VudC5jcmVhdGVDb25uZWN0aW9uID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYW4gQWdlbnQgaW5zdGFuY2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50Jyk7XG5cdH1cbn07XG5cbmNvbnN0IG1hcDR0bzYgPSBlbnRyaWVzID0+IHtcblx0Zm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG5cdFx0aWYgKGVudHJ5LmZhbWlseSA9PT0gNikge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZW50cnkuYWRkcmVzcyA9IGA6OmZmZmY6JHtlbnRyeS5hZGRyZXNzfWA7XG5cdFx0ZW50cnkuZmFtaWx5ID0gNjtcblx0fVxufTtcblxuY29uc3QgZ2V0SWZhY2VJbmZvID0gKCkgPT4ge1xuXHRsZXQgaGFzNCA9IGZhbHNlO1xuXHRsZXQgaGFzNiA9IGZhbHNlO1xuXG5cdGZvciAoY29uc3QgZGV2aWNlIG9mIE9iamVjdC52YWx1ZXMob3MubmV0d29ya0ludGVyZmFjZXMoKSkpIHtcblx0XHRmb3IgKGNvbnN0IGlmYWNlIG9mIGRldmljZSkge1xuXHRcdFx0aWYgKGlmYWNlLmludGVybmFsKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaWZhY2UuZmFtaWx5ID09PSAnSVB2NicpIHtcblx0XHRcdFx0aGFzNiA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYXM0ID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGhhczQgJiYgaGFzNikge1xuXHRcdFx0XHRyZXR1cm4ge2hhczQsIGhhczZ9O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7aGFzNCwgaGFzNn07XG59O1xuXG5jb25zdCBpc0l0ZXJhYmxlID0gbWFwID0+IHtcblx0cmV0dXJuIFN5bWJvbC5pdGVyYXRvciBpbiBtYXA7XG59O1xuXG5jb25zdCBpZ25vcmVOb1Jlc3VsdEVycm9ycyA9IGRuc1Byb21pc2UgPT4ge1xuXHRyZXR1cm4gZG5zUHJvbWlzZS5jYXRjaChlcnJvciA9PiB7XG5cdFx0aWYgKFxuXHRcdFx0ZXJyb3IuY29kZSA9PT0gJ0VOT0RBVEEnIHx8XG5cdFx0XHRlcnJvci5jb2RlID09PSAnRU5PVEZPVU5EJyB8fFxuXHRcdFx0ZXJyb3IuY29kZSA9PT0gJ0VOT0VOVCcgLy8gV2luZG93czogbmFtZSBleGlzdHMsIGJ1dCBub3QgdGhpcyByZWNvcmQgdHlwZVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblxuXHRcdHRocm93IGVycm9yO1xuXHR9KTtcbn07XG5cbmNvbnN0IHR0bCA9IHt0dGw6IHRydWV9O1xuY29uc3QgYWxsID0ge2FsbDogdHJ1ZX07XG5jb25zdCBhbGw0ID0ge2FsbDogdHJ1ZSwgZmFtaWx5OiA0fTtcbmNvbnN0IGFsbDYgPSB7YWxsOiB0cnVlLCBmYW1pbHk6IDZ9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYWNoZWFibGVMb29rdXAge1xuXHRjb25zdHJ1Y3Rvcih7XG5cdFx0Y2FjaGUgPSBuZXcgTWFwKCksXG5cdFx0bWF4VHRsID0gSW5maW5pdHksXG5cdFx0ZmFsbGJhY2tEdXJhdGlvbiA9IDM2MDAsXG5cdFx0ZXJyb3JUdGwgPSAwLjE1LFxuXHRcdHJlc29sdmVyID0gbmV3IEFzeW5jUmVzb2x2ZXIoKSxcblx0XHRsb29rdXAgPSBkbnNMb29rdXBcblx0fSA9IHt9KSB7XG5cdFx0dGhpcy5tYXhUdGwgPSBtYXhUdGw7XG5cdFx0dGhpcy5lcnJvclR0bCA9IGVycm9yVHRsO1xuXG5cdFx0dGhpcy5fY2FjaGUgPSBjYWNoZTtcblx0XHR0aGlzLl9yZXNvbHZlciA9IHJlc29sdmVyO1xuXHRcdHRoaXMuX2Ruc0xvb2t1cCA9IGxvb2t1cCAmJiBwcm9taXNpZnkobG9va3VwKTtcblx0XHR0aGlzLnN0YXRzID0ge1xuXHRcdFx0Y2FjaGU6IDAsXG5cdFx0XHRxdWVyeTogMFxuXHRcdH07XG5cblx0XHRpZiAodGhpcy5fcmVzb2x2ZXIgaW5zdGFuY2VvZiBBc3luY1Jlc29sdmVyKSB7XG5cdFx0XHR0aGlzLl9yZXNvbHZlNCA9IHRoaXMuX3Jlc29sdmVyLnJlc29sdmU0LmJpbmQodGhpcy5fcmVzb2x2ZXIpO1xuXHRcdFx0dGhpcy5fcmVzb2x2ZTYgPSB0aGlzLl9yZXNvbHZlci5yZXNvbHZlNi5iaW5kKHRoaXMuX3Jlc29sdmVyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVzb2x2ZTQgPSBwcm9taXNpZnkodGhpcy5fcmVzb2x2ZXIucmVzb2x2ZTQuYmluZCh0aGlzLl9yZXNvbHZlcikpO1xuXHRcdFx0dGhpcy5fcmVzb2x2ZTYgPSBwcm9taXNpZnkodGhpcy5fcmVzb2x2ZXIucmVzb2x2ZTYuYmluZCh0aGlzLl9yZXNvbHZlcikpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2lmYWNlID0gZ2V0SWZhY2VJbmZvKCk7XG5cblx0XHR0aGlzLl9wZW5kaW5nID0ge307XG5cdFx0dGhpcy5fbmV4dFJlbW92YWxUaW1lID0gZmFsc2U7XG5cdFx0dGhpcy5faG9zdG5hbWVzVG9GYWxsYmFjayA9IG5ldyBTZXQoKTtcblxuXHRcdHRoaXMuZmFsbGJhY2tEdXJhdGlvbiA9IGZhbGxiYWNrRHVyYXRpb247XG5cblx0XHRpZiAoZmFsbGJhY2tEdXJhdGlvbiA+IDApIHtcblx0XHRcdGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuXHRcdFx0XHR0aGlzLl9ob3N0bmFtZXNUb0ZhbGxiYWNrLmNsZWFyKCk7XG5cdFx0XHR9LCBmYWxsYmFja0R1cmF0aW9uICogMTAwMCk7XG5cblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBUaGVyZSBpcyBubyBgaW50ZXJ2YWwudW5yZWYoKWAgd2hlbiBydW5uaW5nIGluc2lkZSBhbiBFbGVjdHJvbiByZW5kZXJlciAqL1xuXHRcdFx0aWYgKGludGVydmFsLnVucmVmKSB7XG5cdFx0XHRcdGludGVydmFsLnVucmVmKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2ZhbGxiYWNrSW50ZXJ2YWwgPSBpbnRlcnZhbDtcblx0XHR9XG5cblx0XHR0aGlzLmxvb2t1cCA9IHRoaXMubG9va3VwLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5sb29rdXBBc3luYyA9IHRoaXMubG9va3VwQXN5bmMuYmluZCh0aGlzKTtcblx0fVxuXG5cdHNldCBzZXJ2ZXJzKHNlcnZlcnMpIHtcblx0XHR0aGlzLmNsZWFyKCk7XG5cblx0XHR0aGlzLl9yZXNvbHZlci5zZXRTZXJ2ZXJzKHNlcnZlcnMpO1xuXHR9XG5cblx0Z2V0IHNlcnZlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Jlc29sdmVyLmdldFNlcnZlcnMoKTtcblx0fVxuXG5cdGxvb2t1cChob3N0bmFtZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNhbGxiYWNrID0gb3B0aW9ucztcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuXHRcdFx0b3B0aW9ucyA9IHtcblx0XHRcdFx0ZmFtaWx5OiBvcHRpb25zXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmICghY2FsbGJhY2spIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuXHRcdH1cblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuXG5cdFx0dGhpcy5sb29rdXBBc3luYyhob3N0bmFtZSwgb3B0aW9ucykudGhlbihyZXN1bHQgPT4ge1xuXHRcdFx0aWYgKG9wdGlvbnMuYWxsKSB7XG5cdFx0XHRcdGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCByZXN1bHQuYWRkcmVzcywgcmVzdWx0LmZhbWlseSwgcmVzdWx0LmV4cGlyZXMsIHJlc3VsdC50dGwsIHJlc3VsdC5zb3VyY2UpO1xuXHRcdFx0fVxuXHRcdH0sIGNhbGxiYWNrKTtcblx0fVxuXG5cdGFzeW5jIGxvb2t1cEFzeW5jKGhvc3RuYW1lLCBvcHRpb25zID0ge30pIHtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG5cdFx0XHRvcHRpb25zID0ge1xuXHRcdFx0XHRmYW1pbHk6IG9wdGlvbnNcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0bGV0IGNhY2hlZCA9IGF3YWl0IHRoaXMucXVlcnkoaG9zdG5hbWUpO1xuXG5cdFx0aWYgKG9wdGlvbnMuZmFtaWx5ID09PSA2KSB7XG5cdFx0XHRjb25zdCBmaWx0ZXJlZCA9IGNhY2hlZC5maWx0ZXIoZW50cnkgPT4gZW50cnkuZmFtaWx5ID09PSA2KTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuaGludHMgJiBWNE1BUFBFRCkge1xuXHRcdFx0XHRpZiAoKHN1cHBvcnRzQUxMICYmIG9wdGlvbnMuaGludHMgJiBBTEwpIHx8IGZpbHRlcmVkLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdG1hcDR0bzYoY2FjaGVkKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYWNoZWQgPSBmaWx0ZXJlZDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FjaGVkID0gZmlsdGVyZWQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLmZhbWlseSA9PT0gNCkge1xuXHRcdFx0Y2FjaGVkID0gY2FjaGVkLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5mYW1pbHkgPT09IDQpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmhpbnRzICYgQUREUkNPTkZJRykge1xuXHRcdFx0Y29uc3Qge19pZmFjZX0gPSB0aGlzO1xuXHRcdFx0Y2FjaGVkID0gY2FjaGVkLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5mYW1pbHkgPT09IDYgPyBfaWZhY2UuaGFzNiA6IF9pZmFjZS5oYXM0KTtcblx0XHR9XG5cblx0XHRpZiAoY2FjaGVkLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGNhY2hlYWJsZUxvb2t1cCBFTk9URk9VTkQgJHtob3N0bmFtZX1gKTtcblx0XHRcdGVycm9yLmNvZGUgPSAnRU5PVEZPVU5EJztcblx0XHRcdGVycm9yLmhvc3RuYW1lID0gaG9zdG5hbWU7XG5cblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmFsbCkge1xuXHRcdFx0cmV0dXJuIGNhY2hlZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2FjaGVkWzBdO1xuXHR9XG5cblx0YXN5bmMgcXVlcnkoaG9zdG5hbWUpIHtcblx0XHRsZXQgc291cmNlID0gJ2NhY2hlJztcblx0XHRsZXQgY2FjaGVkID0gYXdhaXQgdGhpcy5fY2FjaGUuZ2V0KGhvc3RuYW1lKTtcblxuXHRcdGlmIChjYWNoZWQpIHtcblx0XHRcdHRoaXMuc3RhdHMuY2FjaGUrKztcblx0XHR9XG5cblx0XHRpZiAoIWNhY2hlZCkge1xuXHRcdFx0Y29uc3QgcGVuZGluZyA9IHRoaXMuX3BlbmRpbmdbaG9zdG5hbWVdO1xuXHRcdFx0aWYgKHBlbmRpbmcpIHtcblx0XHRcdFx0dGhpcy5zdGF0cy5jYWNoZSsrO1xuXHRcdFx0XHRjYWNoZWQgPSBhd2FpdCBwZW5kaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c291cmNlID0gJ3F1ZXJ5Jztcblx0XHRcdFx0Y29uc3QgbmV3UHJvbWlzZSA9IHRoaXMucXVlcnlBbmRDYWNoZShob3N0bmFtZSk7XG5cdFx0XHRcdHRoaXMuX3BlbmRpbmdbaG9zdG5hbWVdID0gbmV3UHJvbWlzZTtcblx0XHRcdFx0dGhpcy5zdGF0cy5xdWVyeSsrO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNhY2hlZCA9IGF3YWl0IG5ld1Byb21pc2U7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3BlbmRpbmdbaG9zdG5hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y2FjaGVkID0gY2FjaGVkLm1hcChlbnRyeSA9PiB7XG5cdFx0XHRyZXR1cm4gey4uLmVudHJ5LCBzb3VyY2V9O1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNhY2hlZDtcblx0fVxuXG5cdGFzeW5jIF9yZXNvbHZlKGhvc3RuYW1lKSB7XG5cdFx0Ly8gQU5ZIGlzIHVuc2FmZSBhcyBpdCBkb2Vzbid0IHRyaWdnZXIgbmV3IHF1ZXJpZXMgaW4gdGhlIHVuZGVybHlpbmcgc2VydmVyLlxuXHRcdGNvbnN0IFtBLCBBQUFBXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcblx0XHRcdGlnbm9yZU5vUmVzdWx0RXJyb3JzKHRoaXMuX3Jlc29sdmU0KGhvc3RuYW1lLCB0dGwpKSxcblx0XHRcdGlnbm9yZU5vUmVzdWx0RXJyb3JzKHRoaXMuX3Jlc29sdmU2KGhvc3RuYW1lLCB0dGwpKVxuXHRcdF0pO1xuXG5cdFx0bGV0IGFUdGwgPSAwO1xuXHRcdGxldCBhYWFhVHRsID0gMDtcblx0XHRsZXQgY2FjaGVUdGwgPSAwO1xuXG5cdFx0Y29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuXHRcdGZvciAoY29uc3QgZW50cnkgb2YgQSkge1xuXHRcdFx0ZW50cnkuZmFtaWx5ID0gNDtcblx0XHRcdGVudHJ5LmV4cGlyZXMgPSBub3cgKyAoZW50cnkudHRsICogMTAwMCk7XG5cblx0XHRcdGFUdGwgPSBNYXRoLm1heChhVHRsLCBlbnRyeS50dGwpO1xuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgZW50cnkgb2YgQUFBQSkge1xuXHRcdFx0ZW50cnkuZmFtaWx5ID0gNjtcblx0XHRcdGVudHJ5LmV4cGlyZXMgPSBub3cgKyAoZW50cnkudHRsICogMTAwMCk7XG5cblx0XHRcdGFhYWFUdGwgPSBNYXRoLm1heChhYWFhVHRsLCBlbnRyeS50dGwpO1xuXHRcdH1cblxuXHRcdGlmIChBLmxlbmd0aCA+IDApIHtcblx0XHRcdGlmIChBQUFBLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y2FjaGVUdGwgPSBNYXRoLm1pbihhVHRsLCBhYWFhVHRsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhY2hlVHRsID0gYVR0bDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FjaGVUdGwgPSBhYWFhVHRsO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRlbnRyaWVzOiBbXG5cdFx0XHRcdC4uLkEsXG5cdFx0XHRcdC4uLkFBQUFcblx0XHRcdF0sXG5cdFx0XHRjYWNoZVR0bFxuXHRcdH07XG5cdH1cblxuXHRhc3luYyBfbG9va3VwKGhvc3RuYW1lKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IFtBLCBBQUFBXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcblx0XHRcdFx0Ly8gUGFzc2luZyB7YWxsOiB0cnVlfSBkb2Vzbid0IHJldHVybiBhbGwgSVB2NCBhbmQgSVB2NiBlbnRyaWVzLlxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3N6bWFyY3phay9jYWNoZWFibGUtbG9va3VwL2lzc3Vlcy80MlxuXHRcdFx0XHRpZ25vcmVOb1Jlc3VsdEVycm9ycyh0aGlzLl9kbnNMb29rdXAoaG9zdG5hbWUsIGFsbDQpKSxcblx0XHRcdFx0aWdub3JlTm9SZXN1bHRFcnJvcnModGhpcy5fZG5zTG9va3VwKGhvc3RuYW1lLCBhbGw2KSlcblx0XHRcdF0pO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlbnRyaWVzOiBbXG5cdFx0XHRcdFx0Li4uQSxcblx0XHRcdFx0XHQuLi5BQUFBXG5cdFx0XHRcdF0sXG5cdFx0XHRcdGNhY2hlVHRsOiAwXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2gge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZW50cmllczogW10sXG5cdFx0XHRcdGNhY2hlVHRsOiAwXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIF9zZXQoaG9zdG5hbWUsIGRhdGEsIGNhY2hlVHRsKSB7XG5cdFx0aWYgKHRoaXMubWF4VHRsID4gMCAmJiBjYWNoZVR0bCA+IDApIHtcblx0XHRcdGNhY2hlVHRsID0gTWF0aC5taW4oY2FjaGVUdGwsIHRoaXMubWF4VHRsKSAqIDEwMDA7XG5cdFx0XHRkYXRhW2tFeHBpcmVzXSA9IERhdGUubm93KCkgKyBjYWNoZVR0bDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YXdhaXQgdGhpcy5fY2FjaGUuc2V0KGhvc3RuYW1lLCBkYXRhLCBjYWNoZVR0bCk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHR0aGlzLmxvb2t1cEFzeW5jID0gYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGNhY2hlRXJyb3IgPSBuZXcgRXJyb3IoJ0NhY2hlIEVycm9yLiBQbGVhc2UgcmVjcmVhdGUgdGhlIENhY2hlYWJsZUxvb2t1cCBpbnN0YW5jZS4nKTtcblx0XHRcdFx0XHRjYWNoZUVycm9yLmNhdXNlID0gZXJyb3I7XG5cblx0XHRcdFx0XHR0aHJvdyBjYWNoZUVycm9yO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNJdGVyYWJsZSh0aGlzLl9jYWNoZSkpIHtcblx0XHRcdFx0dGhpcy5fdGljayhjYWNoZVR0bCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgcXVlcnlBbmRDYWNoZShob3N0bmFtZSkge1xuXHRcdGlmICh0aGlzLl9ob3N0bmFtZXNUb0ZhbGxiYWNrLmhhcyhob3N0bmFtZSkpIHtcblx0XHRcdHJldHVybiB0aGlzLl9kbnNMb29rdXAoaG9zdG5hbWUsIGFsbCk7XG5cdFx0fVxuXG5cdFx0bGV0IHF1ZXJ5ID0gYXdhaXQgdGhpcy5fcmVzb2x2ZShob3N0bmFtZSk7XG5cblx0XHRpZiAocXVlcnkuZW50cmllcy5sZW5ndGggPT09IDAgJiYgdGhpcy5fZG5zTG9va3VwKSB7XG5cdFx0XHRxdWVyeSA9IGF3YWl0IHRoaXMuX2xvb2t1cChob3N0bmFtZSk7XG5cblx0XHRcdGlmIChxdWVyeS5lbnRyaWVzLmxlbmd0aCAhPT0gMCAmJiB0aGlzLmZhbGxiYWNrRHVyYXRpb24gPiAwKSB7XG5cdFx0XHRcdC8vIFVzZSBgZG5zLmxvb2t1cCguLi4pYCBmb3IgdGhhdCBwYXJ0aWN1bGFyIGhvc3RuYW1lXG5cdFx0XHRcdHRoaXMuX2hvc3RuYW1lc1RvRmFsbGJhY2suYWRkKGhvc3RuYW1lKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBjYWNoZVR0bCA9IHF1ZXJ5LmVudHJpZXMubGVuZ3RoID09PSAwID8gdGhpcy5lcnJvclR0bCA6IHF1ZXJ5LmNhY2hlVHRsO1xuXHRcdGF3YWl0IHRoaXMuX3NldChob3N0bmFtZSwgcXVlcnkuZW50cmllcywgY2FjaGVUdGwpO1xuXG5cdFx0cmV0dXJuIHF1ZXJ5LmVudHJpZXM7XG5cdH1cblxuXHRfdGljayhtcykge1xuXHRcdGNvbnN0IG5leHRSZW1vdmFsVGltZSA9IHRoaXMuX25leHRSZW1vdmFsVGltZTtcblxuXHRcdGlmICghbmV4dFJlbW92YWxUaW1lIHx8IG1zIDwgbmV4dFJlbW92YWxUaW1lKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZhbFRpbWVvdXQpO1xuXG5cdFx0XHR0aGlzLl9uZXh0UmVtb3ZhbFRpbWUgPSBtcztcblxuXHRcdFx0dGhpcy5fcmVtb3ZhbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGhpcy5fbmV4dFJlbW92YWxUaW1lID0gZmFsc2U7XG5cblx0XHRcdFx0bGV0IG5leHRFeHBpcnkgPSBJbmZpbml0eTtcblxuXHRcdFx0XHRjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG5cdFx0XHRcdGZvciAoY29uc3QgW2hvc3RuYW1lLCBlbnRyaWVzXSBvZiB0aGlzLl9jYWNoZSkge1xuXHRcdFx0XHRcdGNvbnN0IGV4cGlyZXMgPSBlbnRyaWVzW2tFeHBpcmVzXTtcblxuXHRcdFx0XHRcdGlmIChub3cgPj0gZXhwaXJlcykge1xuXHRcdFx0XHRcdFx0dGhpcy5fY2FjaGUuZGVsZXRlKGhvc3RuYW1lKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGV4cGlyZXMgPCBuZXh0RXhwaXJ5KSB7XG5cdFx0XHRcdFx0XHRuZXh0RXhwaXJ5ID0gZXhwaXJlcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobmV4dEV4cGlyeSAhPT0gSW5maW5pdHkpIHtcblx0XHRcdFx0XHR0aGlzLl90aWNrKG5leHRFeHBpcnkgLSBub3cpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBtcyk7XG5cblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBUaGVyZSBpcyBubyBgdGltZW91dC51bnJlZigpYCB3aGVuIHJ1bm5pbmcgaW5zaWRlIGFuIEVsZWN0cm9uIHJlbmRlcmVyICovXG5cdFx0XHRpZiAodGhpcy5fcmVtb3ZhbFRpbWVvdXQudW5yZWYpIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZhbFRpbWVvdXQudW5yZWYoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpbnN0YWxsKGFnZW50KSB7XG5cdFx0dmVyaWZ5QWdlbnQoYWdlbnQpO1xuXG5cdFx0aWYgKGtDYWNoZWFibGVMb29rdXBDcmVhdGVDb25uZWN0aW9uIGluIGFnZW50KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NhY2hlYWJsZUxvb2t1cCBoYXMgYmVlbiBhbHJlYWR5IGluc3RhbGxlZCcpO1xuXHRcdH1cblxuXHRcdGFnZW50W2tDYWNoZWFibGVMb29rdXBDcmVhdGVDb25uZWN0aW9uXSA9IGFnZW50LmNyZWF0ZUNvbm5lY3Rpb247XG5cdFx0YWdlbnRba0NhY2hlYWJsZUxvb2t1cEluc3RhbmNlXSA9IHRoaXM7XG5cblx0XHRhZ2VudC5jcmVhdGVDb25uZWN0aW9uID0gKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG5cdFx0XHRpZiAoISgnbG9va3VwJyBpbiBvcHRpb25zKSkge1xuXHRcdFx0XHRvcHRpb25zLmxvb2t1cCA9IHRoaXMubG9va3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYWdlbnRba0NhY2hlYWJsZUxvb2t1cENyZWF0ZUNvbm5lY3Rpb25dKG9wdGlvbnMsIGNhbGxiYWNrKTtcblx0XHR9O1xuXHR9XG5cblx0dW5pbnN0YWxsKGFnZW50KSB7XG5cdFx0dmVyaWZ5QWdlbnQoYWdlbnQpO1xuXG5cdFx0aWYgKGFnZW50W2tDYWNoZWFibGVMb29rdXBDcmVhdGVDb25uZWN0aW9uXSkge1xuXHRcdFx0aWYgKGFnZW50W2tDYWNoZWFibGVMb29rdXBJbnN0YW5jZV0gIT09IHRoaXMpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgYWdlbnQgaXMgbm90IG93bmVkIGJ5IHRoaXMgQ2FjaGVhYmxlTG9va3VwIGluc3RhbmNlJyk7XG5cdFx0XHR9XG5cblx0XHRcdGFnZW50LmNyZWF0ZUNvbm5lY3Rpb24gPSBhZ2VudFtrQ2FjaGVhYmxlTG9va3VwQ3JlYXRlQ29ubmVjdGlvbl07XG5cblx0XHRcdGRlbGV0ZSBhZ2VudFtrQ2FjaGVhYmxlTG9va3VwQ3JlYXRlQ29ubmVjdGlvbl07XG5cdFx0XHRkZWxldGUgYWdlbnRba0NhY2hlYWJsZUxvb2t1cEluc3RhbmNlXTtcblx0XHR9XG5cdH1cblxuXHR1cGRhdGVJbnRlcmZhY2VJbmZvKCkge1xuXHRcdGNvbnN0IHtfaWZhY2V9ID0gdGhpcztcblxuXHRcdHRoaXMuX2lmYWNlID0gZ2V0SWZhY2VJbmZvKCk7XG5cblx0XHRpZiAoKF9pZmFjZS5oYXM0ICYmICF0aGlzLl9pZmFjZS5oYXM0KSB8fCAoX2lmYWNlLmhhczYgJiYgIXRoaXMuX2lmYWNlLmhhczYpKSB7XG5cdFx0XHR0aGlzLl9jYWNoZS5jbGVhcigpO1xuXHRcdH1cblx0fVxuXG5cdGNsZWFyKGhvc3RuYW1lKSB7XG5cdFx0aWYgKGhvc3RuYW1lKSB7XG5cdFx0XHR0aGlzLl9jYWNoZS5kZWxldGUoaG9zdG5hbWUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NhY2hlLmNsZWFyKCk7XG5cdH1cbn1cbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnbm9kZTpldmVudHMnO1xuaW1wb3J0IHVybExpYiBmcm9tICdub2RlOnVybCc7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ25vZGU6Y3J5cHRvJztcbmltcG9ydCBzdHJlYW0sIHsgUGFzc1Rocm91Z2ggYXMgUGFzc1Rocm91Z2hTdHJlYW0gfSBmcm9tICdub2RlOnN0cmVhbSc7XG5pbXBvcnQgbm9ybWFsaXplVXJsIGZyb20gJ25vcm1hbGl6ZS11cmwnO1xuaW1wb3J0IGdldFN0cmVhbSBmcm9tICdnZXQtc3RyZWFtJztcbmltcG9ydCBDYWNoZVBvbGljeSBmcm9tICdodHRwLWNhY2hlLXNlbWFudGljcyc7XG5pbXBvcnQgUmVzcG9uc2UgZnJvbSAncmVzcG9uc2VsaWtlJztcbmltcG9ydCBLZXl2IGZyb20gJ2tleXYnO1xuaW1wb3J0IG1pbWljUmVzcG9uc2UgZnJvbSAnbWltaWMtcmVzcG9uc2UnO1xuaW1wb3J0IHsgQ2FjaGVFcnJvciwgUmVxdWVzdEVycm9yIH0gZnJvbSAnLi90eXBlcy5qcyc7XG5jbGFzcyBDYWNoZWFibGVSZXF1ZXN0IHtcbiAgICBjb25zdHJ1Y3RvcihjYWNoZVJlcXVlc3QsIGNhY2hlQWRhcHRlcikge1xuICAgICAgICB0aGlzLmhvb2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSAoKSA9PiAob3B0aW9ucywgY2IpID0+IHtcbiAgICAgICAgICAgIGxldCB1cmw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gbm9ybWFsaXplVXJsT2JqZWN0KHVybExpYi5wYXJzZShvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIHVybExpYi5VUkwpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBub3JtYWxpemVVcmxPYmplY3QodXJsTGliLnBhcnNlKG9wdGlvbnMudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwYXRobmFtZSwgLi4uc2VhcmNoUGFydHNdID0gKG9wdGlvbnMucGF0aCA/PyAnJykuc3BsaXQoJz8nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2ggPSBzZWFyY2hQYXJ0cy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgID8gYD8ke3NlYXJjaFBhcnRzLmpvaW4oJz8nKX1gXG4gICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAgICAgdXJsID0gbm9ybWFsaXplVXJsT2JqZWN0KHsgLi4ub3B0aW9ucywgcGF0aG5hbWUsIHNlYXJjaCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdHJpY3RUdGw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF1dG9tYXRpY0ZhaWxvdmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIC4uLnVybE9iamVjdFRvUmVxdWVzdE9wdGlvbnModXJsKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcyhvcHRpb25zLmhlYWRlcnMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LnRvTG93ZXJDYXNlKCksIHZhbHVlXSkpO1xuICAgICAgICAgICAgY29uc3QgZWUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkVXJsU3RyaW5nID0gbm9ybWFsaXplVXJsKHVybExpYi5mb3JtYXQodXJsKSwge1xuICAgICAgICAgICAgICAgIHN0cmlwV1dXOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFpbGluZ1NsYXNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdHJpcEF1dGhlbnRpY2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGtleSA9IGAke29wdGlvbnMubWV0aG9kfToke25vcm1hbGl6ZWRVcmxTdHJpbmd9YDtcbiAgICAgICAgICAgIC8vIFBPU1QsIFBBVENILCBhbmQgUFVUIHJlcXVlc3RzIG1heSBiZSBjYWNoZWQsIGRlcGVuZGluZyBvbiB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgIC8vIGNhY2hlLWNvbnRyb2wgaGVhZGVycy4gQXMgYSByZXN1bHQsIHRoZSBib2R5IG9mIHRoZSByZXF1ZXN0IHNob3VsZCBiZVxuICAgICAgICAgICAgLy8gYWRkZWQgdG8gdGhlIGNhY2hlIGtleSBpbiBvcmRlciB0byBhdm9pZCBjb2xsaXNpb25zLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYm9keSAmJiBvcHRpb25zLm1ldGhvZCAhPT0gdW5kZWZpbmVkICYmIFsnUE9TVCcsICdQQVRDSCcsICdQVVQnXS5pbmNsdWRlcyhvcHRpb25zLm1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ib2R5IGluc3RhbmNlb2Ygc3RyZWFtLlJlYWRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0cmVhbWVkIGJvZGllcyBzaG91bGQgY29tcGxldGVseSBza2lwIHRoZSBjYWNoZSBiZWNhdXNlIHRoZXkgbWF5XG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIG1heSBub3QgYmUgaGFzaGFibGUgYW5kIGluIGVpdGhlciBjYXNlIHRoZSBzdHJlYW0gd291bGQgbmVlZCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZSBiZWZvcmUgdGhlIGNhY2hlIGtleSBjb3VsZCBiZSBnZW5lcmF0ZWQuXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FjaGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSArPSBgOiR7Y3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShvcHRpb25zLmJvZHkpLmRpZ2VzdCgnaGV4Jyl9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG1hZGVSZXF1ZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBtYWtlUmVxdWVzdCA9IChvcHRpb25zXykgPT4ge1xuICAgICAgICAgICAgICAgIG1hZGVSZXF1ZXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdEVycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdEVycm9yQ2FsbGJhY2sgPSAoKSA9PiB7IH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdEVycm9yUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RXJyb3JDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdEVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlZFBvbGljeSA9IENhY2hlUG9saWN5LmZyb21PYmplY3QocmV2YWxpZGF0ZS5jYWNoZVBvbGljeSkucmV2YWxpZGF0ZWRQb2xpY3kob3B0aW9uc18sIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmV2YWxpZGF0ZWRQb2xpY3kubW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5yZXN1bWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcHBpbmcgJ2Vycm9yJyBoYW5kbGVyIGNhdXNlICdlcnJvcicgZXZlbnQgc2hvdWxkJ3QgYmUgZW1pdHRlZCBmb3IgMzA0IHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25jZSgnZW5kJywgcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGNvbnZlcnRIZWFkZXJzKHJldmFsaWRhdGVkUG9saWN5LnBvbGljeS5yZXNwb25zZUhlYWRlcnMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoeyBzdGF0dXNDb2RlOiByZXZhbGlkYXRlLnN0YXR1c0NvZGUsIGhlYWRlcnMsIGJvZHk6IHJldmFsaWRhdGUuYm9keSwgdXJsOiByZXZhbGlkYXRlLnVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5jYWNoZVBvbGljeSA9IHJldmFsaWRhdGVkUG9saWN5LnBvbGljeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5mcm9tQ2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2UuZnJvbUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5jYWNoZVBvbGljeSA9IG5ldyBDYWNoZVBvbGljeShvcHRpb25zXywgcmVzcG9uc2UsIG9wdGlvbnNfKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmZyb21DYWNoZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBjbG9uZWRSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNfLmNhY2hlICYmIHJlc3BvbnNlLmNhY2hlUG9saWN5LnN0b3JhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZFJlc3BvbnNlID0gY2xvbmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlQcm9taXNlID0gZ2V0U3RyZWFtLmJ1ZmZlcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RXJyb3JQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UocmVzb2x2ZSA9PiByZXNwb25zZS5vbmNlKCdlbmQnLCByZXNvbHZlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHJlc3BvbnNlLm9uY2UoJ2Nsb3NlJywgcmVzb2x2ZSkpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb21pc2UtZXhlY3V0b3ItcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgYm9keVByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2UuZnJvbUNhY2hlID8gcmV2YWxpZGF0ZS5zdGF0dXNDb2RlIDogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVBvbGljeTogcmVzcG9uc2UuY2FjaGVQb2xpY3kudG9PYmplY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR0bCA9IG9wdGlvbnNfLnN0cmljdFR0bCA/IHJlc3BvbnNlLmNhY2hlUG9saWN5LnRpbWVUb0xpdmUoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNfLm1heFR0bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHRsID0gdHRsID8gTWF0aC5taW4odHRsLCBvcHRpb25zXy5tYXhUdGwpIDogb3B0aW9uc18ubWF4VHRsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhvb2tzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1hd2FpdC1pbi1sb29wICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleV8gb2YgdGhpcy5ob29rcy5rZXlzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF3YWl0IHRoaXMucnVuSG9vayhrZXlfLCB2YWx1ZSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1hd2FpdC1pbi1sb29wICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSwgdHRsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVlLmVtaXQoJ2Vycm9yJywgbmV3IENhY2hlRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnNfLmNhY2hlICYmIHJldmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVlLmVtaXQoJ2Vycm9yJywgbmV3IENhY2hlRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVlLmVtaXQoJ3Jlc3BvbnNlJywgY2xvbmVkUmVzcG9uc2UgPz8gcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYihjbG9uZWRSZXNwb25zZSA/PyByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RfID0gdGhpcy5jYWNoZVJlcXVlc3Qob3B0aW9uc18sIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Xy5vbmNlKCdlcnJvcicsIHJlcXVlc3RFcnJvckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdF8ub25jZSgnYWJvcnQnLCByZXF1ZXN0RXJyb3JDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RfLm9uY2UoJ2Rlc3Ryb3knLCByZXF1ZXN0RXJyb3JDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGVlLmVtaXQoJ3JlcXVlc3QnLCByZXF1ZXN0Xyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlZS5lbWl0KCdlcnJvcicsIG5ldyBSZXF1ZXN0RXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBnZXQgPSBhc3luYyAob3B0aW9uc18pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlRW50cnkgPSBvcHRpb25zXy5jYWNoZSA/IGF3YWl0IHRoaXMuY2FjaGUuZ2V0KGtleSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FjaGVFbnRyeSA9PT0gJ3VuZGVmaW5lZCcgJiYgIW9wdGlvbnNfLmZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcXVlc3Qob3B0aW9uc18pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvbGljeSA9IENhY2hlUG9saWN5LmZyb21PYmplY3QoY2FjaGVFbnRyeS5jYWNoZVBvbGljeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2xpY3kuc2F0aXNmaWVzV2l0aG91dFJldmFsaWRhdGlvbihvcHRpb25zXykgJiYgIW9wdGlvbnNfLmZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGNvbnZlcnRIZWFkZXJzKHBvbGljeS5yZXNwb25zZUhlYWRlcnMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZSh7IHN0YXR1c0NvZGU6IGNhY2hlRW50cnkuc3RhdHVzQ29kZSwgaGVhZGVycywgYm9keTogY2FjaGVFbnRyeS5ib2R5LCB1cmw6IGNhY2hlRW50cnkudXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuY2FjaGVQb2xpY3kgPSBwb2xpY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5mcm9tQ2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWUuZW1pdCgncmVzcG9uc2UnLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBvbGljeS5zYXRpc2ZpZXNXaXRob3V0UmV2YWxpZGF0aW9uKG9wdGlvbnNfKSAmJiBEYXRlLm5vdygpID49IHBvbGljeS50aW1lVG9MaXZlKCkgJiYgb3B0aW9uc18uZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc18uaGVhZGVycyA9IHBvbGljeS5yZXZhbGlkYXRpb25IZWFkZXJzKG9wdGlvbnNfKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VSZXF1ZXN0KG9wdGlvbnNfKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGUgPSBjYWNoZUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc18uaGVhZGVycyA9IHBvbGljeS5yZXZhbGlkYXRpb25IZWFkZXJzKG9wdGlvbnNfKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VSZXF1ZXN0KG9wdGlvbnNfKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKGVycm9yKSA9PiBlZS5lbWl0KCdlcnJvcicsIG5ldyBDYWNoZUVycm9yKGVycm9yKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGUgaW5zdGFuY2VvZiBLZXl2KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlayA9IHRoaXMuY2FjaGU7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlay5vbmNlKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIGVlLm9uKCdlcnJvcicsICgpID0+IGNhY2hlay5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgZWUub24oJ3Jlc3BvbnNlJywgKCkgPT4gY2FjaGVrLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBnZXQob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hdXRvbWF0aWNGYWlsb3ZlciAmJiAhbWFkZVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VSZXF1ZXN0KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVlLmVtaXQoJ2Vycm9yJywgbmV3IENhY2hlRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIGVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZEhvb2sgPSAobmFtZSwgZm4pID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ob29rcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvb2tzLnNldChuYW1lLCBmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVtb3ZlSG9vayA9IChuYW1lKSA9PiB0aGlzLmhvb2tzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgdGhpcy5nZXRIb29rID0gKG5hbWUpID0+IHRoaXMuaG9va3MuZ2V0KG5hbWUpO1xuICAgICAgICB0aGlzLnJ1bkhvb2sgPSBhc3luYyAobmFtZSwgLi4uYXJncykgPT4gdGhpcy5ob29rcy5nZXQobmFtZSk/LiguLi5hcmdzKTtcbiAgICAgICAgaWYgKGNhY2hlQWRhcHRlciBpbnN0YW5jZW9mIEtleXYpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZUFkYXB0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNhY2hlQWRhcHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgS2V5dih7XG4gICAgICAgICAgICAgICAgdXJpOiBjYWNoZUFkYXB0ZXIsXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiAnY2FjaGVhYmxlLXJlcXVlc3QnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0gbmV3IEtleXYoe1xuICAgICAgICAgICAgICAgIHN0b3JlOiBjYWNoZUFkYXB0ZXIsXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiAnY2FjaGVhYmxlLXJlcXVlc3QnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2FjaGVSZXF1ZXN0ID0gY2FjaGVSZXF1ZXN0O1xuICAgIH1cbn1cbmNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcztcbmNvbnN0IGNsb25lUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBQYXNzVGhyb3VnaFN0cmVhbSh7IGF1dG9EZXN0cm95OiBmYWxzZSB9KTtcbiAgICBtaW1pY1Jlc3BvbnNlKHJlc3BvbnNlLCBjbG9uZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnBpcGUoY2xvbmUpO1xufTtcbmNvbnN0IHVybE9iamVjdFRvUmVxdWVzdE9wdGlvbnMgPSAodXJsKSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgLi4udXJsIH07XG4gICAgb3B0aW9ucy5wYXRoID0gYCR7dXJsLnBhdGhuYW1lIHx8ICcvJ30ke3VybC5zZWFyY2ggfHwgJyd9YDtcbiAgICBkZWxldGUgb3B0aW9ucy5wYXRobmFtZTtcbiAgICBkZWxldGUgb3B0aW9ucy5zZWFyY2g7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuY29uc3Qgbm9ybWFsaXplVXJsT2JqZWN0ID0gKHVybCkgPT4gXG4vLyBJZiB1cmwgd2FzIHBhcnNlZCBieSB1cmwucGFyc2Ugb3IgbmV3IFVSTDpcbi8vIC0gaG9zdG5hbWUgd2lsbCBiZSBzZXRcbi8vIC0gaG9zdCB3aWxsIGJlIGhvc3RuYW1lWzpwb3J0XVxuLy8gLSBwb3J0IHdpbGwgYmUgc2V0IGlmIGl0IHdhcyBleHBsaWNpdCBpbiB0aGUgcGFyc2VkIHN0cmluZ1xuLy8gT3RoZXJ3aXNlLCB1cmwgd2FzIGZyb20gcmVxdWVzdCBvcHRpb25zOlxuLy8gLSBob3N0bmFtZSBvciBob3N0IG1heSBiZSBzZXRcbi8vIC0gaG9zdCBzaGFsbCBub3QgaGF2ZSBwb3J0IGVuY29kZWRcbih7XG4gICAgcHJvdG9jb2w6IHVybC5wcm90b2NvbCxcbiAgICBhdXRoOiB1cmwuYXV0aCxcbiAgICBob3N0bmFtZTogdXJsLmhvc3RuYW1lIHx8IHVybC5ob3N0IHx8ICdsb2NhbGhvc3QnLFxuICAgIHBvcnQ6IHVybC5wb3J0LFxuICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgc2VhcmNoOiB1cmwuc2VhcmNoLFxufSk7XG5jb25zdCBjb252ZXJ0SGVhZGVycyA9IChoZWFkZXJzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgIHJlc3VsdFtuYW1lLnRvTG93ZXJDYXNlKCldID0gaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnQgZGVmYXVsdCBDYWNoZWFibGVSZXF1ZXN0O1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcy5qcyc7XG5leHBvcnQgY29uc3Qgb25SZXNwb25zZSA9ICdvblJlc3BvbnNlJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGNhY2hlYWJsZS1yZXF1ZXN0IDYuMFxuLy8gUHJvamVjdDogaHR0cHM6Ly9naXRodWIuY29tL2x1a2VjaGlsZHMvY2FjaGVhYmxlLXJlcXVlc3QjcmVhZG1lXG4vLyBEZWZpbml0aW9ucyBieTogQmVuZGluZ0JlbmRlciA8aHR0cHM6Ly9naXRodWIuY29tL0JlbmRpbmdCZW5kZXI+XG4vLyAgICAgICAgICAgICAgICAgUGF1bCBNZWxuaWtvdyA8aHR0cHM6Ly9naXRodWIuY29tL3BhdWxtZWxuaWtvdz5cbi8vIERlZmluaXRpb25zOiBodHRwczovL2dpdGh1Yi5jb20vRGVmaW5pdGVseVR5cGVkL0RlZmluaXRlbHlUeXBlZFxuLy8gVHlwZVNjcmlwdCBWZXJzaW9uOiAyLjNcbmV4cG9ydCBjbGFzcyBSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgZXJyb3IpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWNoZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGVycm9yKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0Zvcm1EYXRhRW5jb2Rlcl9pbnN0YW5jZXMsIF9Gb3JtRGF0YUVuY29kZXJfQ1JMRiwgX0Zvcm1EYXRhRW5jb2Rlcl9DUkxGX0JZVEVTLCBfRm9ybURhdGFFbmNvZGVyX0NSTEZfQllURVNfTEVOR1RILCBfRm9ybURhdGFFbmNvZGVyX0RBU0hFUywgX0Zvcm1EYXRhRW5jb2Rlcl9lbmNvZGVyLCBfRm9ybURhdGFFbmNvZGVyX2Zvb3RlciwgX0Zvcm1EYXRhRW5jb2Rlcl9mb3JtLCBfRm9ybURhdGFFbmNvZGVyX29wdGlvbnMsIF9Gb3JtRGF0YUVuY29kZXJfZ2V0RmllbGRIZWFkZXIsIF9Gb3JtRGF0YUVuY29kZXJfZ2V0Q29udGVudExlbmd0aDtcbmltcG9ydCB7IGdldFN0cmVhbUl0ZXJhdG9yIH0gZnJvbSBcIi4vdXRpbC9nZXRTdHJlYW1JdGVyYXRvci5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlQm91bmRhcnkgfSBmcm9tIFwiLi91dGlsL2NyZWF0ZUJvdW5kYXJ5LmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVWYWx1ZSB9IGZyb20gXCIuL3V0aWwvbm9ybWFsaXplVmFsdWUuanNcIjtcbmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tIFwiLi91dGlsL2lzUGxhaW5PYmplY3QuanNcIjtcbmltcG9ydCB7IHByb3h5SGVhZGVycyB9IGZyb20gXCIuL3V0aWwvcHJveHlIZWFkZXJzLmpzXCI7XG5pbXBvcnQgeyBpc0Zvcm1EYXRhIH0gZnJvbSBcIi4vdXRpbC9pc0Zvcm1EYXRhLmpzXCI7XG5pbXBvcnQgeyBlc2NhcGVOYW1lIH0gZnJvbSBcIi4vdXRpbC9lc2NhcGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0ZpbGUgfSBmcm9tIFwiLi91dGlsL2lzRmlsZS5qc1wiO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgZW5hYmxlQWRkaXRpb25hbEhlYWRlcnM6IGZhbHNlXG59O1xuY29uc3QgcmVhZG9ubHlQcm9wID0geyB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogZmFsc2UgfTtcbmV4cG9ydCBjbGFzcyBGb3JtRGF0YUVuY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGZvcm0sIGJvdW5kYXJ5T3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgIF9Gb3JtRGF0YUVuY29kZXJfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgX0Zvcm1EYXRhRW5jb2Rlcl9DUkxGLnNldCh0aGlzLCBcIlxcclxcblwiKTtcbiAgICAgICAgX0Zvcm1EYXRhRW5jb2Rlcl9DUkxGX0JZVEVTLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfRm9ybURhdGFFbmNvZGVyX0NSTEZfQllURVNfTEVOR1RILnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfRm9ybURhdGFFbmNvZGVyX0RBU0hFUy5zZXQodGhpcywgXCItXCIucmVwZWF0KDIpKTtcbiAgICAgICAgX0Zvcm1EYXRhRW5jb2Rlcl9lbmNvZGVyLnNldCh0aGlzLCBuZXcgVGV4dEVuY29kZXIoKSk7XG4gICAgICAgIF9Gb3JtRGF0YUVuY29kZXJfZm9vdGVyLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfRm9ybURhdGFFbmNvZGVyX2Zvcm0uc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Gb3JtRGF0YUVuY29kZXJfb3B0aW9ucy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgaWYgKCFpc0Zvcm1EYXRhKGZvcm0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBGb3JtRGF0YSBpbnN0YW5jZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJvdW5kYXJ5O1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChib3VuZGFyeU9yT3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBib3VuZGFyeU9yT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvdW5kYXJ5ID0gYm91bmRhcnlPck9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFib3VuZGFyeSkge1xuICAgICAgICAgICAgYm91bmRhcnkgPSBjcmVhdGVCb3VuZGFyeSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYm91bmRhcnkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBib3VuZGFyeSBhcmd1bWVudCB0byBiZSBhIHN0cmluZy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgIWlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX2Zvcm0sIEFycmF5LmZyb20oZm9ybS5lbnRyaWVzKCkpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9vcHRpb25zLCB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH0sIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX0NSTEZfQllURVMsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9lbmNvZGVyLCBcImZcIikuZW5jb2RlKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9DUkxGLCBcImZcIikpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9DUkxGX0JZVEVTX0xFTkdUSCwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX0NSTEZfQllURVMsIFwiZlwiKS5ieXRlTGVuZ3RoLCBcImZcIik7XG4gICAgICAgIHRoaXMuYm91bmRhcnkgPSBgZm9ybS1kYXRhLWJvdW5kYXJ5LSR7Ym91bmRhcnl9YDtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke3RoaXMuYm91bmRhcnl9YDtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX2Zvb3RlciwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX2VuY29kZXIsIFwiZlwiKS5lbmNvZGUoYCR7X19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX0RBU0hFUywgXCJmXCIpfSR7dGhpcy5ib3VuZGFyeX0ke19fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9EQVNIRVMsIFwiZlwiKX0ke19fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9DUkxGLCBcImZcIikucmVwZWF0KDIpfWApLCBcImZcIik7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiB0aGlzLmNvbnRlbnRUeXBlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gb3JtRGF0YUVuY29kZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Zvcm1EYXRhRW5jb2Rlcl9nZXRDb250ZW50TGVuZ3RoKS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoY29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50TGVuZ3RoID0gY29udGVudExlbmd0aDtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LUxlbmd0aFwiXSA9IGNvbnRlbnRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzID0gcHJveHlIZWFkZXJzKE9iamVjdC5mcmVlemUoaGVhZGVycykpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBib3VuZGFyeTogcmVhZG9ubHlQcm9wLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IHJlYWRvbmx5UHJvcCxcbiAgICAgICAgICAgIGNvbnRlbnRMZW5ndGg6IHJlYWRvbmx5UHJvcCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlYWRvbmx5UHJvcFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29udGVudExlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudExlbmd0aCA9PSBudWxsID8gdW5kZWZpbmVkIDogTnVtYmVyKHRoaXMuY29udGVudExlbmd0aCk7XG4gICAgfVxuICAgICp2YWx1ZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHJhd10gb2YgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX2Zvcm0sIFwiZlwiKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc0ZpbGUocmF3KSA/IHJhdyA6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9lbmNvZGVyLCBcImZcIikuZW5jb2RlKG5vcm1hbGl6ZVZhbHVlKHJhdykpO1xuICAgICAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX2luc3RhbmNlcywgXCJtXCIsIF9Gb3JtRGF0YUVuY29kZXJfZ2V0RmllbGRIZWFkZXIpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgICAgICB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gb3JtRGF0YUVuY29kZXJfQ1JMRl9CWVRFUywgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9mb290ZXIsIFwiZlwiKTtcbiAgICB9XG4gICAgYXN5bmMgKmVuY29kZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHRoaXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChpc0ZpbGUocGFydCkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogZ2V0U3RyZWFtSXRlcmF0b3IocGFydC5zdHJlYW0oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBwYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFsoX0Zvcm1EYXRhRW5jb2Rlcl9DUkxGID0gbmV3IFdlYWtNYXAoKSwgX0Zvcm1EYXRhRW5jb2Rlcl9DUkxGX0JZVEVTID0gbmV3IFdlYWtNYXAoKSwgX0Zvcm1EYXRhRW5jb2Rlcl9DUkxGX0JZVEVTX0xFTkdUSCA9IG5ldyBXZWFrTWFwKCksIF9Gb3JtRGF0YUVuY29kZXJfREFTSEVTID0gbmV3IFdlYWtNYXAoKSwgX0Zvcm1EYXRhRW5jb2Rlcl9lbmNvZGVyID0gbmV3IFdlYWtNYXAoKSwgX0Zvcm1EYXRhRW5jb2Rlcl9mb290ZXIgPSBuZXcgV2Vha01hcCgpLCBfRm9ybURhdGFFbmNvZGVyX2Zvcm0gPSBuZXcgV2Vha01hcCgpLCBfRm9ybURhdGFFbmNvZGVyX29wdGlvbnMgPSBuZXcgV2Vha01hcCgpLCBfRm9ybURhdGFFbmNvZGVyX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9Gb3JtRGF0YUVuY29kZXJfZ2V0RmllbGRIZWFkZXIgPSBmdW5jdGlvbiBfRm9ybURhdGFFbmNvZGVyX2dldEZpZWxkSGVhZGVyKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGxldCBoZWFkZXIgPSBcIlwiO1xuICAgICAgICBoZWFkZXIgKz0gYCR7X19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX0RBU0hFUywgXCJmXCIpfSR7dGhpcy5ib3VuZGFyeX0ke19fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9DUkxGLCBcImZcIil9YDtcbiAgICAgICAgaGVhZGVyICs9IGBDb250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCIke2VzY2FwZU5hbWUobmFtZSl9XCJgO1xuICAgICAgICBpZiAoaXNGaWxlKHZhbHVlKSkge1xuICAgICAgICAgICAgaGVhZGVyICs9IGA7IGZpbGVuYW1lPVwiJHtlc2NhcGVOYW1lKHZhbHVlLm5hbWUpfVwiJHtfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gb3JtRGF0YUVuY29kZXJfQ1JMRiwgXCJmXCIpfWA7XG4gICAgICAgICAgICBoZWFkZXIgKz0gYENvbnRlbnQtVHlwZTogJHt2YWx1ZS50eXBlIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplID0gaXNGaWxlKHZhbHVlKSA/IHZhbHVlLnNpemUgOiB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX29wdGlvbnMsIFwiZlwiKS5lbmFibGVBZGRpdGlvbmFsSGVhZGVycyA9PT0gdHJ1ZVxuICAgICAgICAgICAgJiYgc2l6ZSAhPSBudWxsXG4gICAgICAgICAgICAmJiAhaXNOYU4oc2l6ZSkpIHtcbiAgICAgICAgICAgIGhlYWRlciArPSBgJHtfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gb3JtRGF0YUVuY29kZXJfQ1JMRiwgXCJmXCIpfUNvbnRlbnQtTGVuZ3RoOiAke2lzRmlsZSh2YWx1ZSkgPyB2YWx1ZS5zaXplIDogdmFsdWUuYnl0ZUxlbmd0aH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gb3JtRGF0YUVuY29kZXJfZW5jb2RlciwgXCJmXCIpLmVuY29kZShgJHtoZWFkZXJ9JHtfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gb3JtRGF0YUVuY29kZXJfQ1JMRiwgXCJmXCIpLnJlcGVhdCgyKX1gKTtcbiAgICB9LCBfRm9ybURhdGFFbmNvZGVyX2dldENvbnRlbnRMZW5ndGggPSBmdW5jdGlvbiBfRm9ybURhdGFFbmNvZGVyX2dldENvbnRlbnRMZW5ndGgoKSB7XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCByYXddIG9mIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9mb3JtLCBcImZcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaXNGaWxlKHJhdykgPyByYXcgOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gb3JtRGF0YUVuY29kZXJfZW5jb2RlciwgXCJmXCIpLmVuY29kZShub3JtYWxpemVWYWx1ZShyYXcpKTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBpc0ZpbGUodmFsdWUpID8gdmFsdWUuc2l6ZSA6IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PSBudWxsIHx8IGlzTmFOKHNpemUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbmd0aCArPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gb3JtRGF0YUVuY29kZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Zvcm1EYXRhRW5jb2Rlcl9nZXRGaWVsZEhlYWRlcikuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSkuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGxlbmd0aCArPSBzaXplO1xuICAgICAgICAgICAgbGVuZ3RoICs9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9DUkxGX0JZVEVTX0xFTkdUSCwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcobGVuZ3RoICsgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX2Zvb3RlciwgXCJmXCIpLmJ5dGVMZW5ndGgpO1xuICAgIH0sIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKCk7XG4gICAgfVxufVxuIiwiY29uc3QgYWxwaGFiZXQgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJvdW5kYXJ5KCkge1xuICAgIGxldCBzaXplID0gMTY7XG4gICAgbGV0IHJlcyA9IFwiXCI7XG4gICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICByZXMgKz0gYWxwaGFiZXRbKE1hdGgucmFuZG9tKCkgKiBhbHBoYWJldC5sZW5ndGgpIDw8IDBdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuIiwiZXhwb3J0IGNvbnN0IGVzY2FwZU5hbWUgPSAobmFtZSkgPT4gU3RyaW5nKG5hbWUpXG4gICAgLnJlcGxhY2UoL1xcci9nLCBcIiUwRFwiKVxuICAgIC5yZXBsYWNlKC9cXG4vZywgXCIlMEFcIilcbiAgICAucmVwbGFjZSgvXCIvZywgXCIlMjJcIik7XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSBcIi4vaXNGdW5jdGlvbi5qc1wiO1xuY29uc3QgaXNBc3luY0l0ZXJhYmxlID0gKHZhbHVlKSA9PiAoaXNGdW5jdGlvbih2YWx1ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pKTtcbmFzeW5jIGZ1bmN0aW9uKiByZWFkU3RyZWFtKHJlYWRhYmxlKSB7XG4gICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGUuZ2V0UmVhZGVyKCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBnZXRTdHJlYW1JdGVyYXRvciA9IChzb3VyY2UpID0+IHtcbiAgICBpZiAoaXNBc3luY0l0ZXJhYmxlKHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oc291cmNlLmdldFJlYWRlcikpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRTdHJlYW0oc291cmNlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgc291cmNlOiBFeHBlY3RlZCBlaXRoZXIgUmVhZGFibGVTdHJlYW0gb3IgYXN5bmMgaXRlcmFibGUuXCIpO1xufTtcbiIsImltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tIFwiLi9pc0Z1bmN0aW9uLmpzXCI7XG5leHBvcnQgY29uc3QgaXNGaWxlID0gKHZhbHVlKSA9PiBCb29sZWFuKHZhbHVlXG4gICAgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiXG4gICAgJiYgaXNGdW5jdGlvbih2YWx1ZS5jb25zdHJ1Y3RvcilcbiAgICAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIkZpbGVcIlxuICAgICYmIGlzRnVuY3Rpb24odmFsdWUuc3RyZWFtKVxuICAgICYmIHZhbHVlLm5hbWUgIT0gbnVsbCk7XG5leHBvcnQgY29uc3QgaXNGaWxlTGlrZSA9IGlzRmlsZTtcbiIsImltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tIFwiLi9pc0Z1bmN0aW9uLmpzXCI7XG5leHBvcnQgY29uc3QgaXNGb3JtRGF0YSA9ICh2YWx1ZSkgPT4gQm9vbGVhbih2YWx1ZVxuICAgICYmIGlzRnVuY3Rpb24odmFsdWUuY29uc3RydWN0b3IpXG4gICAgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJGb3JtRGF0YVwiXG4gICAgJiYgaXNGdW5jdGlvbih2YWx1ZS5hcHBlbmQpXG4gICAgJiYgaXNGdW5jdGlvbih2YWx1ZS5nZXRBbGwpXG4gICAgJiYgaXNGdW5jdGlvbih2YWx1ZS5lbnRyaWVzKVxuICAgICYmIGlzRnVuY3Rpb24odmFsdWVbU3ltYm9sLml0ZXJhdG9yXSkpO1xuIiwiZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIik7XG4iLCJjb25zdCBnZXRUeXBlID0gKHZhbHVlKSA9PiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKSk7XG5leHBvcnQgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBwID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICBpZiAocHAgPT09IG51bGwgfHwgcHAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgQ3RvciA9IHBwLmNvbnN0cnVjdG9yICYmIHBwLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIEN0b3IgPT09IE9iamVjdC50b1N0cmluZygpO1xufVxuIiwiZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVZhbHVlID0gKHZhbHVlKSA9PiBTdHJpbmcodmFsdWUpXG4gICAgLnJlcGxhY2UoL1xccnxcXG4vZywgKG1hdGNoLCBpLCBzdHIpID0+IHtcbiAgICBpZiAoKG1hdGNoID09PSBcIlxcclwiICYmIHN0cltpICsgMV0gIT09IFwiXFxuXCIpXG4gICAgICAgIHx8IChtYXRjaCA9PT0gXCJcXG5cIiAmJiBzdHJbaSAtIDFdICE9PSBcIlxcclwiKSkge1xuICAgICAgICByZXR1cm4gXCJcXHJcXG5cIjtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoO1xufSk7XG4iLCJmdW5jdGlvbiBnZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGlmIChwcm9wLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGNvbnN0IHByb3h5SGVhZGVycyA9IChvYmplY3QpID0+IG5ldyBQcm94eShvYmplY3QsIHtcbiAgICBnZXQ6ICh0YXJnZXQsIHByb3ApID0+IGdldFByb3BlcnR5KHRhcmdldCwgcHJvcCksXG4gICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiBnZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3ApICE9PSB1bmRlZmluZWRcbn0pO1xuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnbm9kZTpldmVudHMnO1xuaW1wb3J0IGlzIGZyb20gJ0BzaW5kcmVzb3JodXMvaXMnO1xuaW1wb3J0IFBDYW5jZWxhYmxlIGZyb20gJ3AtY2FuY2VsYWJsZSc7XG5pbXBvcnQgeyBIVFRQRXJyb3IsIFJldHJ5RXJyb3IsIH0gZnJvbSAnLi4vY29yZS9lcnJvcnMuanMnO1xuaW1wb3J0IFJlcXVlc3QgZnJvbSAnLi4vY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgeyBwYXJzZUJvZHksIGlzUmVzcG9uc2VPayB9IGZyb20gJy4uL2NvcmUvcmVzcG9uc2UuanMnO1xuaW1wb3J0IHByb3h5RXZlbnRzIGZyb20gJy4uL2NvcmUvdXRpbHMvcHJveHktZXZlbnRzLmpzJztcbmltcG9ydCB7IENhbmNlbEVycm9yIH0gZnJvbSAnLi90eXBlcy5qcyc7XG5jb25zdCBwcm94aWVkUmVxdWVzdEV2ZW50cyA9IFtcbiAgICAncmVxdWVzdCcsXG4gICAgJ3Jlc3BvbnNlJyxcbiAgICAncmVkaXJlY3QnLFxuICAgICd1cGxvYWRQcm9ncmVzcycsXG4gICAgJ2Rvd25sb2FkUHJvZ3Jlc3MnLFxuXTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFzUHJvbWlzZShmaXJzdFJlcXVlc3QpIHtcbiAgICBsZXQgZ2xvYmFsUmVxdWVzdDtcbiAgICBsZXQgZ2xvYmFsUmVzcG9uc2U7XG4gICAgbGV0IG5vcm1hbGl6ZWRPcHRpb25zO1xuICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQQ2FuY2VsYWJsZSgocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkgPT4ge1xuICAgICAgICBvbkNhbmNlbCgoKSA9PiB7XG4gICAgICAgICAgICBnbG9iYWxSZXF1ZXN0LmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uQ2FuY2VsLnNob3VsZFJlamVjdCA9IGZhbHNlO1xuICAgICAgICBvbkNhbmNlbCgoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IENhbmNlbEVycm9yKGdsb2JhbFJlcXVlc3QpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1ha2VSZXF1ZXN0ID0gKHJldHJ5Q291bnQpID0+IHtcbiAgICAgICAgICAgIC8vIEVycm9ycyB3aGVuIGEgbmV3IHJlcXVlc3QgaXMgbWFkZSBhZnRlciB0aGUgcHJvbWlzZSBzZXR0bGVzLlxuICAgICAgICAgICAgLy8gVXNlZCB0byBkZXRlY3QgYSByYWNlIGNvbmRpdGlvbi5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2dvdC9pc3N1ZXMvMTQ4OVxuICAgICAgICAgICAgb25DYW5jZWwoKCkgPT4geyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBmaXJzdFJlcXVlc3QgPz8gbmV3IFJlcXVlc3QodW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vcm1hbGl6ZWRPcHRpb25zKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmV0cnlDb3VudCA9IHJldHJ5Q291bnQ7XG4gICAgICAgICAgICByZXF1ZXN0Ll9ub1BpcGUgPSB0cnVlO1xuICAgICAgICAgICAgZ2xvYmFsUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uY2UoJ3Jlc3BvbnNlJywgYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYm9keVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IChyZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10gPz8gJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDb21wcmVzc2VkID0gY29udGVudEVuY29kaW5nID09PSAnZ3ppcCcgfHwgY29udGVudEVuY29kaW5nID09PSAnZGVmbGF0ZScgfHwgY29udGVudEVuY29kaW5nID09PSAnYnInO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkICYmICFvcHRpb25zLmRlY29tcHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IHJlc3BvbnNlLnJhd0JvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IHBhcnNlQm9keShyZXNwb25zZSwgb3B0aW9ucy5yZXNwb25zZVR5cGUsIG9wdGlvbnMucGFyc2VKc29uLCBvcHRpb25zLmVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBgdXRmOGBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSByZXNwb25zZS5yYXdCb2R5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXNwb25zZU9rKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuX2JlZm9yZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va3MgPSBvcHRpb25zLmhvb2tzLmFmdGVyUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBob29rXSBvZiBob29rcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgZG9lc24ndCBub3RpY2UgdGhhdCBDYW5jZWxhYmxlUmVxdWVzdCBpcyBhIFByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhvb2socmVzcG9uc2UsIGFzeW5jICh1cGRhdGVkT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWVyZ2UodXBkYXRlZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucHJlZml4VXJsID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWRPcHRpb25zLnVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IHVwZGF0ZWRPcHRpb25zLnVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBmdXJ0aGVyIGhvb2tzIGZvciB0aGF0IHJlcXVlc3QsIGJlY2F1c2Ugd2UnbGwgY2FsbCB0aGVtIGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbG9vcCBjb250aW51ZXMuIFdlIGRvbid0IHdhbnQgZHVwbGljYXRlcyAoYXNQcm9taXNlIHJlY3Vyc2lvbikuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ob29rcy5hZnRlclJlc3BvbnNlID0gb3B0aW9ucy5ob29rcy5hZnRlclJlc3BvbnNlLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcihyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXMub2JqZWN0KHJlc3BvbnNlKSAmJiBpcy5udW1iZXIocmVzcG9uc2Uuc3RhdHVzQ29kZSkgJiYgIWlzLm51bGxPclVuZGVmaW5lZChyZXNwb25zZS5ib2R5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYGFmdGVyUmVzcG9uc2VgIGhvb2sgcmV0dXJuZWQgYW4gaW52YWxpZCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Ll9iZWZvcmVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2xvYmFsUmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmVzcG9uc2VPayhyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5fYmVmb3JlRXJyb3IobmV3IEhUVFBFcnJvcihyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3QuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5vcHRpb25zLnJlc29sdmVCb2R5T25seSA/IHJlc3BvbnNlLmJvZHkgOiByZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZS5pc0NhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEhUVFBFcnJvciAmJiAhb3B0aW9ucy50aHJvd0h0dHBFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXNwb25zZSB9ID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3Qub3B0aW9ucy5yZXNvbHZlQm9keU9ubHkgPyByZXNwb25zZS5ib2R5IDogcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5vbmNlKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNCb2R5ID0gcmVxdWVzdC5vcHRpb25zPy5ib2R5O1xuICAgICAgICAgICAgcmVxdWVzdC5vbmNlKCdyZXRyeScsIChuZXdSZXRyeUNvdW50LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGZpcnN0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdCb2R5ID0gcmVxdWVzdC5vcHRpb25zLmJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQm9keSA9PT0gbmV3Qm9keSAmJiBpcy5ub2RlU3RyZWFtKG5ld0JvZHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSAnQ2Fubm90IHJldHJ5IHdpdGggY29uc3VtZWQgYm9keSBzdHJlYW0nO1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCEgV2UgbmVlZCB0byByZXVzZSBgcmVxdWVzdC5vcHRpb25zYCBiZWNhdXNlIHRoZXkgY2FuIGdldCBtb2RpZmllZCFcbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgYnkgY2FsbGluZyBgcHJvbWlzZS5qc29uKClgLlxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRPcHRpb25zID0gcmVxdWVzdC5vcHRpb25zO1xuICAgICAgICAgICAgICAgIG1ha2VSZXF1ZXN0KG5ld1JldHJ5Q291bnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm94eUV2ZW50cyhyZXF1ZXN0LCBlbWl0dGVyLCBwcm94aWVkUmVxdWVzdEV2ZW50cyk7XG4gICAgICAgICAgICBpZiAoaXMudW5kZWZpbmVkKGZpcnN0UmVxdWVzdCkpIHtcbiAgICAgICAgICAgICAgICB2b2lkIHJlcXVlc3QuZmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWFrZVJlcXVlc3QoMCk7XG4gICAgfSk7XG4gICAgcHJvbWlzZS5vbiA9IChldmVudCwgZm4pID0+IHtcbiAgICAgICAgZW1pdHRlci5vbihldmVudCwgZm4pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICAgIHByb21pc2Uub2ZmID0gKGV2ZW50LCBmbikgPT4ge1xuICAgICAgICBlbWl0dGVyLm9mZihldmVudCwgZm4pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICAgIGNvbnN0IHNob3J0Y3V0ID0gKHJlc3BvbnNlVHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgZG93bmxvYWRpbmcgaGFzIGVuZGVkXG4gICAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBnbG9iYWxSZXNwb25zZS5yZXF1ZXN0O1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQm9keShnbG9iYWxSZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBvcHRpb25zLnBhcnNlSnNvbiwgb3B0aW9ucy5lbmNvZGluZyk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobmV3UHJvbWlzZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocHJvbWlzZSkpO1xuICAgICAgICByZXR1cm4gbmV3UHJvbWlzZTtcbiAgICB9O1xuICAgIHByb21pc2UuanNvbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKGdsb2JhbFJlcXVlc3Qub3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgeyBoZWFkZXJzIH0gPSBnbG9iYWxSZXF1ZXN0Lm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoIWdsb2JhbFJlcXVlc3Qud3JpdGFibGVGaW5pc2hlZCAmJiAhKCdhY2NlcHQnIGluIGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5hY2NlcHQgPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNob3J0Y3V0KCdqc29uJyk7XG4gICAgfTtcbiAgICBwcm9taXNlLmJ1ZmZlciA9ICgpID0+IHNob3J0Y3V0KCdidWZmZXInKTtcbiAgICBwcm9taXNlLnRleHQgPSAoKSA9PiBzaG9ydGN1dCgndGV4dCcpO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuIiwiaW1wb3J0IHsgUmVxdWVzdEVycm9yIH0gZnJvbSAnLi4vY29yZS9lcnJvcnMuanMnO1xuLyoqXG5BbiBlcnJvciB0byBiZSB0aHJvd24gd2hlbiB0aGUgcmVxdWVzdCBpcyBhYm9ydGVkIHdpdGggYC5jYW5jZWwoKWAuXG4qL1xuZXhwb3J0IGNsYXNzIENhbmNlbEVycm9yIGV4dGVuZHMgUmVxdWVzdEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZXF1ZXN0KSB7XG4gICAgICAgIHN1cGVyKCdQcm9taXNlIHdhcyBjYW5jZWxlZCcsIHt9LCByZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NhbmNlbEVycm9yJztcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9DQU5DRUxFRCc7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHByb21pc2UgaXMgY2FuY2VsZWQuXG4gICAgKi9cbiAgICBnZXQgaXNDYW5jZWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuIiwiY29uc3QgY2FsY3VsYXRlUmV0cnlEZWxheSA9ICh7IGF0dGVtcHRDb3VudCwgcmV0cnlPcHRpb25zLCBlcnJvciwgcmV0cnlBZnRlciwgY29tcHV0ZWRWYWx1ZSwgfSkgPT4ge1xuICAgIGlmIChlcnJvci5uYW1lID09PSAnUmV0cnlFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChhdHRlbXB0Q291bnQgPiByZXRyeU9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IGhhc01ldGhvZCA9IHJldHJ5T3B0aW9ucy5tZXRob2RzLmluY2x1ZGVzKGVycm9yLm9wdGlvbnMubWV0aG9kKTtcbiAgICBjb25zdCBoYXNFcnJvckNvZGUgPSByZXRyeU9wdGlvbnMuZXJyb3JDb2Rlcy5pbmNsdWRlcyhlcnJvci5jb2RlKTtcbiAgICBjb25zdCBoYXNTdGF0dXNDb2RlID0gZXJyb3IucmVzcG9uc2UgJiYgcmV0cnlPcHRpb25zLnN0YXR1c0NvZGVzLmluY2x1ZGVzKGVycm9yLnJlc3BvbnNlLnN0YXR1c0NvZGUpO1xuICAgIGlmICghaGFzTWV0aG9kIHx8ICghaGFzRXJyb3JDb2RlICYmICFoYXNTdGF0dXNDb2RlKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXRyeUFmdGVyKSB7XG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UgYGNvbXB1dGVkVmFsdWVgIGlzIGBvcHRpb25zLnJlcXVlc3QudGltZW91dGBcbiAgICAgICAgICAgIGlmIChyZXRyeUFmdGVyID4gY29tcHV0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldHJ5QWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQxMykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9pc2UgPSBNYXRoLnJhbmRvbSgpICogcmV0cnlPcHRpb25zLm5vaXNlO1xuICAgIHJldHVybiBNYXRoLm1pbigoKDIgKiogKGF0dGVtcHRDb3VudCAtIDEpKSAqIDEwMDApLCByZXRyeU9wdGlvbnMuYmFja29mZkxpbWl0KSArIG5vaXNlO1xufTtcbmV4cG9ydCBkZWZhdWx0IGNhbGN1bGF0ZVJldHJ5RGVsYXk7XG4iLCJpbXBvcnQgaXMgZnJvbSAnQHNpbmRyZXNvcmh1cy9pcyc7XG4vLyBBIGhhY2t5IGNoZWNrIHRvIHByZXZlbnQgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbmZ1bmN0aW9uIGlzUmVxdWVzdCh4KSB7XG4gICAgcmV0dXJuIGlzLm9iamVjdCh4KSAmJiAnX29uUmVzcG9uc2UnIGluIHg7XG59XG4vKipcbkFuIGVycm9yIHRvIGJlIHRocm93biB3aGVuIGEgcmVxdWVzdCBmYWlscy5cbkNvbnRhaW5zIGEgYGNvZGVgIHByb3BlcnR5IHdpdGggZXJyb3IgY2xhc3MgY29kZSwgbGlrZSBgRUNPTk5SRUZVU0VEYC5cbiovXG5leHBvcnQgY2xhc3MgUmVxdWVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9yLCBzZWxmKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3BvbnNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcXVlc3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGltaW5nc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1JlcXVlc3RFcnJvcic7XG4gICAgICAgIHRoaXMuY29kZSA9IGVycm9yLmNvZGUgPz8gJ0VSUl9HT1RfUkVRVUVTVF9FUlJPUic7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBlcnJvci5pbnB1dDtcbiAgICAgICAgaWYgKGlzUmVxdWVzdChzZWxmKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZXF1ZXN0Jywge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzZWxmLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Jlc3BvbnNlJywge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzZWxmLnJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltaW5ncyA9IHRoaXMucmVxdWVzdD8udGltaW5ncztcbiAgICAgICAgLy8gUmVjb3ZlciB0aGUgb3JpZ2luYWwgc3RhY2t0cmFjZVxuICAgICAgICBpZiAoaXMuc3RyaW5nKGVycm9yLnN0YWNrKSAmJiBpcy5zdHJpbmcodGhpcy5zdGFjaykpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4T2ZNZXNzYWdlID0gdGhpcy5zdGFjay5pbmRleE9mKHRoaXMubWVzc2FnZSkgKyB0aGlzLm1lc3NhZ2UubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgdGhpc1N0YWNrVHJhY2UgPSB0aGlzLnN0YWNrLnNsaWNlKGluZGV4T2ZNZXNzYWdlKS5zcGxpdCgnXFxuJykucmV2ZXJzZSgpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JTdGFja1RyYWNlID0gZXJyb3Iuc3RhY2suc2xpY2UoZXJyb3Iuc3RhY2suaW5kZXhPZihlcnJvci5tZXNzYWdlKSArIGVycm9yLm1lc3NhZ2UubGVuZ3RoKS5zcGxpdCgnXFxuJykucmV2ZXJzZSgpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZWQgdHJhY2VzXG4gICAgICAgICAgICB3aGlsZSAoZXJyb3JTdGFja1RyYWNlLmxlbmd0aCA+IDAgJiYgZXJyb3JTdGFja1RyYWNlWzBdID09PSB0aGlzU3RhY2tUcmFjZVswXSkge1xuICAgICAgICAgICAgICAgIHRoaXNTdGFja1RyYWNlLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gYCR7dGhpcy5zdGFjay5zbGljZSgwLCBpbmRleE9mTWVzc2FnZSl9JHt0aGlzU3RhY2tUcmFjZS5yZXZlcnNlKCkuam9pbignXFxuJyl9JHtlcnJvclN0YWNrVHJhY2UucmV2ZXJzZSgpLmpvaW4oJ1xcbicpfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbkFuIGVycm9yIHRvIGJlIHRocm93biB3aGVuIHRoZSBzZXJ2ZXIgcmVkaXJlY3RzIHlvdSBtb3JlIHRoYW4gdGVuIHRpbWVzLlxuSW5jbHVkZXMgYSBgcmVzcG9uc2VgIHByb3BlcnR5LlxuKi9cbmV4cG9ydCBjbGFzcyBNYXhSZWRpcmVjdHNFcnJvciBleHRlbmRzIFJlcXVlc3RFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVxdWVzdCkge1xuICAgICAgICBzdXBlcihgUmVkaXJlY3RlZCAke3JlcXVlc3Qub3B0aW9ucy5tYXhSZWRpcmVjdHN9IHRpbWVzLiBBYm9ydGluZy5gLCB7fSwgcmVxdWVzdCk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdNYXhSZWRpcmVjdHNFcnJvcic7XG4gICAgICAgIHRoaXMuY29kZSA9ICdFUlJfVE9PX01BTllfUkVESVJFQ1RTJztcbiAgICB9XG59XG4vKipcbkFuIGVycm9yIHRvIGJlIHRocm93biB3aGVuIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgY29kZSBpcyBub3QgMnh4IG5vciAzeHggaWYgYG9wdGlvbnMuZm9sbG93UmVkaXJlY3RgIGlzIGB0cnVlYCwgYnV0IGFsd2F5cyBleGNlcHQgZm9yIDMwNC5cbkluY2x1ZGVzIGEgYHJlc3BvbnNlYCBwcm9wZXJ0eS5cbiovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY2xhc3MgSFRUUEVycm9yIGV4dGVuZHMgUmVxdWVzdEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICBzdXBlcihgUmVzcG9uc2UgY29kZSAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9ICgke3Jlc3BvbnNlLnN0YXR1c01lc3NhZ2V9KWAsIHt9LCByZXNwb25zZS5yZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0hUVFBFcnJvcic7XG4gICAgICAgIHRoaXMuY29kZSA9ICdFUlJfTk9OXzJYWF8zWFhfUkVTUE9OU0UnO1xuICAgIH1cbn1cbi8qKlxuQW4gZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gYSBjYWNoZSBtZXRob2QgZmFpbHMuXG5Gb3IgZXhhbXBsZSwgaWYgdGhlIGRhdGFiYXNlIGdvZXMgZG93biBvciB0aGVyZSdzIGEgZmlsZXN5c3RlbSBlcnJvci5cbiovXG5leHBvcnQgY2xhc3MgQ2FjaGVFcnJvciBleHRlbmRzIFJlcXVlc3RFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoZXJyb3IubWVzc2FnZSwgZXJyb3IsIHJlcXVlc3QpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQ2FjaGVFcnJvcic7XG4gICAgICAgIHRoaXMuY29kZSA9IHRoaXMuY29kZSA9PT0gJ0VSUl9HT1RfUkVRVUVTVF9FUlJPUicgPyAnRVJSX0NBQ0hFX0FDQ0VTUycgOiB0aGlzLmNvZGU7XG4gICAgfVxufVxuLyoqXG5BbiBlcnJvciB0byBiZSB0aHJvd24gd2hlbiB0aGUgcmVxdWVzdCBib2R5IGlzIGEgc3RyZWFtIGFuZCBhbiBlcnJvciBvY2N1cnMgd2hpbGUgcmVhZGluZyBmcm9tIHRoYXQgc3RyZWFtLlxuKi9cbmV4cG9ydCBjbGFzcyBVcGxvYWRFcnJvciBleHRlbmRzIFJlcXVlc3RFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoZXJyb3IubWVzc2FnZSwgZXJyb3IsIHJlcXVlc3QpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVXBsb2FkRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLmNvZGUgPT09ICdFUlJfR09UX1JFUVVFU1RfRVJST1InID8gJ0VSUl9VUExPQUQnIDogdGhpcy5jb2RlO1xuICAgIH1cbn1cbi8qKlxuQW4gZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gdGhlIHJlcXVlc3QgaXMgYWJvcnRlZCBkdWUgdG8gYSB0aW1lb3V0LlxuSW5jbHVkZXMgYW4gYGV2ZW50YCBhbmQgYHRpbWluZ3NgIHByb3BlcnR5LlxuKi9cbmV4cG9ydCBjbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBSZXF1ZXN0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9yLCB0aW1pbmdzLCByZXF1ZXN0KSB7XG4gICAgICAgIHN1cGVyKGVycm9yLm1lc3NhZ2UsIGVycm9yLCByZXF1ZXN0KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGltaW5nc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVGltZW91dEVycm9yJztcbiAgICAgICAgdGhpcy5ldmVudCA9IGVycm9yLmV2ZW50O1xuICAgICAgICB0aGlzLnRpbWluZ3MgPSB0aW1pbmdzO1xuICAgIH1cbn1cbi8qKlxuQW4gZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gcmVhZGluZyBmcm9tIHJlc3BvbnNlIHN0cmVhbSBmYWlscy5cbiovXG5leHBvcnQgY2xhc3MgUmVhZEVycm9yIGV4dGVuZHMgUmVxdWVzdEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvciwgcmVxdWVzdCkge1xuICAgICAgICBzdXBlcihlcnJvci5tZXNzYWdlLCBlcnJvciwgcmVxdWVzdCk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdSZWFkRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLmNvZGUgPT09ICdFUlJfR09UX1JFUVVFU1RfRVJST1InID8gJ0VSUl9SRUFESU5HX1JFU1BPTlNFX1NUUkVBTScgOiB0aGlzLmNvZGU7XG4gICAgfVxufVxuLyoqXG5BbiBlcnJvciB3aGljaCBhbHdheXMgdHJpZ2dlcnMgYSBuZXcgcmV0cnkgd2hlbiB0aHJvd24uXG4qL1xuZXhwb3J0IGNsYXNzIFJldHJ5RXJyb3IgZXh0ZW5kcyBSZXF1ZXN0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoJ1JldHJ5aW5nJywge30sIHJlcXVlc3QpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUmV0cnlFcnJvcic7XG4gICAgICAgIHRoaXMuY29kZSA9ICdFUlJfUkVUUllJTkcnO1xuICAgIH1cbn1cbi8qKlxuQW4gZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gdGhlIHJlcXVlc3QgaXMgYWJvcnRlZCBieSBBYm9ydENvbnRyb2xsZXIuXG4qL1xuZXhwb3J0IGNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBSZXF1ZXN0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoJ1RoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsIHt9LCByZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9BQk9SVEVEJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICAgIH1cbn1cbiIsImltcG9ydCBwcm9jZXNzIGZyb20gJ25vZGU6cHJvY2Vzcyc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdub2RlOmJ1ZmZlcic7XG5pbXBvcnQgeyBEdXBsZXggfSBmcm9tICdub2RlOnN0cmVhbSc7XG5pbXBvcnQgeyBVUkwsIFVSTFNlYXJjaFBhcmFtcyB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCBodHRwLCB7IFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnbm9kZTpodHRwJztcbmltcG9ydCB0aW1lciBmcm9tICdAc3ptYXJjemFrL2h0dHAtdGltZXInO1xuaW1wb3J0IENhY2hlYWJsZVJlcXVlc3QsIHsgQ2FjaGVFcnJvciBhcyBDYWNoZWFibGVDYWNoZUVycm9yLCB9IGZyb20gJ2NhY2hlYWJsZS1yZXF1ZXN0JztcbmltcG9ydCBkZWNvbXByZXNzUmVzcG9uc2UgZnJvbSAnZGVjb21wcmVzcy1yZXNwb25zZSc7XG5pbXBvcnQgaXMgZnJvbSAnQHNpbmRyZXNvcmh1cy9pcyc7XG5pbXBvcnQgeyBidWZmZXIgYXMgZ2V0QnVmZmVyIH0gZnJvbSAnZ2V0LXN0cmVhbSc7XG5pbXBvcnQgeyBGb3JtRGF0YUVuY29kZXIsIGlzRm9ybURhdGEgYXMgaXNGb3JtRGF0YUxpa2UgfSBmcm9tICdmb3JtLWRhdGEtZW5jb2Rlcic7XG5pbXBvcnQgZ2V0Qm9keVNpemUgZnJvbSAnLi91dGlscy9nZXQtYm9keS1zaXplLmpzJztcbmltcG9ydCBpc0Zvcm1EYXRhIGZyb20gJy4vdXRpbHMvaXMtZm9ybS1kYXRhLmpzJztcbmltcG9ydCBwcm94eUV2ZW50cyBmcm9tICcuL3V0aWxzL3Byb3h5LWV2ZW50cy5qcyc7XG5pbXBvcnQgdGltZWRPdXQsIHsgVGltZW91dEVycm9yIGFzIFRpbWVkT3V0VGltZW91dEVycm9yIH0gZnJvbSAnLi90aW1lZC1vdXQuanMnO1xuaW1wb3J0IHVybFRvT3B0aW9ucyBmcm9tICcuL3V0aWxzL3VybC10by1vcHRpb25zLmpzJztcbmltcG9ydCBXZWFrYWJsZU1hcCBmcm9tICcuL3V0aWxzL3dlYWthYmxlLW1hcC5qcyc7XG5pbXBvcnQgY2FsY3VsYXRlUmV0cnlEZWxheSBmcm9tICcuL2NhbGN1bGF0ZS1yZXRyeS1kZWxheS5qcyc7XG5pbXBvcnQgT3B0aW9ucyBmcm9tICcuL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgaXNSZXNwb25zZU9rIH0gZnJvbSAnLi9yZXNwb25zZS5qcyc7XG5pbXBvcnQgaXNDbGllbnRSZXF1ZXN0IGZyb20gJy4vdXRpbHMvaXMtY2xpZW50LXJlcXVlc3QuanMnO1xuaW1wb3J0IGlzVW5peFNvY2tldFVSTCBmcm9tICcuL3V0aWxzL2lzLXVuaXgtc29ja2V0LXVybC5qcyc7XG5pbXBvcnQgeyBSZXF1ZXN0RXJyb3IsIFJlYWRFcnJvciwgTWF4UmVkaXJlY3RzRXJyb3IsIEhUVFBFcnJvciwgVGltZW91dEVycm9yLCBVcGxvYWRFcnJvciwgQ2FjaGVFcnJvciwgQWJvcnRFcnJvciwgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5jb25zdCBzdXBwb3J0c0Jyb3RsaSA9IGlzLnN0cmluZyhwcm9jZXNzLnZlcnNpb25zLmJyb3RsaSk7XG5jb25zdCBtZXRob2RzV2l0aG91dEJvZHkgPSBuZXcgU2V0KFsnR0VUJywgJ0hFQUQnXSk7XG5jb25zdCBjYWNoZWFibGVTdG9yZSA9IG5ldyBXZWFrYWJsZU1hcCgpO1xuY29uc3QgcmVkaXJlY3RDb2RlcyA9IG5ldyBTZXQoWzMwMCwgMzAxLCAzMDIsIDMwMywgMzA0LCAzMDcsIDMwOF0pO1xuY29uc3QgcHJveGllZFJlcXVlc3RFdmVudHMgPSBbXG4gICAgJ3NvY2tldCcsXG4gICAgJ2Nvbm5lY3QnLFxuICAgICdjb250aW51ZScsXG4gICAgJ2luZm9ybWF0aW9uJyxcbiAgICAndXBncmFkZScsXG5dO1xuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlcXVlc3QgZXh0ZW5kcyBEdXBsZXgge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucywgZGVmYXVsdHMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLy8gRG9uJ3QgZGVzdHJveSBpbW1lZGlhdGVseSwgYXMgdGhlIGVycm9yIG1heSBiZSBlbWl0dGVkIG9uIHVuc3VjY2Vzc2Z1bCByZXRyeVxuICAgICAgICAgICAgYXV0b0Rlc3Ryb3k6IGZhbHNlLFxuICAgICAgICAgICAgLy8gSXQgbmVlZHMgdG8gYmUgemVybyBiZWNhdXNlIHdlJ3JlIGp1c3QgcHJveHlpbmcgdGhlIGRhdGEgdG8gYW5vdGhlciBzdHJlYW1cbiAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gSWdub3JpbmcgZm9yIG5vdy5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb25zdHJ1Y3RvcicsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ub1BpcGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzk1NjhcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNwb25zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXF1ZXN0VXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZGlyZWN0VXJsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXRyeUNvdW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdG9wUmV0cnlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rvd25sb2FkZWRTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl91cGxvYWRlZFNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N0b3BSZWFkaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9waXBlZFNlcnZlclJlc3BvbnNlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcmVxdWVzdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcmVzcG9uc2VTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ib2R5U2l6ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdW5wcm94eUV2ZW50c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaXNGcm9tQ2FjaGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Nhbm5vdEhhdmVCb2R5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90cmlnZ2VyUmVhZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2FuY2VsVGltZW91dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JlbW92ZUxpc3RlbmVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbmF0aXZlUmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZsdXNoZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Fib3J0ZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2UgbmVlZCB0aGlzIGJlY2F1c2UgYHRoaXMuX3JlcXVlc3RgIGlmIGB1bmRlZmluZWRgIHdoZW4gdXNpbmcgY2FjaGVcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JlcXVlc3RJbml0aWFsaXplZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kb3dubG9hZGVkU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3VwbG9hZGVkU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3N0b3BSZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BpcGVkU2VydmVyUmVzcG9uc2VzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9jYW5ub3RIYXZlQm9keSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl91bnByb3h5RXZlbnRzID0gbm9vcDtcbiAgICAgICAgdGhpcy5fdHJpZ2dlclJlYWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2FuY2VsVGltZW91dHMgPSBub29wO1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBub29wO1xuICAgICAgICB0aGlzLl9qb2JzID0gW107XG4gICAgICAgIHRoaXMuX2ZsdXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdEluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Fib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWRpcmVjdFVybHMgPSBbXTtcbiAgICAgICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fc3RvcFJldHJ5ID0gbm9vcDtcbiAgICAgICAgdGhpcy5vbigncGlwZScsIHNvdXJjZSA9PiB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucy5oZWFkZXJzLCBzb3VyY2UuaGVhZGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gJ3JldHJ5JyAmJiB0aGlzLmxpc3RlbmVyQ291bnQoJ3JldHJ5JykgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHJldHJ5IGxpc3RlbmVyIGhhcyBiZWVuIGF0dGFjaGVkIGFscmVhZHkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gbmV3IE9wdGlvbnModXJsLCBvcHRpb25zLCBkZWZhdWx0cyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZWZpeFVybCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBgdXJsYCBwcm9wZXJ0eScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudXJsID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RVcmwgPSB0aGlzLm9wdGlvbnMudXJsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBlcnJvcjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmx1c2ggPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCA9IGFzeW5jICgpID0+IHsgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbXBvcnRhbnQhIElmIHlvdSByZXBsYWNlIGBib2R5YCBpbiBhIGhhbmRsZXIgd2l0aCBhbm90aGVyIHN0cmVhbSwgbWFrZSBzdXJlIGl0J3MgcmVhZGFibGUgZmlyc3QuXG4gICAgICAgIC8vIFRoZSBiZWxvdyBpcyBydW4gb25seSBvbmNlLlxuICAgICAgICBjb25zdCB7IGJvZHkgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKGlzLm5vZGVTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgICAgIGJvZHkub25jZSgnZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZsdXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmVmb3JlRXJyb3IobmV3IFVwbG9hZEVycm9yKGVycm9yLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaCA9IGFzeW5jICgpID0+IHsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2JlZm9yZUVycm9yKG5ldyBVcGxvYWRFcnJvcihlcnJvciwgdGhpcykpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICBjb25zdCBhYm9ydCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3kobmV3IEFib3J0RXJyb3IodGhpcykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZsdXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mbHVzaGVkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2ZpbmFsaXplQm9keSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbWFrZVJlcXVlc3QoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3Q/LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBRdWV1ZWQgd3JpdGVzIGV0Yy5cbiAgICAgICAgICAgIGZvciAoY29uc3Qgam9iIG9mIHRoaXMuX2pvYnMpIHtcbiAgICAgICAgICAgICAgICBqb2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICAgICAgICAgIHRoaXMuX2pvYnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9iZWZvcmVFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2JlZm9yZUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdG9wUmVhZGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcmVzcG9uc2UsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGF0dGVtcHRDb3VudCA9IHRoaXMucmV0cnlDb3VudCArIChlcnJvci5uYW1lID09PSAnUmV0cnlFcnJvcicgPyAwIDogMSk7XG4gICAgICAgIHRoaXMuX3N0b3BSZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBSZXF1ZXN0RXJyb3IpKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBSZXF1ZXN0RXJyb3IoZXJyb3IubWVzc2FnZSwgZXJyb3IsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdm9pZCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gTm9kZS5qcyBwYXJzZXIgaXMgcmVhbGx5IHdlaXJkLlxuICAgICAgICAgICAgLy8gSXQgZW1pdHMgcG9zdC1yZXF1ZXN0IFBhcnNlIEVycm9ycyBvbiB0aGUgc2FtZSBpbnN0YW5jZSBhcyBwcmV2aW91cyByZXF1ZXN0LiBXVEYuXG4gICAgICAgICAgICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBjaGVjayBpZiBpdCBoYXMgYmVlbiBkZXN0cm95ZWQgYXMgd2VsbC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGdXJ0aGVybW9yZSwgTm9kZS5qcyAxNiBgcmVzcG9uc2UuZGVzdHJveSgpYCBkb2Vzbid0IGltbWVkaWF0ZWx5IGRlc3Ryb3kgdGhlIHNvY2tldCxcbiAgICAgICAgICAgIC8vIGJ1dCBtYWtlcyB0aGUgcmVzcG9uc2UgdW5yZWFkYWJsZS4gU28gd2UgYWRkaXRpb25hbGx5IG5lZWQgdG8gY2hlY2sgYHJlc3BvbnNlLnJlYWRhYmxlYC5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZT8ucmVhZGFibGUgJiYgIXJlc3BvbnNlLnJhd0JvZHkgJiYgIXRoaXMuX3JlcXVlc3Q/LnNvY2tldD8uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHR5cGVzL25vZGUgaGFzIGluY29ycmVjdCB0eXBpbmdzLiBgc2V0RW5jb2RpbmdgIGFjY2VwdHMgYG51bGxgIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2V0RW5jb2RpbmcodGhpcy5yZWFkYWJsZUVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5fc2V0UmF3Qm9keShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IHJlc3BvbnNlLnJhd0JvZHkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdyZXRyeScpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJhY2tvZmY7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJldHJ5QWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAncmV0cnktYWZ0ZXInIGluIHJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5QWZ0ZXIgPSBOdW1iZXIocmVzcG9uc2UuaGVhZGVyc1sncmV0cnktYWZ0ZXInXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHJldHJ5QWZ0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlBZnRlciA9IERhdGUucGFyc2UocmVzcG9uc2UuaGVhZGVyc1sncmV0cnktYWZ0ZXInXSkgLSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRyeUFmdGVyIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlBZnRlciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlBZnRlciAqPSAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5T3B0aW9ucyA9IG9wdGlvbnMucmV0cnk7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tvZmYgPSBhd2FpdCByZXRyeU9wdGlvbnMuY2FsY3VsYXRlRGVsYXkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHR5cGVkRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeUFmdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRWYWx1ZTogY2FsY3VsYXRlUmV0cnlEZWxheSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogdHlwZWRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUFmdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkVmFsdWU6IHJldHJ5T3B0aW9ucy5tYXhSZXRyeUFmdGVyID8/IG9wdGlvbnMudGltZW91dC5yZXF1ZXN0ID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yXykge1xuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuX2Vycm9yKG5ldyBSZXF1ZXN0RXJyb3IoZXJyb3JfLm1lc3NhZ2UsIGVycm9yXywgdGhpcykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiYWNrb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQocmVzb2x2ZSwgYmFja29mZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wUmV0cnkgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgZm9yY2VkIHVzIHRvIGFib3J0IHRoZSByZXRyeVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBob29rIG9mIHRoaXMub3B0aW9ucy5ob29rcy5iZWZvcmVSZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgaG9vayh0eXBlZEVycm9yLCB0aGlzLnJldHJ5Q291bnQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3JfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuX2Vycm9yKG5ldyBSZXF1ZXN0RXJyb3IoZXJyb3JfLm1lc3NhZ2UsIGVycm9yLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIGZvcmNlZCB1cyB0byBhYm9ydCB0aGUgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmV0cnknLCB0aGlzLnJldHJ5Q291bnQgKyAxLCBlcnJvciwgKHVwZGF0ZWRPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3Qob3B0aW9ucy51cmwsIHVwZGF0ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmV0cnlDb3VudCA9IHRoaXMucmV0cnlDb3VudCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIHJlcXVlc3QuZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm9pZCB0aGlzLl9lcnJvcih0eXBlZEVycm9yKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgX3JlYWQoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJSZWFkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyByZXNwb25zZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHJlc3BvbnNlICYmICF0aGlzLl9zdG9wUmVhZGluZykge1xuICAgICAgICAgICAgLy8gV2UgY2Fubm90IHB1dCB0aGlzIGluIHRoZSBgaWZgIGFib3ZlXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGAucmVhZCgpYCBhbHNvIHRyaWdnZXJzIHRoZSBgZW5kYCBldmVudFxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlYWRhYmxlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlclJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgd2hpbGUgKChkYXRhID0gcmVzcG9uc2UucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rvd25sb2FkZWRTaXplICs9IGRhdGEubGVuZ3RoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLmRvd25sb2FkUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzLnBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZG93bmxvYWRQcm9ncmVzcycsIHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHdyaXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd3JpdGVSZXF1ZXN0KGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdEluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fam9icy5wdXNoKHdyaXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZmluYWwoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgZW5kUmVxdWVzdCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgYHRoaXMuX3JlcXVlc3RgIGlzIHByZXNlbnQsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0IGlzbid0IHdoZW4gd2UgdXNlIGNhY2hlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0IHx8IHRoaXMuX3JlcXVlc3QuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LmVuZCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVxdWVzdCBoYXMgYmVlbiBkZXN0cm95ZWQgYmVmb3JlIGBfZmluYWxgIGZpbmlzaGVkLlxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzM5MzU2XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QuX3dyaXRhYmxlU3RhdGU/LmVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlTaXplID0gdGhpcy5fdXBsb2FkZWRTaXplO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwbG9hZFByb2dyZXNzJywgdGhpcy51cGxvYWRQcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QuZW1pdCgndXBsb2FkLWNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdEluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBlbmRSZXF1ZXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9qb2JzLnB1c2goZW5kUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Rlc3Ryb3koZXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3N0b3BSZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mbHVzaCA9IGFzeW5jICgpID0+IHsgfTtcbiAgICAgICAgLy8gUHJldmVudCBmdXJ0aGVyIHJldHJpZXNcbiAgICAgICAgdGhpcy5fc3RvcFJldHJ5KCk7XG4gICAgICAgIHRoaXMuX2NhbmNlbFRpbWVvdXRzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IGJvZHkgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChpcy5ub2RlU3RyZWFtKGJvZHkpKSB7XG4gICAgICAgICAgICAgICAgYm9keS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAhPT0gbnVsbCAmJiAhaXMudW5kZWZpbmVkKGVycm9yKSAmJiAhKGVycm9yIGluc3RhbmNlb2YgUmVxdWVzdEVycm9yKSkge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgUmVxdWVzdEVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfVxuICAgIHBpcGUoZGVzdGluYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgU2VydmVyUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3BpcGVkU2VydmVyUmVzcG9uc2VzLmFkZChkZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnBpcGUoZGVzdGluYXRpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgICB1bnBpcGUoZGVzdGluYXRpb24pIHtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgU2VydmVyUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3BpcGVkU2VydmVyUmVzcG9uc2VzLmRlbGV0ZShkZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIudW5waXBlKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIF9maW5hbGl6ZUJvZHkoKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBoZWFkZXJzIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBpc0Zvcm0gPSAhaXMudW5kZWZpbmVkKG9wdGlvbnMuZm9ybSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICAgICAgY29uc3QgaXNKU09OID0gIWlzLnVuZGVmaW5lZChvcHRpb25zLmpzb24pO1xuICAgICAgICBjb25zdCBpc0JvZHkgPSAhaXMudW5kZWZpbmVkKG9wdGlvbnMuYm9keSk7XG4gICAgICAgIGNvbnN0IGNhbm5vdEhhdmVCb2R5ID0gbWV0aG9kc1dpdGhvdXRCb2R5LmhhcyhvcHRpb25zLm1ldGhvZCkgJiYgIShvcHRpb25zLm1ldGhvZCA9PT0gJ0dFVCcgJiYgb3B0aW9ucy5hbGxvd0dldEJvZHkpO1xuICAgICAgICB0aGlzLl9jYW5ub3RIYXZlQm9keSA9IGNhbm5vdEhhdmVCb2R5O1xuICAgICAgICBpZiAoaXNGb3JtIHx8IGlzSlNPTiB8fCBpc0JvZHkpIHtcbiAgICAgICAgICAgIGlmIChjYW5ub3RIYXZlQm9keSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGAke29wdGlvbnMubWV0aG9kfVxcYCBtZXRob2QgY2Fubm90IGJlIHVzZWQgd2l0aCBhIGJvZHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBib2R5XG4gICAgICAgICAgICBjb25zdCBub0NvbnRlbnRUeXBlID0gIWlzLnN0cmluZyhoZWFkZXJzWydjb250ZW50LXR5cGUnXSk7XG4gICAgICAgICAgICBpZiAoaXNCb2R5KSB7XG4gICAgICAgICAgICAgICAgLy8gQm9keSBpcyBzcGVjLWNvbXBsaWFudCBGb3JtRGF0YVxuICAgICAgICAgICAgICAgIGlmIChpc0Zvcm1EYXRhTGlrZShvcHRpb25zLmJvZHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgRm9ybURhdGFFbmNvZGVyKG9wdGlvbnMuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub0NvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IGVuY29kZXIuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdDb250ZW50LUxlbmd0aCcgaW4gZW5jb2Rlci5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LWxlbmd0aCddID0gZW5jb2Rlci5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IGVuY29kZXIuZW5jb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGFcbiAgICAgICAgICAgICAgICBpZiAoaXNGb3JtRGF0YShvcHRpb25zLmJvZHkpICYmIG5vQ29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBgbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JHtvcHRpb25zLmJvZHkuZ2V0Qm91bmRhcnkoKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRm9ybSkge1xuICAgICAgICAgICAgICAgIGlmIChub0NvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZm9ybSB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZvcm0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gKG5ldyBVUkxTZWFyY2hQYXJhbXMoZm9ybSkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobm9Db250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBqc29uIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuanNvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBvcHRpb25zLnN0cmluZ2lmeUpzb24oanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cGxvYWRCb2R5U2l6ZSA9IGF3YWl0IGdldEJvZHlTaXplKG9wdGlvbnMuYm9keSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG4gICAgICAgICAgICAvLyBBIHVzZXIgYWdlbnQgU0hPVUxEIHNlbmQgYSBDb250ZW50LUxlbmd0aCBpbiBhIHJlcXVlc3QgbWVzc2FnZSB3aGVuXG4gICAgICAgICAgICAvLyBubyBUcmFuc2Zlci1FbmNvZGluZyBpcyBzZW50IGFuZCB0aGUgcmVxdWVzdCBtZXRob2QgZGVmaW5lcyBhIG1lYW5pbmdcbiAgICAgICAgICAgIC8vIGZvciBhbiBlbmNsb3NlZCBwYXlsb2FkIGJvZHkuICBGb3IgZXhhbXBsZSwgYSBDb250ZW50LUxlbmd0aCBoZWFkZXJcbiAgICAgICAgICAgIC8vIGZpZWxkIGlzIG5vcm1hbGx5IHNlbnQgaW4gYSBQT1NUIHJlcXVlc3QgZXZlbiB3aGVuIHRoZSB2YWx1ZSBpcyAwXG4gICAgICAgICAgICAvLyAoaW5kaWNhdGluZyBhbiBlbXB0eSBwYXlsb2FkIGJvZHkpLiAgQSB1c2VyIGFnZW50IFNIT1VMRCBOT1Qgc2VuZCBhXG4gICAgICAgICAgICAvLyBDb250ZW50LUxlbmd0aCBoZWFkZXIgZmllbGQgd2hlbiB0aGUgcmVxdWVzdCBtZXNzYWdlIGRvZXMgbm90IGNvbnRhaW5cbiAgICAgICAgICAgIC8vIGEgcGF5bG9hZCBib2R5IGFuZCB0aGUgbWV0aG9kIHNlbWFudGljcyBkbyBub3QgYW50aWNpcGF0ZSBzdWNoIGFcbiAgICAgICAgICAgIC8vIGJvZHkuXG4gICAgICAgICAgICBpZiAoaXMudW5kZWZpbmVkKGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pICYmIGlzLnVuZGVmaW5lZChoZWFkZXJzWyd0cmFuc2Zlci1lbmNvZGluZyddKSAmJiAhY2Fubm90SGF2ZUJvZHkgJiYgIWlzLnVuZGVmaW5lZCh1cGxvYWRCb2R5U2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LWxlbmd0aCddID0gU3RyaW5nKHVwbG9hZEJvZHlTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5yZXNwb25zZVR5cGUgPT09ICdqc29uJyAmJiAhKCdhY2NlcHQnIGluIG9wdGlvbnMuaGVhZGVycykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycy5hY2NlcHQgPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYm9keVNpemUgPSBOdW1iZXIoaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSkgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBfb25SZXNwb25zZUJhc2UocmVzcG9uc2UpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCBlLmcuIHdoZW4gdXNpbmcgY2FjaGUgc28gd2UgbmVlZCB0byBjaGVjayBpZiB0aGlzIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgICAgaWYgKHRoaXMuaXNBYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHVybCB9ID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fbmF0aXZlUmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVjb21wcmVzcykge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBkZWNvbXByZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICBjb25zdCB0eXBlZFJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHR5cGVkUmVzcG9uc2Uuc3RhdHVzTWVzc2FnZSA9IHR5cGVkUmVzcG9uc2Uuc3RhdHVzTWVzc2FnZSA/PyBodHRwLlNUQVRVU19DT0RFU1tzdGF0dXNDb2RlXTtcbiAgICAgICAgdHlwZWRSZXNwb25zZS51cmwgPSBvcHRpb25zLnVybC50b1N0cmluZygpO1xuICAgICAgICB0eXBlZFJlc3BvbnNlLnJlcXVlc3RVcmwgPSB0aGlzLnJlcXVlc3RVcmw7XG4gICAgICAgIHR5cGVkUmVzcG9uc2UucmVkaXJlY3RVcmxzID0gdGhpcy5yZWRpcmVjdFVybHM7XG4gICAgICAgIHR5cGVkUmVzcG9uc2UucmVxdWVzdCA9IHRoaXM7XG4gICAgICAgIHR5cGVkUmVzcG9uc2UuaXNGcm9tQ2FjaGUgPSB0aGlzLl9uYXRpdmVSZXNwb25zZS5mcm9tQ2FjaGUgPz8gZmFsc2U7XG4gICAgICAgIHR5cGVkUmVzcG9uc2UuaXAgPSB0aGlzLmlwO1xuICAgICAgICB0eXBlZFJlc3BvbnNlLnJldHJ5Q291bnQgPSB0aGlzLnJldHJ5Q291bnQ7XG4gICAgICAgIHR5cGVkUmVzcG9uc2Uub2sgPSBpc1Jlc3BvbnNlT2sodHlwZWRSZXNwb25zZSk7XG4gICAgICAgIHRoaXMuX2lzRnJvbUNhY2hlID0gdHlwZWRSZXNwb25zZS5pc0Zyb21DYWNoZTtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VTaXplID0gTnVtYmVyKHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHR5cGVkUmVzcG9uc2U7XG4gICAgICAgIHJlc3BvbnNlLm9uY2UoJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlU2l6ZSA9IHRoaXMuX2Rvd25sb2FkZWRTaXplO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkb3dubG9hZFByb2dyZXNzJywgdGhpcy5kb3dubG9hZFByb2dyZXNzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3BvbnNlLm9uY2UoJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIEZvcmNlIGNsZWFuLXVwLCBiZWNhdXNlIHNvbWUgcGFja2FnZXMgZG9uJ3QgZG8gdGhpcy5cbiAgICAgICAgICAgIC8vIFRPRE86IEZpeCBkZWNvbXByZXNzLXJlc3BvbnNlXG4gICAgICAgICAgICByZXNwb25zZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLl9iZWZvcmVFcnJvcihuZXcgUmVhZEVycm9yKGVycm9yLCB0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNwb25zZS5vbmNlKCdhYm9ydGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9iZWZvcmVFcnJvcihuZXcgUmVhZEVycm9yKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnRXJyb3InLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgc2VydmVyIGFib3J0ZWQgcGVuZGluZyByZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRUNPTk5SRVNFVCcsXG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoJ2Rvd25sb2FkUHJvZ3Jlc3MnLCB0aGlzLmRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgICAgICBjb25zdCByYXdDb29raWVzID0gcmVzcG9uc2UuaGVhZGVyc1snc2V0LWNvb2tpZSddO1xuICAgICAgICBpZiAoaXMub2JqZWN0KG9wdGlvbnMuY29va2llSmFyKSAmJiByYXdDb29raWVzKSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZXMgPSByYXdDb29raWVzLm1hcChhc3luYyAocmF3Q29va2llKSA9PiBvcHRpb25zLmNvb2tpZUphci5zZXRDb29raWUocmF3Q29va2llLCB1cmwudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaWdub3JlSW52YWxpZENvb2tpZXMpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcyA9IHByb21pc2VzLm1hcChhc3luYyAocHJvbWlzZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCB7IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVmb3JlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgYWJvdmUgaXMgcnVubmluZyBhIHByb21pc2UsIHRoZXJlZm9yZSB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoaXMgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkIHlldCBhZ2Fpbi5cbiAgICAgICAgaWYgKHRoaXMuaXNBYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZm9sbG93UmVkaXJlY3QgJiYgcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiAmJiByZWRpcmVjdENvZGVzLmhhcyhzdGF0dXNDb2RlKSkge1xuICAgICAgICAgICAgLy8gV2UncmUgYmVpbmcgcmVkaXJlY3RlZCwgd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAvLyBJdCdkIGJlIGJlc3QgdG8gYWJvcnQgdGhlIHJlcXVlc3QsIGJ1dCB3ZSBjYW4ndCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB3ZSB3b3VsZCBoYXZlIHRvIHNhY3JpZmljZSB0aGUgVENQIGNvbm5lY3Rpb24uIFdlIGRvbid0IHdhbnQgdGhhdC5cbiAgICAgICAgICAgIHJlc3BvbnNlLnJlc3VtZSgpO1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsVGltZW91dHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3VucHJveHlFdmVudHMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZGlyZWN0VXJscy5sZW5ndGggPj0gb3B0aW9ucy5tYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVFcnJvcihuZXcgTWF4UmVkaXJlY3RzRXJyb3IodGhpcykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkT3B0aW9ucyA9IG5ldyBPcHRpb25zKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyUmVxdWVzdGVkR2V0ID0gc3RhdHVzQ29kZSA9PT0gMzAzICYmIHVwZGF0ZWRPcHRpb25zLm1ldGhvZCAhPT0gJ0dFVCcgJiYgdXBkYXRlZE9wdGlvbnMubWV0aG9kICE9PSAnSEVBRCc7XG4gICAgICAgICAgICBjb25zdCBjYW5SZXdyaXRlID0gc3RhdHVzQ29kZSAhPT0gMzA3ICYmIHN0YXR1c0NvZGUgIT09IDMwODtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJSZXF1ZXN0ZWRHZXQgPSB1cGRhdGVkT3B0aW9ucy5tZXRob2RSZXdyaXRpbmcgJiYgY2FuUmV3cml0ZTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJSZXF1ZXN0ZWRHZXQgfHwgdXNlclJlcXVlc3RlZEdldCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRPcHRpb25zLm1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRPcHRpb25zLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdXBkYXRlZE9wdGlvbnMuanNvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB1cGRhdGVkT3B0aW9ucy5mb3JtID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB1cGRhdGVkT3B0aW9ucy5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRoaXMgaW4gb3JkZXIgdG8gc3VwcG9ydCBVVEYtOFxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZGlyZWN0QnVmZmVyID0gQnVmZmVyLmZyb20ocmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiwgJ2JpbmFyeScpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RVcmwgPSBuZXcgVVJMKHJlZGlyZWN0QnVmZmVyLCB1cmwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNVbml4U29ja2V0VVJMKHVybCkgJiYgaXNVbml4U29ja2V0VVJMKHJlZGlyZWN0VXJsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVFcnJvcihuZXcgUmVxdWVzdEVycm9yKCdDYW5ub3QgcmVkaXJlY3QgdG8gVU5JWCBzb2NrZXQnLCB7fSwgdGhpcykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlZGlyZWN0aW5nIHRvIGEgZGlmZmVyZW50IHNpdGUsIGNsZWFyIHNlbnNpdGl2ZSBkYXRhLlxuICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdFVybC5ob3N0bmFtZSAhPT0gdXJsLmhvc3RuYW1lIHx8IHJlZGlyZWN0VXJsLnBvcnQgIT09IHVybC5wb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnaG9zdCcgaW4gdXBkYXRlZE9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHVwZGF0ZWRPcHRpb25zLmhlYWRlcnMuaG9zdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ2Nvb2tpZScgaW4gdXBkYXRlZE9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHVwZGF0ZWRPcHRpb25zLmhlYWRlcnMuY29va2llO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgnYXV0aG9yaXphdGlvbicgaW4gdXBkYXRlZE9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHVwZGF0ZWRPcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZE9wdGlvbnMudXNlcm5hbWUgfHwgdXBkYXRlZE9wdGlvbnMucGFzc3dvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRPcHRpb25zLnVzZXJuYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkT3B0aW9ucy5wYXNzd29yZCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFVybC51c2VybmFtZSA9IHVwZGF0ZWRPcHRpb25zLnVzZXJuYW1lO1xuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFVybC5wYXNzd29yZCA9IHVwZGF0ZWRPcHRpb25zLnBhc3N3b3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZGlyZWN0VXJscy5wdXNoKHJlZGlyZWN0VXJsKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkT3B0aW9ucy5wcmVmaXhVcmwgPSAnJztcbiAgICAgICAgICAgICAgICB1cGRhdGVkT3B0aW9ucy51cmwgPSByZWRpcmVjdFVybDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhvb2sgb2YgdXBkYXRlZE9wdGlvbnMuaG9va3MuYmVmb3JlUmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaG9vayh1cGRhdGVkT3B0aW9ucywgdHlwZWRSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVkaXJlY3QnLCB1cGRhdGVkT3B0aW9ucywgdHlwZWRSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gdXBkYXRlZE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbWFrZVJlcXVlc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JlZm9yZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYEhUVFBFcnJvcmBzIGFsd2F5cyBoYXZlIGBlcnJvci5yZXNwb25zZS5ib2R5YCBkZWZpbmVkLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgY2Fubm90IHJldHJ5IGlmIGBvcHRpb25zLnRocm93SHR0cEVycm9yc2AgaXMgZmFsc2UuXG4gICAgICAgIC8vIE9uIHRoZSBsYXN0IHJldHJ5LCBpZiBgb3B0aW9ucy50aHJvd0h0dHBFcnJvcnNgIGlzIGZhbHNlLCB3ZSB3b3VsZCBuZWVkIHRvIHJldHVybiB0aGUgYm9keSxcbiAgICAgICAgLy8gYnV0IHRoYXQgd291bGRuJ3QgYmUgcG9zc2libGUgc2luY2UgdGhlIGJvZHkgd291bGQgYmUgYWxyZWFkeSByZWFkIGluIGBlcnJvci5yZXNwb25zZS5ib2R5YC5cbiAgICAgICAgaWYgKG9wdGlvbnMuaXNTdHJlYW0gJiYgb3B0aW9ucy50aHJvd0h0dHBFcnJvcnMgJiYgIWlzUmVzcG9uc2VPayh0eXBlZFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgdGhpcy5fYmVmb3JlRXJyb3IobmV3IEhUVFBFcnJvcih0eXBlZFJlc3BvbnNlKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uc2Uub24oJ3JlYWRhYmxlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJSZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbigncmVzdW1lJywgKCkgPT4ge1xuICAgICAgICAgICAgcmVzcG9uc2UucmVzdW1lKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCdwYXVzZScsICgpID0+IHtcbiAgICAgICAgICAgIHJlc3BvbnNlLnBhdXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNwb25zZS5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnB1c2gobnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fbm9QaXBlKSB7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5fc2V0UmF3Qm9keSgpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3Jlc3BvbnNlJywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgncmVzcG9uc2UnLCByZXNwb25zZSk7XG4gICAgICAgIGZvciAoY29uc3QgZGVzdGluYXRpb24gb2YgdGhpcy5fcGlwZWRTZXJ2ZXJSZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5oZWFkZXJzU2VudCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQWxsb3dlZCA9IG9wdGlvbnMuZGVjb21wcmVzcyA/IGtleSAhPT0gJ2NvbnRlbnQtZW5jb2RpbmcnIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3BvbnNlLmhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnNldEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfc2V0UmF3Qm9keShmcm9tID0gdGhpcykge1xuICAgICAgICBpZiAoZnJvbS5yZWFkYWJsZUVuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEVycm9ycyBhcmUgZW1pdHRlZCB2aWEgdGhlIGBlcnJvcmAgZXZlbnRcbiAgICAgICAgICAgIGNvbnN0IHJhd0JvZHkgPSBhd2FpdCBnZXRCdWZmZXIoZnJvbSk7XG4gICAgICAgICAgICAvLyBPbiByZXRyeSBSZXF1ZXN0IGlzIGRlc3Ryb3llZCB3aXRoIG5vIGVycm9yLCB0aGVyZWZvcmUgdGhlIGFib3ZlIHdpbGwgc3VjY2Vzc2Z1bGx5IHJlc29sdmUuXG4gICAgICAgICAgICAvLyBTbyBpbiBvcmRlciB0byBjaGVjayBpZiB0aGlzIHdhcyByZWFsbHkgc3VjY2Vzc2Z1bGwsIHdlIG5lZWQgdG8gY2hlY2sgaWYgaXQgaGFzIGJlZW4gcHJvcGVybHkgZW5kZWQuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZS5yYXdCb2R5ID0gcmF3Qm9keTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7IH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBfb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fb25SZXNwb25zZUJhc2UocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGJldHRlciBzYWZlIHRoYW4gc29ycnkgKi9cbiAgICAgICAgICAgIHRoaXMuX2JlZm9yZUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb25SZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHVybCB9ID0gb3B0aW9ucztcbiAgICAgICAgdGltZXIocmVxdWVzdCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaHR0cDIpIHtcbiAgICAgICAgICAgIC8vIFVuc2V0IHN0cmVhbSB0aW1lb3V0LCBhcyB0aGUgYHRpbWVvdXRgIG9wdGlvbiB3YXMgdXNlZCBvbmx5IGZvciBjb25uZWN0aW9uIHRpbWVvdXQuXG4gICAgICAgICAgICByZXF1ZXN0LnNldFRpbWVvdXQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FuY2VsVGltZW91dHMgPSB0aW1lZE91dChyZXF1ZXN0LCB0aW1lb3V0LCB1cmwpO1xuICAgICAgICBjb25zdCByZXNwb25zZUV2ZW50TmFtZSA9IG9wdGlvbnMuY2FjaGUgPyAnY2FjaGVhYmxlUmVzcG9uc2UnIDogJ3Jlc3BvbnNlJztcbiAgICAgICAgcmVxdWVzdC5vbmNlKHJlc3BvbnNlRXZlbnROYW1lLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fb25SZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0Lm9uY2UoJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIEZvcmNlIGNsZWFuLXVwLCBiZWNhdXNlIHNvbWUgcGFja2FnZXMgKGUuZy4gbm9jaykgZG9uJ3QgZG8gdGhpcy5cbiAgICAgICAgICAgIHJlcXVlc3QuZGVzdHJveSgpO1xuICAgICAgICAgICAgZXJyb3IgPSBlcnJvciBpbnN0YW5jZW9mIFRpbWVkT3V0VGltZW91dEVycm9yID8gbmV3IFRpbWVvdXRFcnJvcihlcnJvciwgdGhpcy50aW1pbmdzLCB0aGlzKSA6IG5ldyBSZXF1ZXN0RXJyb3IoZXJyb3IubWVzc2FnZSwgZXJyb3IsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fYmVmb3JlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdW5wcm94eUV2ZW50cyA9IHByb3h5RXZlbnRzKHJlcXVlc3QsIHRoaXMsIHByb3hpZWRSZXF1ZXN0RXZlbnRzKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuZW1pdCgndXBsb2FkUHJvZ3Jlc3MnLCB0aGlzLnVwbG9hZFByb2dyZXNzKTtcbiAgICAgICAgdGhpcy5fc2VuZEJvZHkoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgcmVxdWVzdCk7XG4gICAgfVxuICAgIGFzeW5jIF9hc3luY1dyaXRlKGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzdXBlci53cml0ZShjaHVuaywgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3NlbmRCb2R5KCkge1xuICAgICAgICAvLyBTZW5kIGJvZHlcbiAgICAgICAgY29uc3QgeyBib2R5IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSZXF1ZXN0ID0gdGhpcy5yZWRpcmVjdFVybHMubGVuZ3RoID09PSAwID8gdGhpcyA6IHRoaXMuX3JlcXVlc3QgPz8gdGhpcztcbiAgICAgICAgaWYgKGlzLm5vZGVTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgICAgIGJvZHkucGlwZShjdXJyZW50UmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXMuZ2VuZXJhdG9yKGJvZHkpIHx8IGlzLmFzeW5jR2VuZXJhdG9yKGJvZHkpKSB7XG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fYXN5bmNXcml0ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXMudW5kZWZpbmVkKGJvZHkpKSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZVJlcXVlc3QoYm9keSwgdW5kZWZpbmVkLCAoKSA9PiB7IH0pO1xuICAgICAgICAgICAgY3VycmVudFJlcXVlc3QuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fY2Fubm90SGF2ZUJvZHkgfHwgdGhpcy5fbm9QaXBlKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVxdWVzdC5lbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJlcGFyZUNhY2hlKGNhY2hlKSB7XG4gICAgICAgIGlmICghY2FjaGVhYmxlU3RvcmUuaGFzKGNhY2hlKSkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVhYmxlUmVxdWVzdCA9IG5ldyBDYWNoZWFibGVSZXF1ZXN0KCgocmVxdWVzdE9wdGlvbnMsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXF1ZXN0T3B0aW9ucy5fcmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgd2hlbiBgY2FjaGVhYmxlLXJlcXVlc3RgIHN1cHBvcnRzIGFzeW5jIHJlcXVlc3QgZnVuY3Rpb25zLlxuICAgICAgICAgICAgICAgIGlmIChpcy5wcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIGltcGxlbWVudCB0aGUgZXJyb3IgaGFuZGxlciBpbiBvcmRlciB0byBzdXBwb3J0IEhUVFAyIGNhY2hpbmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgd2lsbCBiZSBhIHByb21pc2UgYW55d2F5LlxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmNcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm9uY2UgPSAoZXZlbnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudCA9PT0gJ2Fib3J0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbXB0eSBjYXRjaCBpcyBuZWVkZWQgaGVyZSBpbiBjYXNlIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCByZWplY3RzIGJlZm9yZSBpdCdzIGBhd2FpdGBlZCBpbiBgX21ha2VSZXF1ZXN0YC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IChhd2FpdCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5vbmNlKCdhYm9ydCcsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIHsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FmZXR5IGNoZWNrICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIEhUVFAyIHByb21pc2UgZXZlbnQ6ICR7ZXZlbnR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSksIGNhY2hlKTtcbiAgICAgICAgICAgIGNhY2hlYWJsZVN0b3JlLnNldChjYWNoZSwgY2FjaGVhYmxlUmVxdWVzdC5yZXF1ZXN0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVDYWNoZWFibGVSZXF1ZXN0KHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIGB1dGlscy91cmwtdG8tb3B0aW9ucy50c2Agd2hlbiBgY2FjaGVhYmxlLXJlcXVlc3RgIGlzIGZpeGVkXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHVybFRvT3B0aW9ucyh1cmwpKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0O1xuICAgICAgICAgICAgLy8gVE9ETzogRml4IGBjYWNoZWFibGUtcmVzcG9uc2VgLiBUaGlzIGlzIHVnbHkuXG4gICAgICAgICAgICBjb25zdCBjYWNoZVJlcXVlc3QgPSBjYWNoZWFibGVTdG9yZS5nZXQob3B0aW9ucy5jYWNoZSkob3B0aW9ucywgYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuX3JlYWRhYmxlU3RhdGUuYXV0b0Rlc3Ryb3kgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UucmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuY29tcGxldGUgPSByZXNwb25zZS5yZXEucmVzLmNvbXBsZXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5wcmVwZW5kT25jZUxpc3RlbmVyKCdlbmQnLCBmaXgpO1xuICAgICAgICAgICAgICAgICAgICBmaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgKGF3YWl0IHJlcXVlc3QpLmVtaXQoJ2NhY2hlYWJsZVJlc3BvbnNlJywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FjaGVSZXF1ZXN0Lm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICAgIGNhY2hlUmVxdWVzdC5vbmNlKCdyZXF1ZXN0JywgYXN5bmMgKHJlcXVlc3RPclByb21pc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdE9yUHJvbWlzZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfbWFrZVJlcXVlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBoZWFkZXJzLCB1c2VybmFtZSwgcGFzc3dvcmQgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGNvb2tpZUphciA9IG9wdGlvbnMuY29va2llSmFyO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXMudW5kZWZpbmVkKGhlYWRlcnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzLm51bGxfKGhlYWRlcnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVc2UgXFxgdW5kZWZpbmVkXFxgIGluc3RlYWQgb2YgXFxgbnVsbFxcYCB0byBkZWxldGUgdGhlIFxcYCR7a2V5fVxcYCBoZWFkZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kZWNvbXByZXNzICYmIGlzLnVuZGVmaW5lZChoZWFkZXJzWydhY2NlcHQtZW5jb2RpbmcnXSkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ2FjY2VwdC1lbmNvZGluZyddID0gc3VwcG9ydHNCcm90bGkgPyAnZ3ppcCwgZGVmbGF0ZSwgYnInIDogJ2d6aXAsIGRlZmxhdGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VybmFtZSB8fCBwYXNzd29yZCkge1xuICAgICAgICAgICAgY29uc3QgY3JlZGVudGlhbHMgPSBCdWZmZXIuZnJvbShgJHt1c2VybmFtZX06JHtwYXNzd29yZH1gKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICBoZWFkZXJzLmF1dGhvcml6YXRpb24gPSBgQmFzaWMgJHtjcmVkZW50aWFsc31gO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBjb29raWVzXG4gICAgICAgIGlmIChjb29raWVKYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvb2tpZVN0cmluZyA9IGF3YWl0IGNvb2tpZUphci5nZXRDb29raWVTdHJpbmcob3B0aW9ucy51cmwudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBpZiAoaXMubm9uRW1wdHlTdHJpbmcoY29va2llU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuY29va2llID0gY29va2llU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IGBwcmVmaXhVcmxgXG4gICAgICAgIG9wdGlvbnMucHJlZml4VXJsID0gJyc7XG4gICAgICAgIGxldCByZXF1ZXN0O1xuICAgICAgICBmb3IgKGNvbnN0IGhvb2sgb2Ygb3B0aW9ucy5ob29rcy5iZWZvcmVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaG9vayhvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICghaXMudW5kZWZpbmVkKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFNraXAgdGhlIHR5cGUgbWlzbWF0Y2ggdG8gc3VwcG9ydCBhYnN0cmFjdCByZXNwb25zZXNcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gKCkgPT4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgcmVxdWVzdCA9IG9wdGlvbnMuZ2V0UmVxdWVzdEZ1bmN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gb3B0aW9ucy51cmw7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RPcHRpb25zID0gb3B0aW9ucy5jcmVhdGVOYXRpdmVSZXF1ZXN0T3B0aW9ucygpO1xuICAgICAgICBpZiAob3B0aW9ucy5jYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdE9wdGlvbnMuX3JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdE9wdGlvbnMuY2FjaGUgPSBvcHRpb25zLmNhY2hlO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdE9wdGlvbnMuYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVDYWNoZShvcHRpb25zLmNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWNoZSBzdXBwb3J0XG4gICAgICAgIGNvbnN0IGZuID0gb3B0aW9ucy5jYWNoZSA/IHRoaXMuX2NyZWF0ZUNhY2hlYWJsZVJlcXVlc3QgOiByZXF1ZXN0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZG8gYGF3YWl0IGZuKC4uLilgLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBzdHJlYW0gYGVycm9yYCBldmVudCBjYW4gYmUgZW1pdHRlZCBiZWZvcmUgYFByb21pc2UucmVzb2x2ZSgpYC5cbiAgICAgICAgICAgIGxldCByZXF1ZXN0T3JSZXNwb25zZSA9IGZuKHVybCwgdGhpcy5fcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGlzLnByb21pc2UocmVxdWVzdE9yUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9yUmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0T3JSZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpZiAoaXMudW5kZWZpbmVkKHJlcXVlc3RPclJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPclJlc3BvbnNlID0gb3B0aW9ucy5nZXRGYWxsYmFja1JlcXVlc3RGdW5jdGlvbigpKHVybCwgdGhpcy5fcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChpcy5wcm9taXNlKHJlcXVlc3RPclJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0T3JSZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RPclJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NsaWVudFJlcXVlc3QocmVxdWVzdE9yUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25SZXF1ZXN0KHJlcXVlc3RPclJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLl9vblJlc3BvbnNlKHJlcXVlc3RPclJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kQm9keSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLl9vblJlc3BvbnNlKHJlcXVlc3RPclJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENhY2hlYWJsZUNhY2hlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2FjaGVFcnJvcihlcnJvciwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEhUVFBFcnJvciAmJiAhdGhpcy5vcHRpb25zLnRocm93SHR0cEVycm9ycykge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgYnJhbmNoIGNhbiBiZSByZWFjaGVkIG9ubHkgd2hlbiB1c2luZyB0aGUgUHJvbWlzZSBBUElcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGNhbGxpbmcgdGhlIGhvb2tzIG9uIHB1cnBvc2UuXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZ290L2lzc3Vlcy8yMTAzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhvb2sgb2YgdGhpcy5vcHRpb25zLmhvb2tzLmJlZm9yZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gYXdhaXQgaG9vayhlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcl8pIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFJlcXVlc3RFcnJvcihlcnJvcl8ubWVzc2FnZSwgZXJyb3JfLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3Ryb3koZXJyb3IpO1xuICAgIH1cbiAgICBfd3JpdGVSZXF1ZXN0KGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0IHx8IHRoaXMuX3JlcXVlc3QuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAvLyBQcm9iYWJseSB0aGUgYENsaWVudFJlcXVlc3RgIGluc3RhbmNlIHdpbGwgdGhyb3dcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXF1ZXN0LndyaXRlKGNodW5rLCBlbmNvZGluZywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBUaGUgYCFkZXN0cm95ZWRgIGNoZWNrIGlzIHJlcXVpcmVkIHRvIHByZXZlbnQgYHVwbG9hZFByb2dyZXNzYCBiZWluZyBlbWl0dGVkIGFmdGVyIHRoZSBzdHJlYW0gd2FzIGRlc3Ryb3llZFxuICAgICAgICAgICAgaWYgKCFlcnJvciAmJiAhdGhpcy5fcmVxdWVzdC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWRlZFNpemUgKz0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IHRoaXMudXBsb2FkUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzLnBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndXBsb2FkUHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHJlbW90ZSBJUCBhZGRyZXNzLlxuICAgICovXG4gICAgZ2V0IGlwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXQ/LnJlbW90ZUFkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQgb3Igbm90LlxuICAgICovXG4gICAgZ2V0IGlzQWJvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fib3J0ZWQ7XG4gICAgfVxuICAgIGdldCBzb2NrZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0Py5zb2NrZXQgPz8gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBQcm9ncmVzcyBldmVudCBmb3IgZG93bmxvYWRpbmcgKHJlY2VpdmluZyBhIHJlc3BvbnNlKS5cbiAgICAqL1xuICAgIGdldCBkb3dubG9hZFByb2dyZXNzKCkge1xuICAgICAgICBsZXQgcGVyY2VudDtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc3BvbnNlU2l6ZSkge1xuICAgICAgICAgICAgcGVyY2VudCA9IHRoaXMuX2Rvd25sb2FkZWRTaXplIC8gdGhpcy5fcmVzcG9uc2VTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Jlc3BvbnNlU2l6ZSA9PT0gdGhpcy5fZG93bmxvYWRlZFNpemUpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBlcmNlbnQsXG4gICAgICAgICAgICB0cmFuc2ZlcnJlZDogdGhpcy5fZG93bmxvYWRlZFNpemUsXG4gICAgICAgICAgICB0b3RhbDogdGhpcy5fcmVzcG9uc2VTaXplLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBQcm9ncmVzcyBldmVudCBmb3IgdXBsb2FkaW5nIChzZW5kaW5nIGEgcmVxdWVzdCkuXG4gICAgKi9cbiAgICBnZXQgdXBsb2FkUHJvZ3Jlc3MoKSB7XG4gICAgICAgIGxldCBwZXJjZW50O1xuICAgICAgICBpZiAodGhpcy5fYm9keVNpemUpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSB0aGlzLl91cGxvYWRlZFNpemUgLyB0aGlzLl9ib2R5U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9ib2R5U2l6ZSA9PT0gdGhpcy5fdXBsb2FkZWRTaXplKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwZXJjZW50LFxuICAgICAgICAgICAgdHJhbnNmZXJyZWQ6IHRoaXMuX3VwbG9hZGVkU2l6ZSxcbiAgICAgICAgICAgIHRvdGFsOiB0aGlzLl9ib2R5U2l6ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG9iamVjdCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cbiAgICAtIGBzdGFydGAgLSBUaW1lIHdoZW4gdGhlIHJlcXVlc3Qgc3RhcnRlZC5cbiAgICAtIGBzb2NrZXRgIC0gVGltZSB3aGVuIGEgc29ja2V0IHdhcyBhc3NpZ25lZCB0byB0aGUgcmVxdWVzdC5cbiAgICAtIGBsb29rdXBgIC0gVGltZSB3aGVuIHRoZSBETlMgbG9va3VwIGZpbmlzaGVkLlxuICAgIC0gYGNvbm5lY3RgIC0gVGltZSB3aGVuIHRoZSBzb2NrZXQgc3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZC5cbiAgICAtIGBzZWN1cmVDb25uZWN0YCAtIFRpbWUgd2hlbiB0aGUgc29ja2V0IHNlY3VyZWx5IGNvbm5lY3RlZC5cbiAgICAtIGB1cGxvYWRgIC0gVGltZSB3aGVuIHRoZSByZXF1ZXN0IGZpbmlzaGVkIHVwbG9hZGluZy5cbiAgICAtIGByZXNwb25zZWAgLSBUaW1lIHdoZW4gdGhlIHJlcXVlc3QgZmlyZWQgYHJlc3BvbnNlYCBldmVudC5cbiAgICAtIGBlbmRgIC0gVGltZSB3aGVuIHRoZSByZXNwb25zZSBmaXJlZCBgZW5kYCBldmVudC5cbiAgICAtIGBlcnJvcmAgLSBUaW1lIHdoZW4gdGhlIHJlcXVlc3QgZmlyZWQgYGVycm9yYCBldmVudC5cbiAgICAtIGBhYm9ydGAgLSBUaW1lIHdoZW4gdGhlIHJlcXVlc3QgZmlyZWQgYGFib3J0YCBldmVudC5cbiAgICAtIGBwaGFzZXNgXG4gICAgICAgIC0gYHdhaXRgIC0gYHRpbWluZ3Muc29ja2V0IC0gdGltaW5ncy5zdGFydGBcbiAgICAgICAgLSBgZG5zYCAtIGB0aW1pbmdzLmxvb2t1cCAtIHRpbWluZ3Muc29ja2V0YFxuICAgICAgICAtIGB0Y3BgIC0gYHRpbWluZ3MuY29ubmVjdCAtIHRpbWluZ3MubG9va3VwYFxuICAgICAgICAtIGB0bHNgIC0gYHRpbWluZ3Muc2VjdXJlQ29ubmVjdCAtIHRpbWluZ3MuY29ubmVjdGBcbiAgICAgICAgLSBgcmVxdWVzdGAgLSBgdGltaW5ncy51cGxvYWQgLSAodGltaW5ncy5zZWN1cmVDb25uZWN0IHx8IHRpbWluZ3MuY29ubmVjdClgXG4gICAgICAgIC0gYGZpcnN0Qnl0ZWAgLSBgdGltaW5ncy5yZXNwb25zZSAtIHRpbWluZ3MudXBsb2FkYFxuICAgICAgICAtIGBkb3dubG9hZGAgLSBgdGltaW5ncy5lbmQgLSB0aW1pbmdzLnJlc3BvbnNlYFxuICAgICAgICAtIGB0b3RhbGAgLSBgKHRpbWluZ3MuZW5kIHx8IHRpbWluZ3MuZXJyb3IgfHwgdGltaW5ncy5hYm9ydCkgLSB0aW1pbmdzLnN0YXJ0YFxuXG4gICAgSWYgc29tZXRoaW5nIGhhcyBub3QgYmVlbiBtZWFzdXJlZCB5ZXQsIGl0IHdpbGwgYmUgYHVuZGVmaW5lZGAuXG5cbiAgICBfX05vdGVfXzogVGhlIHRpbWUgaXMgYSBgbnVtYmVyYCByZXByZXNlbnRpbmcgdGhlIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHNpbmNlIHRoZSBVTklYIGVwb2NoLlxuICAgICovXG4gICAgZ2V0IHRpbWluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0Py50aW1pbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSByZXNwb25zZSB3YXMgcmV0cmlldmVkIGZyb20gdGhlIGNhY2hlLlxuICAgICovXG4gICAgZ2V0IGlzRnJvbUNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNGcm9tQ2FjaGU7XG4gICAgfVxuICAgIGdldCByZXVzZWRTb2NrZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0Py5yZXVzZWRTb2NrZXQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHByb2Nlc3MgZnJvbSAnbm9kZTpwcm9jZXNzJztcbmltcG9ydCB7IHByb21pc2lmeSwgaW5zcGVjdCB9IGZyb20gJ25vZGU6dXRpbCc7XG5pbXBvcnQgeyBVUkwsIFVSTFNlYXJjaFBhcmFtcyB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IGNoZWNrU2VydmVySWRlbnRpdHkgfSBmcm9tICdub2RlOnRscyc7XG4vLyBETyBOT1QgdXNlIGRlc3RydWN0dXJpbmcgZm9yIGBodHRwcy5yZXF1ZXN0YCBhbmQgYGh0dHAucmVxdWVzdGAgYXMgaXQncyBub3QgY29tcGF0aWJsZSB3aXRoIGBub2NrYC5cbmltcG9ydCBodHRwIGZyb20gJ25vZGU6aHR0cCc7XG5pbXBvcnQgaHR0cHMgZnJvbSAnbm9kZTpodHRwcyc7XG5pbXBvcnQgaXMsIHsgYXNzZXJ0IH0gZnJvbSAnQHNpbmRyZXNvcmh1cy9pcyc7XG5pbXBvcnQgbG93ZXJjYXNlS2V5cyBmcm9tICdsb3dlcmNhc2Uta2V5cyc7XG5pbXBvcnQgQ2FjaGVhYmxlTG9va3VwIGZyb20gJ2NhY2hlYWJsZS1sb29rdXAnO1xuaW1wb3J0IGh0dHAyd3JhcHBlciBmcm9tICdodHRwMi13cmFwcGVyJztcbmltcG9ydCB7IGlzRm9ybURhdGEgfSBmcm9tICdmb3JtLWRhdGEtZW5jb2Rlcic7XG5pbXBvcnQgcGFyc2VMaW5rSGVhZGVyIGZyb20gJy4vcGFyc2UtbGluay1oZWFkZXIuanMnO1xuY29uc3QgW21ham9yLCBtaW5vcl0gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKS5tYXAoTnVtYmVyKTtcbmZ1bmN0aW9uIHZhbGlkYXRlU2VhcmNoUGFyYW1ldGVycyhzZWFyY2hQYXJhbWV0ZXJzKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAoY29uc3Qga2V5IGluIHNlYXJjaFBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzZWFyY2hQYXJhbWV0ZXJzW2tleV07XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLnN0cmluZywgaXMubnVtYmVyLCBpcy5ib29sZWFuLCBpcy5udWxsXywgaXMudW5kZWZpbmVkXSwgdmFsdWUpO1xuICAgIH1cbn1cbmNvbnN0IGdsb2JhbENhY2hlID0gbmV3IE1hcCgpO1xubGV0IGdsb2JhbERuc0NhY2hlO1xuY29uc3QgZ2V0R2xvYmFsRG5zQ2FjaGUgPSAoKSA9PiB7XG4gICAgaWYgKGdsb2JhbERuc0NhY2hlKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxEbnNDYWNoZTtcbiAgICB9XG4gICAgZ2xvYmFsRG5zQ2FjaGUgPSBuZXcgQ2FjaGVhYmxlTG9va3VwKCk7XG4gICAgcmV0dXJuIGdsb2JhbERuc0NhY2hlO1xufTtcbmNvbnN0IGRlZmF1bHRJbnRlcm5hbHMgPSB7XG4gICAgcmVxdWVzdDogdW5kZWZpbmVkLFxuICAgIGFnZW50OiB7XG4gICAgICAgIGh0dHA6IHVuZGVmaW5lZCxcbiAgICAgICAgaHR0cHM6IHVuZGVmaW5lZCxcbiAgICAgICAgaHR0cDI6IHVuZGVmaW5lZCxcbiAgICB9LFxuICAgIGgyc2Vzc2lvbjogdW5kZWZpbmVkLFxuICAgIGRlY29tcHJlc3M6IHRydWUsXG4gICAgdGltZW91dDoge1xuICAgICAgICBjb25uZWN0OiB1bmRlZmluZWQsXG4gICAgICAgIGxvb2t1cDogdW5kZWZpbmVkLFxuICAgICAgICByZWFkOiB1bmRlZmluZWQsXG4gICAgICAgIHJlcXVlc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVzcG9uc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VjdXJlQ29ubmVjdDogdW5kZWZpbmVkLFxuICAgICAgICBzZW5kOiB1bmRlZmluZWQsXG4gICAgICAgIHNvY2tldDogdW5kZWZpbmVkLFxuICAgIH0sXG4gICAgcHJlZml4VXJsOiAnJyxcbiAgICBib2R5OiB1bmRlZmluZWQsXG4gICAgZm9ybTogdW5kZWZpbmVkLFxuICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICBjb29raWVKYXI6IHVuZGVmaW5lZCxcbiAgICBpZ25vcmVJbnZhbGlkQ29va2llczogZmFsc2UsXG4gICAgc2VhcmNoUGFyYW1zOiB1bmRlZmluZWQsXG4gICAgZG5zTG9va3VwOiB1bmRlZmluZWQsXG4gICAgZG5zQ2FjaGU6IHVuZGVmaW5lZCxcbiAgICBjb250ZXh0OiB7fSxcbiAgICBob29rczoge1xuICAgICAgICBpbml0OiBbXSxcbiAgICAgICAgYmVmb3JlUmVxdWVzdDogW10sXG4gICAgICAgIGJlZm9yZUVycm9yOiBbXSxcbiAgICAgICAgYmVmb3JlUmVkaXJlY3Q6IFtdLFxuICAgICAgICBiZWZvcmVSZXRyeTogW10sXG4gICAgICAgIGFmdGVyUmVzcG9uc2U6IFtdLFxuICAgIH0sXG4gICAgZm9sbG93UmVkaXJlY3Q6IHRydWUsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICBjYWNoZTogdW5kZWZpbmVkLFxuICAgIHRocm93SHR0cEVycm9yczogdHJ1ZSxcbiAgICB1c2VybmFtZTogJycsXG4gICAgcGFzc3dvcmQ6ICcnLFxuICAgIGh0dHAyOiBmYWxzZSxcbiAgICBhbGxvd0dldEJvZHk6IGZhbHNlLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ3VzZXItYWdlbnQnOiAnZ290IChodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2dvdCknLFxuICAgIH0sXG4gICAgbWV0aG9kUmV3cml0aW5nOiBmYWxzZSxcbiAgICBkbnNMb29rdXBJcFZlcnNpb246IHVuZGVmaW5lZCxcbiAgICBwYXJzZUpzb246IEpTT04ucGFyc2UsXG4gICAgc3RyaW5naWZ5SnNvbjogSlNPTi5zdHJpbmdpZnksXG4gICAgcmV0cnk6IHtcbiAgICAgICAgbGltaXQ6IDIsXG4gICAgICAgIG1ldGhvZHM6IFtcbiAgICAgICAgICAgICdHRVQnLFxuICAgICAgICAgICAgJ1BVVCcsXG4gICAgICAgICAgICAnSEVBRCcsXG4gICAgICAgICAgICAnREVMRVRFJyxcbiAgICAgICAgICAgICdPUFRJT05TJyxcbiAgICAgICAgICAgICdUUkFDRScsXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXR1c0NvZGVzOiBbXG4gICAgICAgICAgICA0MDgsXG4gICAgICAgICAgICA0MTMsXG4gICAgICAgICAgICA0MjksXG4gICAgICAgICAgICA1MDAsXG4gICAgICAgICAgICA1MDIsXG4gICAgICAgICAgICA1MDMsXG4gICAgICAgICAgICA1MDQsXG4gICAgICAgICAgICA1MjEsXG4gICAgICAgICAgICA1MjIsXG4gICAgICAgICAgICA1MjQsXG4gICAgICAgIF0sXG4gICAgICAgIGVycm9yQ29kZXM6IFtcbiAgICAgICAgICAgICdFVElNRURPVVQnLFxuICAgICAgICAgICAgJ0VDT05OUkVTRVQnLFxuICAgICAgICAgICAgJ0VBRERSSU5VU0UnLFxuICAgICAgICAgICAgJ0VDT05OUkVGVVNFRCcsXG4gICAgICAgICAgICAnRVBJUEUnLFxuICAgICAgICAgICAgJ0VOT1RGT1VORCcsXG4gICAgICAgICAgICAnRU5FVFVOUkVBQ0gnLFxuICAgICAgICAgICAgJ0VBSV9BR0FJTicsXG4gICAgICAgIF0sXG4gICAgICAgIG1heFJldHJ5QWZ0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgY2FsY3VsYXRlRGVsYXk6ICh7IGNvbXB1dGVkVmFsdWUgfSkgPT4gY29tcHV0ZWRWYWx1ZSxcbiAgICAgICAgYmFja29mZkxpbWl0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgIG5vaXNlOiAxMDAsXG4gICAgfSxcbiAgICBsb2NhbEFkZHJlc3M6IHVuZGVmaW5lZCxcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIGNyZWF0ZUNvbm5lY3Rpb246IHVuZGVmaW5lZCxcbiAgICBjYWNoZU9wdGlvbnM6IHtcbiAgICAgICAgc2hhcmVkOiB1bmRlZmluZWQsXG4gICAgICAgIGNhY2hlSGV1cmlzdGljOiB1bmRlZmluZWQsXG4gICAgICAgIGltbXV0YWJsZU1pblRpbWVUb0xpdmU6IHVuZGVmaW5lZCxcbiAgICAgICAgaWdub3JlQ2FyZ29DdWx0OiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICBodHRwczoge1xuICAgICAgICBhbHBuUHJvdG9jb2xzOiB1bmRlZmluZWQsXG4gICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogdW5kZWZpbmVkLFxuICAgICAgICBjaGVja1NlcnZlcklkZW50aXR5OiB1bmRlZmluZWQsXG4gICAgICAgIGNlcnRpZmljYXRlQXV0aG9yaXR5OiB1bmRlZmluZWQsXG4gICAgICAgIGtleTogdW5kZWZpbmVkLFxuICAgICAgICBjZXJ0aWZpY2F0ZTogdW5kZWZpbmVkLFxuICAgICAgICBwYXNzcGhyYXNlOiB1bmRlZmluZWQsXG4gICAgICAgIHBmeDogdW5kZWZpbmVkLFxuICAgICAgICBjaXBoZXJzOiB1bmRlZmluZWQsXG4gICAgICAgIGhvbm9yQ2lwaGVyT3JkZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgbWluVmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICBtYXhWZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgIHNpZ25hdHVyZUFsZ29yaXRobXM6IHVuZGVmaW5lZCxcbiAgICAgICAgdGxzU2Vzc2lvbkxpZmV0aW1lOiB1bmRlZmluZWQsXG4gICAgICAgIGRocGFyYW06IHVuZGVmaW5lZCxcbiAgICAgICAgZWNkaEN1cnZlOiB1bmRlZmluZWQsXG4gICAgICAgIGNlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3RzOiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICBlbmNvZGluZzogdW5kZWZpbmVkLFxuICAgIHJlc29sdmVCb2R5T25seTogZmFsc2UsXG4gICAgaXNTdHJlYW06IGZhbHNlLFxuICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgIHVybDogdW5kZWZpbmVkLFxuICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgdHJhbnNmb3JtKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UucmVxdWVzdC5vcHRpb25zLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFnaW5hdGUoeyByZXNwb25zZSB9KSB7XG4gICAgICAgICAgICBjb25zdCByYXdMaW5rSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5saW5rO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByYXdMaW5rSGVhZGVyICE9PSAnc3RyaW5nJyB8fCByYXdMaW5rSGVhZGVyLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUxpbmtIZWFkZXIocmF3TGlua0hlYWRlcik7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gcGFyc2VkLmZpbmQoZW50cnkgPT4gZW50cnkucGFyYW1ldGVycy5yZWwgPT09ICduZXh0JyB8fCBlbnRyeS5wYXJhbWV0ZXJzLnJlbCA9PT0gJ1wibmV4dFwiJyk7XG4gICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogbmV3IFVSTChuZXh0LnJlZmVyZW5jZSwgcmVzcG9uc2UudXJsKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXI6ICgpID0+IHRydWUsXG4gICAgICAgIHNob3VsZENvbnRpbnVlOiAoKSA9PiB0cnVlLFxuICAgICAgICBjb3VudExpbWl0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgIGJhY2tvZmY6IDAsXG4gICAgICAgIHJlcXVlc3RMaW1pdDogMTAwMDAsXG4gICAgICAgIHN0YWNrQWxsSXRlbXM6IGZhbHNlLFxuICAgIH0sXG4gICAgc2V0SG9zdDogdHJ1ZSxcbiAgICBtYXhIZWFkZXJTaXplOiB1bmRlZmluZWQsXG4gICAgc2lnbmFsOiB1bmRlZmluZWQsXG4gICAgZW5hYmxlVW5peFNvY2tldHM6IHRydWUsXG59O1xuY29uc3QgY2xvbmVJbnRlcm5hbHMgPSAoaW50ZXJuYWxzKSA9PiB7XG4gICAgY29uc3QgeyBob29rcywgcmV0cnkgfSA9IGludGVybmFscztcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIC4uLmludGVybmFscyxcbiAgICAgICAgY29udGV4dDogeyAuLi5pbnRlcm5hbHMuY29udGV4dCB9LFxuICAgICAgICBjYWNoZU9wdGlvbnM6IHsgLi4uaW50ZXJuYWxzLmNhY2hlT3B0aW9ucyB9LFxuICAgICAgICBodHRwczogeyAuLi5pbnRlcm5hbHMuaHR0cHMgfSxcbiAgICAgICAgYWdlbnQ6IHsgLi4uaW50ZXJuYWxzLmFnZW50IH0sXG4gICAgICAgIGhlYWRlcnM6IHsgLi4uaW50ZXJuYWxzLmhlYWRlcnMgfSxcbiAgICAgICAgcmV0cnk6IHtcbiAgICAgICAgICAgIC4uLnJldHJ5LFxuICAgICAgICAgICAgZXJyb3JDb2RlczogWy4uLnJldHJ5LmVycm9yQ29kZXNdLFxuICAgICAgICAgICAgbWV0aG9kczogWy4uLnJldHJ5Lm1ldGhvZHNdLFxuICAgICAgICAgICAgc3RhdHVzQ29kZXM6IFsuLi5yZXRyeS5zdGF0dXNDb2Rlc10sXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVvdXQ6IHsgLi4uaW50ZXJuYWxzLnRpbWVvdXQgfSxcbiAgICAgICAgaG9va3M6IHtcbiAgICAgICAgICAgIGluaXQ6IFsuLi5ob29rcy5pbml0XSxcbiAgICAgICAgICAgIGJlZm9yZVJlcXVlc3Q6IFsuLi5ob29rcy5iZWZvcmVSZXF1ZXN0XSxcbiAgICAgICAgICAgIGJlZm9yZUVycm9yOiBbLi4uaG9va3MuYmVmb3JlRXJyb3JdLFxuICAgICAgICAgICAgYmVmb3JlUmVkaXJlY3Q6IFsuLi5ob29rcy5iZWZvcmVSZWRpcmVjdF0sXG4gICAgICAgICAgICBiZWZvcmVSZXRyeTogWy4uLmhvb2tzLmJlZm9yZVJldHJ5XSxcbiAgICAgICAgICAgIGFmdGVyUmVzcG9uc2U6IFsuLi5ob29rcy5hZnRlclJlc3BvbnNlXSxcbiAgICAgICAgfSxcbiAgICAgICAgc2VhcmNoUGFyYW1zOiBpbnRlcm5hbHMuc2VhcmNoUGFyYW1zID8gbmV3IFVSTFNlYXJjaFBhcmFtcyhpbnRlcm5hbHMuc2VhcmNoUGFyYW1zKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFnaW5hdGlvbjogeyAuLi5pbnRlcm5hbHMucGFnaW5hdGlvbiB9LFxuICAgIH07XG4gICAgaWYgKHJlc3VsdC51cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQucHJlZml4VXJsID0gJyc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgY2xvbmVSYXcgPSAocmF3KSA9PiB7XG4gICAgY29uc3QgeyBob29rcywgcmV0cnkgfSA9IHJhdztcbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLnJhdyB9O1xuICAgIGlmIChpcy5vYmplY3QocmF3LmNvbnRleHQpKSB7XG4gICAgICAgIHJlc3VsdC5jb250ZXh0ID0geyAuLi5yYXcuY29udGV4dCB9O1xuICAgIH1cbiAgICBpZiAoaXMub2JqZWN0KHJhdy5jYWNoZU9wdGlvbnMpKSB7XG4gICAgICAgIHJlc3VsdC5jYWNoZU9wdGlvbnMgPSB7IC4uLnJhdy5jYWNoZU9wdGlvbnMgfTtcbiAgICB9XG4gICAgaWYgKGlzLm9iamVjdChyYXcuaHR0cHMpKSB7XG4gICAgICAgIHJlc3VsdC5odHRwcyA9IHsgLi4ucmF3Lmh0dHBzIH07XG4gICAgfVxuICAgIGlmIChpcy5vYmplY3QocmF3LmNhY2hlT3B0aW9ucykpIHtcbiAgICAgICAgcmVzdWx0LmNhY2hlT3B0aW9ucyA9IHsgLi4ucmVzdWx0LmNhY2hlT3B0aW9ucyB9O1xuICAgIH1cbiAgICBpZiAoaXMub2JqZWN0KHJhdy5hZ2VudCkpIHtcbiAgICAgICAgcmVzdWx0LmFnZW50ID0geyAuLi5yYXcuYWdlbnQgfTtcbiAgICB9XG4gICAgaWYgKGlzLm9iamVjdChyYXcuaGVhZGVycykpIHtcbiAgICAgICAgcmVzdWx0LmhlYWRlcnMgPSB7IC4uLnJhdy5oZWFkZXJzIH07XG4gICAgfVxuICAgIGlmIChpcy5vYmplY3QocmV0cnkpKSB7XG4gICAgICAgIHJlc3VsdC5yZXRyeSA9IHsgLi4ucmV0cnkgfTtcbiAgICAgICAgaWYgKGlzLmFycmF5KHJldHJ5LmVycm9yQ29kZXMpKSB7XG4gICAgICAgICAgICByZXN1bHQucmV0cnkuZXJyb3JDb2RlcyA9IFsuLi5yZXRyeS5lcnJvckNvZGVzXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuYXJyYXkocmV0cnkubWV0aG9kcykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZXRyeS5tZXRob2RzID0gWy4uLnJldHJ5Lm1ldGhvZHNdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcy5hcnJheShyZXRyeS5zdGF0dXNDb2RlcykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZXRyeS5zdGF0dXNDb2RlcyA9IFsuLi5yZXRyeS5zdGF0dXNDb2Rlc107XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLm9iamVjdChyYXcudGltZW91dCkpIHtcbiAgICAgICAgcmVzdWx0LnRpbWVvdXQgPSB7IC4uLnJhdy50aW1lb3V0IH07XG4gICAgfVxuICAgIGlmIChpcy5vYmplY3QoaG9va3MpKSB7XG4gICAgICAgIHJlc3VsdC5ob29rcyA9IHtcbiAgICAgICAgICAgIC4uLmhvb2tzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXMuYXJyYXkoaG9va3MuaW5pdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ob29rcy5pbml0ID0gWy4uLmhvb2tzLmluaXRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcy5hcnJheShob29rcy5iZWZvcmVSZXF1ZXN0KSkge1xuICAgICAgICAgICAgcmVzdWx0Lmhvb2tzLmJlZm9yZVJlcXVlc3QgPSBbLi4uaG9va3MuYmVmb3JlUmVxdWVzdF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzLmFycmF5KGhvb2tzLmJlZm9yZUVycm9yKSkge1xuICAgICAgICAgICAgcmVzdWx0Lmhvb2tzLmJlZm9yZUVycm9yID0gWy4uLmhvb2tzLmJlZm9yZUVycm9yXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuYXJyYXkoaG9va3MuYmVmb3JlUmVkaXJlY3QpKSB7XG4gICAgICAgICAgICByZXN1bHQuaG9va3MuYmVmb3JlUmVkaXJlY3QgPSBbLi4uaG9va3MuYmVmb3JlUmVkaXJlY3RdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcy5hcnJheShob29rcy5iZWZvcmVSZXRyeSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ob29rcy5iZWZvcmVSZXRyeSA9IFsuLi5ob29rcy5iZWZvcmVSZXRyeV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzLmFycmF5KGhvb2tzLmFmdGVyUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICByZXN1bHQuaG9va3MuYWZ0ZXJSZXNwb25zZSA9IFsuLi5ob29rcy5hZnRlclJlc3BvbnNlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUT0RPOiByYXcuc2VhcmNoUGFyYW1zXG4gICAgaWYgKGlzLm9iamVjdChyYXcucGFnaW5hdGlvbikpIHtcbiAgICAgICAgcmVzdWx0LnBhZ2luYXRpb24gPSB7IC4uLnJhdy5wYWdpbmF0aW9uIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgZ2V0SHR0cDJUaW1lb3V0T3B0aW9uID0gKGludGVybmFscykgPT4ge1xuICAgIGNvbnN0IGRlbGF5cyA9IFtpbnRlcm5hbHMudGltZW91dC5zb2NrZXQsIGludGVybmFscy50aW1lb3V0LmNvbm5lY3QsIGludGVybmFscy50aW1lb3V0Lmxvb2t1cCwgaW50ZXJuYWxzLnRpbWVvdXQucmVxdWVzdCwgaW50ZXJuYWxzLnRpbWVvdXQuc2VjdXJlQ29ubmVjdF0uZmlsdGVyKGRlbGF5ID0+IHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicpO1xuICAgIGlmIChkZWxheXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oLi4uZGVsYXlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCBpbml0ID0gKG9wdGlvbnMsIHdpdGhPcHRpb25zLCBzZWxmKSA9PiB7XG4gICAgY29uc3QgaW5pdEhvb2tzID0gb3B0aW9ucy5ob29rcz8uaW5pdDtcbiAgICBpZiAoaW5pdEhvb2tzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaG9vayBvZiBpbml0SG9va3MpIHtcbiAgICAgICAgICAgIGhvb2sod2l0aE9wdGlvbnMsIHNlbGYpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0LCBvcHRpb25zLCBkZWZhdWx0cykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdW5peE9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludGVybmFsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWVyZ2luZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW5pdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBhc3NlcnQuYW55KFtpcy5zdHJpbmcsIGlzLnVybEluc3RhbmNlLCBpcy5vYmplY3QsIGlzLnVuZGVmaW5lZF0sIGlucHV0KTtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMub2JqZWN0LCBpcy51bmRlZmluZWRdLCBvcHRpb25zKTtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMub2JqZWN0LCBpcy51bmRlZmluZWRdLCBkZWZhdWx0cyk7XG4gICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIE9wdGlvbnMgfHwgb3B0aW9ucyBpbnN0YW5jZW9mIE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBkZWZhdWx0cyBtdXN0IGJlIHBhc3NlZCBhcyB0aGUgdGhpcmQgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbHMgPSBjbG9uZUludGVybmFscyhkZWZhdWx0cz8uX2ludGVybmFscyA/PyBkZWZhdWx0cyA/PyBkZWZhdWx0SW50ZXJuYWxzKTtcbiAgICAgICAgdGhpcy5faW5pdCA9IFsuLi4oZGVmYXVsdHM/Ll9pbml0ID8/IFtdKV07XG4gICAgICAgIHRoaXMuX21lcmdpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdW5peE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoaXMgcnVsZSBhbGxvd3MgYGZpbmFsbHlgIHRvIGJlIGNvbnNpZGVyZWQgbW9yZSBpbXBvcnRhbnQuXG4gICAgICAgIC8vIE1lYW5pbmcgbm8gbWF0dGVyIHRoZSBlcnJvciB0aHJvd24gaW4gdGhlIGB0cnlgIGJsb2NrLFxuICAgICAgICAvLyBpZiBgZmluYWxseWAgdGhyb3dzIHRoZW4gdGhlIGBmaW5hbGx5YCBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gWWVzLCB3ZSB3YW50IHRoaXMuIElmIHdlIHNldCBgdXJsYCBmaXJzdCwgdGhlbiB0aGUgYHVybC5zZWFyY2hQYXJhbXNgXG4gICAgICAgIC8vIHdvdWxkIGdldCBtZXJnZWQuIEluc3RlYWQgd2Ugc2V0IHRoZSBgc2VhcmNoUGFyYW1zYCBmaXJzdCwgdGhlblxuICAgICAgICAvLyBgdXJsLnNlYXJjaFBhcmFtc2AgaXMgb3ZlcndyaXR0ZW4gYXMgZXhwZWN0ZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuc2FmZS1maW5hbGx5ICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXMucGxhaW5PYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZShpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2Uob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVybCA9IGlucHV0LnVybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnM/LnVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYHVybGAgb3B0aW9uIGlzIG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIHRoZSBgaW5wdXRgIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cmwgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLm9wdGlvbnMgPSB0aGlzO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnNhZmUtZmluYWxseSAqL1xuICAgIH1cbiAgICBtZXJnZShvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgT3B0aW9ucykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbml0IG9mIG9wdGlvbnMuX2luaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lcmdlKGluaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBjbG9uZVJhdyhvcHRpb25zKTtcbiAgICAgICAgaW5pdCh0aGlzLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgaW5pdChvcHRpb25zLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbWVyZ2luZyA9IHRydWU7XG4gICAgICAgIC8vIEFsd2F5cyBtZXJnZSBgaXNTdHJlYW1gIGZpcnN0XG4gICAgICAgIGlmICgnaXNTdHJlYW0nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdHJlYW0gPSBvcHRpb25zLmlzU3RyZWFtO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIC8vIGBnb3QuZXh0ZW5kKClgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnbXV0YWJsZURlZmF1bHRzJyB8fCBrZXkgPT09ICdoYW5kbGVycycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5ldmVyIG1lcmdlIGB1cmxgXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3VybCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3B0aW9uOiAke2tleX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUeXBlICd1bmtub3duJyBpcyBub3QgYXNzaWduYWJsZSB0byB0eXBlICduZXZlcicuXG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHB1c2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0LnB1c2gob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9tZXJnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3VzdG9tIHJlcXVlc3QgZnVuY3Rpb24uXG4gICAgVGhlIG1haW4gcHVycG9zZSBvZiB0aGlzIGlzIHRvIFtzdXBwb3J0IEhUVFAyIHVzaW5nIGEgd3JhcHBlcl0oaHR0cHM6Ly9naXRodWIuY29tL3N6bWFyY3phay9odHRwMi13cmFwcGVyKS5cblxuICAgIEBkZWZhdWx0IGh0dHAucmVxdWVzdCB8IGh0dHBzLnJlcXVlc3RcbiAgICAqL1xuICAgIGdldCByZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLnJlcXVlc3Q7XG4gICAgfVxuICAgIHNldCByZXF1ZXN0KHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLmZ1bmN0aW9uXywgaXMudW5kZWZpbmVkXSwgdmFsdWUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbHMucmVxdWVzdCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGBodHRwYCwgYGh0dHBzYCBhbmQgYGh0dHAyYCBrZXlzIGZvciBbYGh0dHAuQWdlbnRgXShodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX2NsYXNzX2h0dHBfYWdlbnQpLCBbYGh0dHBzLkFnZW50YF0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwcy5odG1sI2h0dHBzX2NsYXNzX2h0dHBzX2FnZW50KSBhbmQgW2BodHRwMndyYXBwZXIuQWdlbnRgXShodHRwczovL2dpdGh1Yi5jb20vc3ptYXJjemFrL2h0dHAyLXdyYXBwZXIjbmV3LWh0dHAyYWdlbnRvcHRpb25zKSBpbnN0YW5jZS5cbiAgICBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGEgcmVxdWVzdCB0byBvbmUgcHJvdG9jb2wgbWlnaHQgcmVkaXJlY3QgdG8gYW5vdGhlci5cbiAgICBJbiBzdWNoIGEgc2NlbmFyaW8sIEdvdCB3aWxsIHN3aXRjaCBvdmVyIHRvIHRoZSByaWdodCBwcm90b2NvbCBhZ2VudCBmb3IgeW91LlxuXG4gICAgSWYgYSBrZXkgaXMgbm90IHByZXNlbnQsIGl0IHdpbGwgZGVmYXVsdCB0byBhIGdsb2JhbCBhZ2VudC5cblxuICAgIEBleGFtcGxlXG4gICAgYGBgXG4gICAgaW1wb3J0IGdvdCBmcm9tICdnb3QnO1xuICAgIGltcG9ydCBIdHRwQWdlbnQgZnJvbSAnYWdlbnRrZWVwYWxpdmUnO1xuXG4gICAgY29uc3Qge0h0dHBzQWdlbnR9ID0gSHR0cEFnZW50O1xuXG4gICAgYXdhaXQgZ290KCdodHRwczovL3NpbmRyZXNvcmh1cy5jb20nLCB7XG4gICAgICAgIGFnZW50OiB7XG4gICAgICAgICAgICBodHRwOiBuZXcgSHR0cEFnZW50KCksXG4gICAgICAgICAgICBodHRwczogbmV3IEh0dHBzQWdlbnQoKVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgYGBgXG4gICAgKi9cbiAgICBnZXQgYWdlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMuYWdlbnQ7XG4gICAgfVxuICAgIHNldCBhZ2VudCh2YWx1ZSkge1xuICAgICAgICBhc3NlcnQucGxhaW5PYmplY3QodmFsdWUpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5faW50ZXJuYWxzLmFnZW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuZXhwZWN0ZWQgYWdlbnQgb3B0aW9uOiAke2tleX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBObyBpZGVhIHdoeSBgdmFsdWVba2V5XWAgZG9lc24ndCB3b3JrIGhlcmUuXG4gICAgICAgICAgICBhc3NlcnQuYW55KFtpcy5vYmplY3QsIGlzLnVuZGVmaW5lZF0sIHZhbHVlW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tZXJnaW5nKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2ludGVybmFscy5hZ2VudCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxzLmFnZW50ID0geyAuLi52YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBoMnNlc3Npb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMuaDJzZXNzaW9uO1xuICAgIH1cbiAgICBzZXQgaDJzZXNzaW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFscy5oMnNlc3Npb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVjb21wcmVzcyB0aGUgcmVzcG9uc2UgYXV0b21hdGljYWxseS5cblxuICAgIFRoaXMgd2lsbCBzZXQgdGhlIGBhY2NlcHQtZW5jb2RpbmdgIGhlYWRlciB0byBgZ3ppcCwgZGVmbGF0ZSwgYnJgIHVubGVzcyB5b3Ugc2V0IGl0IHlvdXJzZWxmLlxuXG4gICAgSWYgdGhpcyBpcyBkaXNhYmxlZCwgYSBjb21wcmVzc2VkIHJlc3BvbnNlIGlzIHJldHVybmVkIGFzIGEgYEJ1ZmZlcmAuXG4gICAgVGhpcyBtYXkgYmUgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGhhbmRsZSBkZWNvbXByZXNzaW9uIHlvdXJzZWxmIG9yIHN0cmVhbSB0aGUgcmF3IGNvbXByZXNzZWQgZGF0YS5cblxuICAgIEBkZWZhdWx0IHRydWVcbiAgICAqL1xuICAgIGdldCBkZWNvbXByZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLmRlY29tcHJlc3M7XG4gICAgfVxuICAgIHNldCBkZWNvbXByZXNzKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5ib29sZWFuKHZhbHVlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxzLmRlY29tcHJlc3MgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIHRoZSBzZXJ2ZXIgdG8gZW5kIHRoZSByZXNwb25zZSBiZWZvcmUgYWJvcnRpbmcgdGhlIHJlcXVlc3Qgd2l0aCBgZ290LlRpbWVvdXRFcnJvcmAgZXJyb3IgKGEuay5hLiBgcmVxdWVzdGAgcHJvcGVydHkpLlxuICAgIEJ5IGRlZmF1bHQsIHRoZXJlJ3Mgbm8gdGltZW91dC5cblxuICAgIFRoaXMgYWxzbyBhY2NlcHRzIGFuIGBvYmplY3RgIHdpdGggdGhlIGZvbGxvd2luZyBmaWVsZHMgdG8gY29uc3RyYWluIHRoZSBkdXJhdGlvbiBvZiBlYWNoIHBoYXNlIG9mIHRoZSByZXF1ZXN0IGxpZmVjeWNsZTpcblxuICAgIC0gYGxvb2t1cGAgc3RhcnRzIHdoZW4gYSBzb2NrZXQgaXMgYXNzaWduZWQgYW5kIGVuZHMgd2hlbiB0aGUgaG9zdG5hbWUgaGFzIGJlZW4gcmVzb2x2ZWQuXG4gICAgICAgIERvZXMgbm90IGFwcGx5IHdoZW4gdXNpbmcgYSBVbml4IGRvbWFpbiBzb2NrZXQuXG4gICAgLSBgY29ubmVjdGAgc3RhcnRzIHdoZW4gYGxvb2t1cGAgY29tcGxldGVzIChvciB3aGVuIHRoZSBzb2NrZXQgaXMgYXNzaWduZWQgaWYgbG9va3VwIGRvZXMgbm90IGFwcGx5IHRvIHRoZSByZXF1ZXN0KSBhbmQgZW5kcyB3aGVuIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkLlxuICAgIC0gYHNlY3VyZUNvbm5lY3RgIHN0YXJ0cyB3aGVuIGBjb25uZWN0YCBjb21wbGV0ZXMgYW5kIGVuZHMgd2hlbiB0aGUgaGFuZHNoYWtpbmcgcHJvY2VzcyBjb21wbGV0ZXMgKEhUVFBTIG9ubHkpLlxuICAgIC0gYHNvY2tldGAgc3RhcnRzIHdoZW4gdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQuIFNlZSBbcmVxdWVzdC5zZXRUaW1lb3V0XShodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX3JlcXVlc3Rfc2V0dGltZW91dF90aW1lb3V0X2NhbGxiYWNrKS5cbiAgICAtIGByZXNwb25zZWAgc3RhcnRzIHdoZW4gdGhlIHJlcXVlc3QgaGFzIGJlZW4gd3JpdHRlbiB0byB0aGUgc29ja2V0IGFuZCBlbmRzIHdoZW4gdGhlIHJlc3BvbnNlIGhlYWRlcnMgYXJlIHJlY2VpdmVkLlxuICAgIC0gYHNlbmRgIHN0YXJ0cyB3aGVuIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkIGFuZCBlbmRzIHdpdGggdGhlIHJlcXVlc3QgaGFzIGJlZW4gd3JpdHRlbiB0byB0aGUgc29ja2V0LlxuICAgIC0gYHJlcXVlc3RgIHN0YXJ0cyB3aGVuIHRoZSByZXF1ZXN0IGlzIGluaXRpYXRlZCBhbmQgZW5kcyB3aGVuIHRoZSByZXNwb25zZSdzIGVuZCBldmVudCBmaXJlcy5cbiAgICAqL1xuICAgIGdldCB0aW1lb3V0KCkge1xuICAgICAgICAvLyBXZSBhbHdheXMgcmV0dXJuIGBEZWxheXNgIGhlcmUuXG4gICAgICAgIC8vIEl0IGhhcyB0byBiZSBgRGVsYXlzIHwgbnVtYmVyYCwgb3RoZXJ3aXNlIFR5cGVTY3JpcHQgd2lsbCBlcnJvciBiZWNhdXNlIHRoZSBnZXR0ZXIgYW5kIHRoZSBzZXR0ZXIgaGF2ZSBpbmNvbXBhdGlibGUgdHlwZXMuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMudGltZW91dDtcbiAgICB9XG4gICAgc2V0IHRpbWVvdXQodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LnBsYWluT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuX2ludGVybmFscy50aW1lb3V0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0aW1lb3V0IG9wdGlvbjogJHtrZXl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gTm8gaWRlYSB3aHkgYHZhbHVlW2tleV1gIGRvZXNuJ3Qgd29yayBoZXJlLlxuICAgICAgICAgICAgYXNzZXJ0LmFueShbaXMubnVtYmVyLCBpcy51bmRlZmluZWRdLCB2YWx1ZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbWVyZ2luZykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9pbnRlcm5hbHMudGltZW91dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxzLnRpbWVvdXQgPSB7IC4uLnZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiBzcGVjaWZpZWQsIGBwcmVmaXhVcmxgIHdpbGwgYmUgcHJlcGVuZGVkIHRvIGB1cmxgLlxuICAgIFRoZSBwcmVmaXggY2FuIGJlIGFueSB2YWxpZCBVUkwsIGVpdGhlciByZWxhdGl2ZSBvciBhYnNvbHV0ZS5cbiAgICBBIHRyYWlsaW5nIHNsYXNoIGAvYCBpcyBvcHRpb25hbCAtIG9uZSB3aWxsIGJlIGFkZGVkIGF1dG9tYXRpY2FsbHkuXG5cbiAgICBfX05vdGVfXzogYHByZWZpeFVybGAgd2lsbCBiZSBpZ25vcmVkIGlmIHRoZSBgdXJsYCBhcmd1bWVudCBpcyBhIFVSTCBpbnN0YW5jZS5cblxuICAgIF9fTm90ZV9fOiBMZWFkaW5nIHNsYXNoZXMgaW4gYGlucHV0YCBhcmUgZGlzYWxsb3dlZCB3aGVuIHVzaW5nIHRoaXMgb3B0aW9uIHRvIGVuZm9yY2UgY29uc2lzdGVuY3kgYW5kIGF2b2lkIGNvbmZ1c2lvbi5cbiAgICBGb3IgZXhhbXBsZSwgd2hlbiB0aGUgcHJlZml4IFVSTCBpcyBgaHR0cHM6Ly9leGFtcGxlLmNvbS9mb29gIGFuZCB0aGUgaW5wdXQgaXMgYC9iYXJgLCB0aGVyZSdzIGFtYmlndWl0eSB3aGV0aGVyIHRoZSByZXN1bHRpbmcgVVJMIHdvdWxkIGJlY29tZSBgaHR0cHM6Ly9leGFtcGxlLmNvbS9mb28vYmFyYCBvciBgaHR0cHM6Ly9leGFtcGxlLmNvbS9iYXJgLlxuICAgIFRoZSBsYXR0ZXIgaXMgdXNlZCBieSBicm93c2Vycy5cblxuICAgIF9fVGlwX186IFVzZWZ1bCB3aGVuIHVzZWQgd2l0aCBgZ290LmV4dGVuZCgpYCB0byBjcmVhdGUgbmljaGUtc3BlY2lmaWMgR290IGluc3RhbmNlcy5cblxuICAgIF9fVGlwX186IFlvdSBjYW4gY2hhbmdlIGBwcmVmaXhVcmxgIHVzaW5nIGhvb2tzIGFzIGxvbmcgYXMgdGhlIFVSTCBzdGlsbCBpbmNsdWRlcyB0aGUgYHByZWZpeFVybGAuXG4gICAgSWYgdGhlIFVSTCBkb2Vzbid0IGluY2x1ZGUgaXQgYW55bW9yZSwgaXQgd2lsbCB0aHJvdy5cblxuICAgIEBleGFtcGxlXG4gICAgYGBgXG4gICAgaW1wb3J0IGdvdCBmcm9tICdnb3QnO1xuXG4gICAgYXdhaXQgZ290KCd1bmljb3JuJywge3ByZWZpeFVybDogJ2h0dHBzOi8vY2F0cy5jb20nfSk7XG4gICAgLy89PiAnaHR0cHM6Ly9jYXRzLmNvbS91bmljb3JuJ1xuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnb3QuZXh0ZW5kKHtcbiAgICAgICAgcHJlZml4VXJsOiAnaHR0cHM6Ly9nb29nbGUuY29tJ1xuICAgIH0pO1xuXG4gICAgYXdhaXQgaW5zdGFuY2UoJ3VuaWNvcm4nLCB7XG4gICAgICAgIGhvb2tzOiB7XG4gICAgICAgICAgICBiZWZvcmVSZXF1ZXN0OiBbXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucHJlZml4VXJsID0gJ2h0dHBzOi8vY2F0cy5jb20nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vPT4gJ2h0dHBzOi8vY2F0cy5jb20vdW5pY29ybidcbiAgICBgYGBcbiAgICAqL1xuICAgIGdldCBwcmVmaXhVcmwoKSB7XG4gICAgICAgIC8vIFdlIGFsd2F5cyByZXR1cm4gYHN0cmluZ2AgaGVyZS5cbiAgICAgICAgLy8gSXQgaGFzIHRvIGJlIGBzdHJpbmcgfCBVUkxgLCBvdGhlcndpc2UgVHlwZVNjcmlwdCB3aWxsIGVycm9yIGJlY2F1c2UgdGhlIGdldHRlciBhbmQgdGhlIHNldHRlciBoYXZlIGluY29tcGF0aWJsZSB0eXBlcy5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFscy5wcmVmaXhVcmw7XG4gICAgfVxuICAgIHNldCBwcmVmaXhVcmwodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMuc3RyaW5nLCBpcy51cmxJbnN0YW5jZV0sIHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxzLnByZWZpeFVybCA9ICcnO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKCF2YWx1ZS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFscy5wcmVmaXhVcmwgJiYgdGhpcy5faW50ZXJuYWxzLnVybCkge1xuICAgICAgICAgICAgY29uc3QgeyBocmVmIH0gPSB0aGlzLl9pbnRlcm5hbHMudXJsO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxzLnVybC5ocmVmID0gdmFsdWUgKyBocmVmLnNsaWNlKHRoaXMuX2ludGVybmFscy5wcmVmaXhVcmwubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbHMucHJlZml4VXJsID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIF9fTm90ZSAjMV9fOiBUaGUgYGJvZHlgIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIHRoZSBganNvbmAgb3IgYGZvcm1gIG9wdGlvbi5cblxuICAgIF9fTm90ZSAjMl9fOiBJZiB5b3UgcHJvdmlkZSB0aGlzIG9wdGlvbiwgYGdvdC5zdHJlYW0oKWAgd2lsbCBiZSByZWFkLW9ubHkuXG5cbiAgICBfX05vdGUgIzNfXzogSWYgeW91IHByb3ZpZGUgYSBwYXlsb2FkIHdpdGggdGhlIGBHRVRgIG9yIGBIRUFEYCBtZXRob2QsIGl0IHdpbGwgdGhyb3cgYSBgVHlwZUVycm9yYCB1bmxlc3MgdGhlIG1ldGhvZCBpcyBgR0VUYCBhbmQgdGhlIGBhbGxvd0dldEJvZHlgIG9wdGlvbiBpcyBzZXQgdG8gYHRydWVgLlxuXG4gICAgX19Ob3RlICM0X186IFRoaXMgb3B0aW9uIGlzIG5vdCBlbnVtZXJhYmxlIGFuZCB3aWxsIG5vdCBiZSBtZXJnZWQgd2l0aCB0aGUgaW5zdGFuY2UgZGVmYXVsdHMuXG5cbiAgICBUaGUgYGNvbnRlbnQtbGVuZ3RoYCBoZWFkZXIgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCBpZiBgYm9keWAgaXMgYSBgc3RyaW5nYCAvIGBCdWZmZXJgIC8gW2BGb3JtRGF0YWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Gb3JtRGF0YSkgLyBbYGZvcm0tZGF0YWAgaW5zdGFuY2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtLWRhdGEvZm9ybS1kYXRhKSwgYW5kIGBjb250ZW50LWxlbmd0aGAgYW5kIGB0cmFuc2Zlci1lbmNvZGluZ2AgYXJlIG5vdCBtYW51YWxseSBzZXQgaW4gYG9wdGlvbnMuaGVhZGVyc2AuXG5cbiAgICBTaW5jZSBHb3QgMTIsIHRoZSBgY29udGVudC1sZW5ndGhgIGlzIG5vdCBhdXRvbWF0aWNhbGx5IHNldCB3aGVuIGBib2R5YCBpcyBhIGBmcy5jcmVhdGVSZWFkU3RyZWFtYC5cbiAgICAqL1xuICAgIGdldCBib2R5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLmJvZHk7XG4gICAgfVxuICAgIHNldCBib2R5KHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLnN0cmluZywgaXMuYnVmZmVyLCBpcy5ub2RlU3RyZWFtLCBpcy5nZW5lcmF0b3IsIGlzLmFzeW5jR2VuZXJhdG9yLCBpc0Zvcm1EYXRhLCBpcy51bmRlZmluZWRdLCB2YWx1ZSk7XG4gICAgICAgIGlmIChpcy5ub2RlU3RyZWFtKHZhbHVlKSkge1xuICAgICAgICAgICAgYXNzZXJ0LnRydXRoeSh2YWx1ZS5yZWFkYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydC51bmRlZmluZWQodGhpcy5faW50ZXJuYWxzLmZvcm0pO1xuICAgICAgICAgICAgYXNzZXJ0LnVuZGVmaW5lZCh0aGlzLl9pbnRlcm5hbHMuanNvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxzLmJvZHkgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGZvcm0gYm9keSBpcyBjb252ZXJ0ZWQgdG8gYSBxdWVyeSBzdHJpbmcgdXNpbmcgW2AobmV3IFVSTFNlYXJjaFBhcmFtcyhvYmplY3QpKS50b1N0cmluZygpYF0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS91cmwuaHRtbCN1cmxfY29uc3RydWN0b3JfbmV3X3VybHNlYXJjaHBhcmFtc19vYmopLlxuXG4gICAgSWYgdGhlIGBDb250ZW50LVR5cGVgIGhlYWRlciBpcyBub3QgcHJlc2VudCwgaXQgd2lsbCBiZSBzZXQgdG8gYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGAuXG5cbiAgICBfX05vdGUgIzFfXzogSWYgeW91IHByb3ZpZGUgdGhpcyBvcHRpb24sIGBnb3Quc3RyZWFtKClgIHdpbGwgYmUgcmVhZC1vbmx5LlxuXG4gICAgX19Ob3RlICMyX186IFRoaXMgb3B0aW9uIGlzIG5vdCBlbnVtZXJhYmxlIGFuZCB3aWxsIG5vdCBiZSBtZXJnZWQgd2l0aCB0aGUgaW5zdGFuY2UgZGVmYXVsdHMuXG4gICAgKi9cbiAgICBnZXQgZm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFscy5mb3JtO1xuICAgIH1cbiAgICBzZXQgZm9ybSh2YWx1ZSkge1xuICAgICAgICBhc3NlcnQuYW55KFtpcy5wbGFpbk9iamVjdCwgaXMudW5kZWZpbmVkXSwgdmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0LnVuZGVmaW5lZCh0aGlzLl9pbnRlcm5hbHMuYm9keSk7XG4gICAgICAgICAgICBhc3NlcnQudW5kZWZpbmVkKHRoaXMuX2ludGVybmFscy5qc29uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbHMuZm9ybSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBKU09OIGJvZHkuIElmIHRoZSBgQ29udGVudC1UeXBlYCBoZWFkZXIgaXMgbm90IHNldCwgaXQgd2lsbCBiZSBzZXQgdG8gYGFwcGxpY2F0aW9uL2pzb25gLlxuXG4gICAgX19Ob3RlICMxX186IElmIHlvdSBwcm92aWRlIHRoaXMgb3B0aW9uLCBgZ290LnN0cmVhbSgpYCB3aWxsIGJlIHJlYWQtb25seS5cblxuICAgIF9fTm90ZSAjMl9fOiBUaGlzIG9wdGlvbiBpcyBub3QgZW51bWVyYWJsZSBhbmQgd2lsbCBub3QgYmUgbWVyZ2VkIHdpdGggdGhlIGluc3RhbmNlIGRlZmF1bHRzLlxuICAgICovXG4gICAgZ2V0IGpzb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMuanNvbjtcbiAgICB9XG4gICAgc2V0IGpzb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydC51bmRlZmluZWQodGhpcy5faW50ZXJuYWxzLmJvZHkpO1xuICAgICAgICAgICAgYXNzZXJ0LnVuZGVmaW5lZCh0aGlzLl9pbnRlcm5hbHMuZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxzLmpzb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIFVSTCB0byByZXF1ZXN0LCBhcyBhIHN0cmluZywgYSBbYGh0dHBzLnJlcXVlc3RgIG9wdGlvbnMgb2JqZWN0XShodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHBzLmh0bWwjaHR0cHNfaHR0cHNfcmVxdWVzdF9vcHRpb25zX2NhbGxiYWNrKSwgb3IgYSBbV0hBVFdHIGBVUkxgXShodHRwczovL25vZGVqcy5vcmcvYXBpL3VybC5odG1sI3VybF9jbGFzc191cmwpLlxuXG4gICAgUHJvcGVydGllcyBmcm9tIGBvcHRpb25zYCB3aWxsIG92ZXJyaWRlIHByb3BlcnRpZXMgaW4gdGhlIHBhcnNlZCBgdXJsYC5cblxuICAgIElmIG5vIHByb3RvY29sIGlzIHNwZWNpZmllZCwgaXQgd2lsbCB0aHJvdyBhIGBUeXBlRXJyb3JgLlxuXG4gICAgX19Ob3RlX186IFRoZSBxdWVyeSBzdHJpbmcgaXMgKipub3QqKiBwYXJzZWQgYXMgc2VhcmNoIHBhcmFtcy5cblxuICAgIEBleGFtcGxlXG4gICAgYGBgXG4gICAgYXdhaXQgZ290KCdodHRwczovL2V4YW1wbGUuY29tLz9xdWVyeT1hIGInKTsgLy89PiBodHRwczovL2V4YW1wbGUuY29tLz9xdWVyeT1hJTIwYlxuICAgIGF3YWl0IGdvdCgnaHR0cHM6Ly9leGFtcGxlLmNvbS8nLCB7c2VhcmNoUGFyYW1zOiB7cXVlcnk6ICdhIGInfX0pOyAvLz0+IGh0dHBzOi8vZXhhbXBsZS5jb20vP3F1ZXJ5PWErYlxuXG4gICAgLy8gVGhlIHF1ZXJ5IHN0cmluZyBpcyBvdmVycmlkZGVuIGJ5IGBzZWFyY2hQYXJhbXNgXG4gICAgYXdhaXQgZ290KCdodHRwczovL2V4YW1wbGUuY29tLz9xdWVyeT1hIGInLCB7c2VhcmNoUGFyYW1zOiB7cXVlcnk6ICdhIGInfX0pOyAvLz0+IGh0dHBzOi8vZXhhbXBsZS5jb20vP3F1ZXJ5PWErYlxuICAgIGBgYFxuICAgICovXG4gICAgZ2V0IHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFscy51cmw7XG4gICAgfVxuICAgIHNldCB1cmwodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMuc3RyaW5nLCBpcy51cmxJbnN0YW5jZSwgaXMudW5kZWZpbmVkXSwgdmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxzLnVybCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuc3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYHVybGAgbXVzdCBub3Qgc3RhcnQgd2l0aCBhIHNsYXNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsU3RyaW5nID0gYCR7dGhpcy5wcmVmaXhVcmx9JHt2YWx1ZS50b1N0cmluZygpfWA7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodXJsU3RyaW5nKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxzLnVybCA9IHVybDtcbiAgICAgICAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ3VuaXg6Jykge1xuICAgICAgICAgICAgdXJsLmhyZWYgPSBgaHR0cDovL3VuaXgke3VybC5wYXRobmFtZX0ke3VybC5zZWFyY2h9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsLnByb3RvY29sICE9PSAnaHR0cDonICYmIHVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm90b2NvbDogJHt1cmwucHJvdG9jb2x9YCk7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gJ0VSUl9VTlNVUFBPUlRFRF9QUk9UT0NPTCc7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxzLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICB1cmwudXNlcm5hbWUgPSB0aGlzLl9pbnRlcm5hbHMudXNlcm5hbWU7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbHMudXNlcm5hbWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxzLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICB1cmwucGFzc3dvcmQgPSB0aGlzLl9pbnRlcm5hbHMucGFzc3dvcmQ7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbHMucGFzc3dvcmQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxzLnNlYXJjaFBhcmFtcykge1xuICAgICAgICAgICAgdXJsLnNlYXJjaCA9IHRoaXMuX2ludGVybmFscy5zZWFyY2hQYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFscy5zZWFyY2hQYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybC5ob3N0bmFtZSA9PT0gJ3VuaXgnKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ludGVybmFscy5lbmFibGVVbml4U29ja2V0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNpbmcgVU5JWCBkb21haW4gc29ja2V0cyBidXQgb3B0aW9uIGBlbmFibGVVbml4U29ja2V0c2AgaXMgbm90IGVuYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSAvKD88c29ja2V0UGF0aD4uKz8pOig/PHBhdGg+LispLy5leGVjKGAke3VybC5wYXRobmFtZX0ke3VybC5zZWFyY2h9YCk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcz8uZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzb2NrZXRQYXRoLCBwYXRoIH0gPSBtYXRjaGVzLmdyb3VwcztcbiAgICAgICAgICAgICAgICB0aGlzLl91bml4T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogJycsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXhPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VuaXhPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBDb29raWUgc3VwcG9ydC4gWW91IGRvbid0IGhhdmUgdG8gY2FyZSBhYm91dCBwYXJzaW5nIG9yIGhvdyB0byBzdG9yZSB0aGVtLlxuXG4gICAgX19Ob3RlX186IElmIHlvdSBwcm92aWRlIHRoaXMgb3B0aW9uLCBgb3B0aW9ucy5oZWFkZXJzLmNvb2tpZWAgd2lsbCBiZSBvdmVycmlkZGVuLlxuICAgICovXG4gICAgZ2V0IGNvb2tpZUphcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFscy5jb29raWVKYXI7XG4gICAgfVxuICAgIHNldCBjb29raWVKYXIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMub2JqZWN0LCBpcy51bmRlZmluZWRdLCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbHMuY29va2llSmFyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHNldENvb2tpZSwgZ2V0Q29va2llU3RyaW5nIH0gPSB2YWx1ZTtcbiAgICAgICAgYXNzZXJ0LmZ1bmN0aW9uXyhzZXRDb29raWUpO1xuICAgICAgICBhc3NlcnQuZnVuY3Rpb25fKGdldENvb2tpZVN0cmluZyk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBIb3JyaWJsZSBgdG91Z2gtY29va2llYCB2MyBjaGVjayAqL1xuICAgICAgICBpZiAoc2V0Q29va2llLmxlbmd0aCA9PT0gNCAmJiBnZXRDb29raWVTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzZXRDb29raWUgPSBwcm9taXNpZnkoc2V0Q29va2llLmJpbmQodmFsdWUpKTtcbiAgICAgICAgICAgIGdldENvb2tpZVN0cmluZyA9IHByb21pc2lmeShnZXRDb29raWVTdHJpbmcuYmluZCh2YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxzLmNvb2tpZUphciA9IHtcbiAgICAgICAgICAgICAgICBzZXRDb29raWUsXG4gICAgICAgICAgICAgICAgZ2V0Q29va2llU3RyaW5nOiBnZXRDb29raWVTdHJpbmcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxzLmNvb2tpZUphciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFlvdSBjYW4gYWJvcnQgdGhlIGByZXF1ZXN0YCB1c2luZyBbYEFib3J0Q29udHJvbGxlcmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BYm9ydENvbnRyb2xsZXIpLlxuXG4gICAgKlJlcXVpcmVzIE5vZGUuanMgMTYgb3IgbGF0ZXIuKlxuXG4gICAgQGV4YW1wbGVcbiAgICBgYGBcbiAgICBpbXBvcnQgZ290IGZyb20gJ2dvdCc7XG5cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gZ290KCdodHRwczovL2h0dHBiaW4ub3JnL2FueXRoaW5nJywge1xuICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICB9KTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9LCAxMDApO1xuICAgIGBgYFxuICAgICovXG4gICAgLy8gVE9ETzogUmVwbGFjZSBgYW55YCB3aXRoIGBBYm9ydFNpZ25hbGAgd2hlbiB0YXJnZXRpbmcgTm9kZSAxNi5cbiAgICBnZXQgc2lnbmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLnNpZ25hbDtcbiAgICB9XG4gICAgLy8gVE9ETzogUmVwbGFjZSBgYW55YCB3aXRoIGBBYm9ydFNpZ25hbGAgd2hlbiB0YXJnZXRpbmcgTm9kZSAxNi5cbiAgICBzZXQgc2lnbmFsKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5vYmplY3QodmFsdWUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbHMuc2lnbmFsID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIElnbm9yZSBpbnZhbGlkIGNvb2tpZXMgaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvci5cbiAgICBPbmx5IHVzZWZ1bCB3aGVuIHRoZSBgY29va2llSmFyYCBvcHRpb24gaGFzIGJlZW4gc2V0LiBOb3QgcmVjb21tZW5kZWQuXG5cbiAgICBAZGVmYXVsdCBmYWxzZVxuICAgICovXG4gICAgZ2V0IGlnbm9yZUludmFsaWRDb29raWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLmlnbm9yZUludmFsaWRDb29raWVzO1xuICAgIH1cbiAgICBzZXQgaWdub3JlSW52YWxpZENvb2tpZXModmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LmJvb2xlYW4odmFsdWUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbHMuaWdub3JlSW52YWxpZENvb2tpZXMgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgc3RyaW5nIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgcmVxdWVzdCBVUkwuXG4gICAgVGhpcyB3aWxsIG92ZXJyaWRlIHRoZSBxdWVyeSBzdHJpbmcgaW4gYHVybGAuXG5cbiAgICBJZiB5b3UgbmVlZCB0byBwYXNzIGluIGFuIGFycmF5LCB5b3UgY2FuIGRvIGl0IHVzaW5nIGEgYFVSTFNlYXJjaFBhcmFtc2AgaW5zdGFuY2UuXG5cbiAgICBAZXhhbXBsZVxuICAgIGBgYFxuICAgIGltcG9ydCBnb3QgZnJvbSAnZ290JztcblxuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1sna2V5JywgJ2EnXSwgWydrZXknLCAnYiddXSk7XG5cbiAgICBhd2FpdCBnb3QoJ2h0dHBzOi8vZXhhbXBsZS5jb20nLCB7c2VhcmNoUGFyYW1zfSk7XG5cbiAgICBjb25zb2xlLmxvZyhzZWFyY2hQYXJhbXMudG9TdHJpbmcoKSk7XG4gICAgLy89PiAna2V5PWEma2V5PWInXG4gICAgYGBgXG4gICAgKi9cbiAgICBnZXQgc2VhcmNoUGFyYW1zKCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxzLnVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFscy51cmwuc2VhcmNoUGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbHMuc2VhcmNoUGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFscy5zZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFscy5zZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIHNldCBzZWFyY2hQYXJhbXModmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMuc3RyaW5nLCBpcy5vYmplY3QsIGlzLnVuZGVmaW5lZF0sIHZhbHVlKTtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5faW50ZXJuYWxzLnVybDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFscy5zZWFyY2hQYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgdXJsLnNlYXJjaCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtZXRlcnMgPSB0aGlzLnNlYXJjaFBhcmFtcztcbiAgICAgICAgbGV0IHVwZGF0ZWQ7XG4gICAgICAgIGlmIChpcy5zdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICB1cGRhdGVkID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRlU2VhcmNoUGFyYW1ldGVycyh2YWx1ZSk7XG4gICAgICAgICAgICB1cGRhdGVkID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuYXBwZW5kKGtleSwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtZXRlcnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmFwcGVuZChrZXksIGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21lcmdpbmcpIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIGtleXMgd2lsbCBiZSByZXBsYWNlZFxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXBkYXRlZC5rZXlzKCkpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hQYXJhbWV0ZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtZXRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVybCkge1xuICAgICAgICAgICAgdXJsLnNlYXJjaCA9IHNlYXJjaFBhcmFtZXRlcnMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFscy5zZWFyY2hQYXJhbXMgPSBzZWFyY2hQYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzZWFyY2hQYXJhbWV0ZXJzKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgc2VhcmNoUGFyYW1ldGVyc2Agb3B0aW9uIGRvZXMgbm90IGV4aXN0LiBVc2UgYHNlYXJjaFBhcmFtc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgc2V0IHNlYXJjaFBhcmFtZXRlcnMoX3ZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBzZWFyY2hQYXJhbWV0ZXJzYCBvcHRpb24gZG9lcyBub3QgZXhpc3QuIFVzZSBgc2VhcmNoUGFyYW1zYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICBnZXQgZG5zTG9va3VwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLmRuc0xvb2t1cDtcbiAgICB9XG4gICAgc2V0IGRuc0xvb2t1cCh2YWx1ZSkge1xuICAgICAgICBhc3NlcnQuYW55KFtpcy5mdW5jdGlvbl8sIGlzLnVuZGVmaW5lZF0sIHZhbHVlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxzLmRuc0xvb2t1cCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBBbiBpbnN0YW5jZSBvZiBbYENhY2hlYWJsZUxvb2t1cGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9zem1hcmN6YWsvY2FjaGVhYmxlLWxvb2t1cCkgdXNlZCBmb3IgbWFraW5nIEROUyBsb29rdXBzLlxuICAgIFVzZWZ1bCB3aGVuIG1ha2luZyBsb3RzIG9mIHJlcXVlc3RzIHRvIGRpZmZlcmVudCAqcHVibGljKiBob3N0bmFtZXMuXG5cbiAgICBgQ2FjaGVhYmxlTG9va3VwYCB1c2VzIGBkbnMucmVzb2x2ZXI0KC4uKWAgYW5kIGBkbnMucmVzb2x2ZXI2KC4uLilgIHVuZGVyIHRoZSBob29kIGFuZCBmYWxsIGJhY2tzIHRvIGBkbnMubG9va3VwKC4uLilgIHdoZW4gdGhlIGZpcnN0IHR3byBmYWlsLCB3aGljaCBtYXkgbGVhZCB0byBhZGRpdGlvbmFsIGRlbGF5LlxuXG4gICAgX19Ob3RlX186IFRoaXMgc2hvdWxkIHN0YXkgZGlzYWJsZWQgd2hlbiBtYWtpbmcgcmVxdWVzdHMgdG8gaW50ZXJuYWwgaG9zdG5hbWVzIHN1Y2ggYXMgYGxvY2FsaG9zdGAsIGBkYXRhYmFzZS5sb2NhbGAgZXRjLlxuXG4gICAgQGRlZmF1bHQgZmFsc2VcbiAgICAqL1xuICAgIGdldCBkbnNDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFscy5kbnNDYWNoZTtcbiAgICB9XG4gICAgc2V0IGRuc0NhY2hlKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLm9iamVjdCwgaXMuYm9vbGVhbiwgaXMudW5kZWZpbmVkXSwgdmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFscy5kbnNDYWNoZSA9IGdldEdsb2JhbERuc0NhY2hlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbHMuZG5zQ2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbHMuZG5zQ2FjaGUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBVc2VyIGRhdGEuIGBjb250ZXh0YCBpcyBzaGFsbG93IG1lcmdlZCBhbmQgZW51bWVyYWJsZS4gSWYgaXQgY29udGFpbnMgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyB0aGV5IHdpbGwgTk9UIGJlIG1lcmdlZC5cblxuICAgIEBleGFtcGxlXG4gICAgYGBgXG4gICAgaW1wb3J0IGdvdCBmcm9tICdnb3QnO1xuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnb3QuZXh0ZW5kKHtcbiAgICAgICAgaG9va3M6IHtcbiAgICAgICAgICAgIGJlZm9yZVJlcXVlc3Q6IFtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNvbnRleHQgfHwgIW9wdGlvbnMuY29udGV4dC50b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbiByZXF1aXJlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzLnRva2VuID0gb3B0aW9ucy5jb250ZXh0LnRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgdG9rZW46ICdzZWNyZXQnXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaW5zdGFuY2UoJ2h0dHBzOi8vaHR0cGJpbi5vcmcvaGVhZGVycycsIHtjb250ZXh0fSk7XG5cbiAgICAvLyBMZXQncyBzZWUgdGhlIGhlYWRlcnNcbiAgICBjb25zb2xlLmxvZyhyZXNwb25zZS5ib2R5KTtcbiAgICBgYGBcbiAgICAqL1xuICAgIGdldCBjb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLmNvbnRleHQ7XG4gICAgfVxuICAgIHNldCBjb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5vYmplY3QodmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5fbWVyZ2luZykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9pbnRlcm5hbHMuY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxzLmNvbnRleHQgPSB7IC4uLnZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSG9va3MgYWxsb3cgbW9kaWZpY2F0aW9ucyBkdXJpbmcgdGhlIHJlcXVlc3QgbGlmZWN5Y2xlLlxuICAgIEhvb2sgZnVuY3Rpb25zIG1heSBiZSBhc3luYyBhbmQgYXJlIHJ1biBzZXJpYWxseS5cbiAgICAqL1xuICAgIGdldCBob29rcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFscy5ob29rcztcbiAgICB9XG4gICAgc2V0IGhvb2tzKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5vYmplY3QodmFsdWUpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgICAgIGZvciAoY29uc3Qga25vd25Ib29rRXZlbnQgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghKGtub3duSG9va0V2ZW50IGluIHRoaXMuX2ludGVybmFscy5ob29rcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaG9vayBldmVudDogJHtrbm93bkhvb2tFdmVudH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGVkS25vd25Ib29rRXZlbnQgPSBrbm93bkhvb2tFdmVudDtcbiAgICAgICAgICAgIGNvbnN0IGhvb2tzID0gdmFsdWVbdHlwZWRLbm93bkhvb2tFdmVudF07XG4gICAgICAgICAgICBhc3NlcnQuYW55KFtpcy5hcnJheSwgaXMudW5kZWZpbmVkXSwgaG9va3MpO1xuICAgICAgICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBob29rIG9mIGhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5mdW5jdGlvbl8oaG9vayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21lcmdpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBGSVhNRVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbHMuaG9va3NbdHlwZWRLbm93bkhvb2tFdmVudF0ucHVzaCguLi5ob29rcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFob29rcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgaG9vayBldmVudDogJHtrbm93bkhvb2tFdmVudH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBGSVhNRVxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFscy5ob29rc1trbm93bkhvb2tFdmVudF0gPSBbLi4uaG9va3NdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZXMgaWYgcmVkaXJlY3QgcmVzcG9uc2VzIHNob3VsZCBiZSBmb2xsb3dlZCBhdXRvbWF0aWNhbGx5LlxuXG4gICAgTm90ZSB0aGF0IGlmIGEgYDMwM2AgaXMgc2VudCBieSB0aGUgc2VydmVyIGluIHJlc3BvbnNlIHRvIGFueSByZXF1ZXN0IHR5cGUgKGBQT1NUYCwgYERFTEVURWAsIGV0Yy4pLCBHb3Qgd2lsbCBhdXRvbWF0aWNhbGx5IHJlcXVlc3QgdGhlIHJlc291cmNlIHBvaW50ZWQgdG8gaW4gdGhlIGxvY2F0aW9uIGhlYWRlciB2aWEgYEdFVGAuXG4gICAgVGhpcyBpcyBpbiBhY2NvcmRhbmNlIHdpdGggW3RoZSBzcGVjXShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNC40KS4gWW91IGNhbiBvcHRpb25hbGx5IHR1cm4gb24gdGhpcyBiZWhhdmlvciBhbHNvIGZvciBvdGhlciByZWRpcmVjdCBjb2RlcyAtIHNlZSBgbWV0aG9kUmV3cml0aW5nYC5cblxuICAgIEBkZWZhdWx0IHRydWVcbiAgICAqL1xuICAgIGdldCBmb2xsb3dSZWRpcmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFscy5mb2xsb3dSZWRpcmVjdDtcbiAgICB9XG4gICAgc2V0IGZvbGxvd1JlZGlyZWN0KHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5ib29sZWFuKHZhbHVlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxzLmZvbGxvd1JlZGlyZWN0ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBmb2xsb3dSZWRpcmVjdHMoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBgZm9sbG93UmVkaXJlY3RzYCBvcHRpb24gZG9lcyBub3QgZXhpc3QuIFVzZSBgZm9sbG93UmVkaXJlY3RgIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHNldCBmb2xsb3dSZWRpcmVjdHMoX3ZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBgZm9sbG93UmVkaXJlY3RzYCBvcHRpb24gZG9lcyBub3QgZXhpc3QuIFVzZSBgZm9sbG93UmVkaXJlY3RgIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgIElmIGV4Y2VlZGVkLCB0aGUgcmVxdWVzdCB3aWxsIGJlIGFib3J0ZWQgYW5kIGEgYE1heFJlZGlyZWN0c0Vycm9yYCB3aWxsIGJlIHRocm93bi5cblxuICAgIEBkZWZhdWx0IDEwXG4gICAgKi9cbiAgICBnZXQgbWF4UmVkaXJlY3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLm1heFJlZGlyZWN0cztcbiAgICB9XG4gICAgc2V0IG1heFJlZGlyZWN0cyh2YWx1ZSkge1xuICAgICAgICBhc3NlcnQubnVtYmVyKHZhbHVlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxzLm1heFJlZGlyZWN0cyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBBIGNhY2hlIGFkYXB0ZXIgaW5zdGFuY2UgZm9yIHN0b3JpbmcgY2FjaGVkIHJlc3BvbnNlIGRhdGEuXG5cbiAgICBAZGVmYXVsdCBmYWxzZVxuICAgICovXG4gICAgZ2V0IGNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLmNhY2hlO1xuICAgIH1cbiAgICBzZXQgY2FjaGUodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMub2JqZWN0LCBpcy5zdHJpbmcsIGlzLmJvb2xlYW4sIGlzLnVuZGVmaW5lZF0sIHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbHMuY2FjaGUgPSBnbG9iYWxDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFscy5jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFscy5jYWNoZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIERldGVybWluZXMgaWYgYSBgZ290LkhUVFBFcnJvcmAgaXMgdGhyb3duIGZvciB1bnN1Y2Nlc3NmdWwgcmVzcG9uc2VzLlxuXG4gICAgSWYgdGhpcyBpcyBkaXNhYmxlZCwgcmVxdWVzdHMgdGhhdCBlbmNvdW50ZXIgYW4gZXJyb3Igc3RhdHVzIGNvZGUgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSBgcmVzcG9uc2VgIGluc3RlYWQgb2YgdGhyb3dpbmcuXG4gICAgVGhpcyBtYXkgYmUgdXNlZnVsIGlmIHlvdSBhcmUgY2hlY2tpbmcgZm9yIHJlc291cmNlIGF2YWlsYWJpbGl0eSBhbmQgYXJlIGV4cGVjdGluZyBlcnJvciByZXNwb25zZXMuXG5cbiAgICBAZGVmYXVsdCB0cnVlXG4gICAgKi9cbiAgICBnZXQgdGhyb3dIdHRwRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLnRocm93SHR0cEVycm9ycztcbiAgICB9XG4gICAgc2V0IHRocm93SHR0cEVycm9ycyh2YWx1ZSkge1xuICAgICAgICBhc3NlcnQuYm9vbGVhbih2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFscy50aHJvd0h0dHBFcnJvcnMgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHVzZXJuYW1lKCkge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLl9pbnRlcm5hbHMudXJsO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHVybCA/IHVybC51c2VybmFtZSA6IHRoaXMuX2ludGVybmFscy51c2VybmFtZTtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgfVxuICAgIHNldCB1c2VybmFtZSh2YWx1ZSkge1xuICAgICAgICBhc3NlcnQuc3RyaW5nKHZhbHVlKTtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5faW50ZXJuYWxzLnVybDtcbiAgICAgICAgY29uc3QgZml4ZWRWYWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIHVybC51c2VybmFtZSA9IGZpeGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbHMudXNlcm5hbWUgPSBmaXhlZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwYXNzd29yZCgpIHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5faW50ZXJuYWxzLnVybDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB1cmwgPyB1cmwucGFzc3dvcmQgOiB0aGlzLl9pbnRlcm5hbHMucGFzc3dvcmQ7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgIH1cbiAgICBzZXQgcGFzc3dvcmQodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LnN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX2ludGVybmFscy51cmw7XG4gICAgICAgIGNvbnN0IGZpeGVkVmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICB1cmwucGFzc3dvcmQgPSBmaXhlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxzLnBhc3N3b3JkID0gZml4ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJZiBzZXQgdG8gYHRydWVgLCBHb3Qgd2lsbCBhZGRpdGlvbmFsbHkgYWNjZXB0IEhUVFAyIHJlcXVlc3RzLlxuXG4gICAgSXQgd2lsbCBjaG9vc2UgZWl0aGVyIEhUVFAvMS4xIG9yIEhUVFAvMiBkZXBlbmRpbmcgb24gdGhlIEFMUE4gcHJvdG9jb2wuXG5cbiAgICBfX05vdGVfXzogVGhpcyBvcHRpb24gcmVxdWlyZXMgTm9kZS5qcyAxNS4xMC4wIG9yIG5ld2VyIGFzIEhUVFAvMiBzdXBwb3J0IG9uIG9sZGVyIE5vZGUuanMgdmVyc2lvbnMgaXMgdmVyeSBidWdneS5cblxuICAgIF9fTm90ZV9fOiBPdmVycmlkaW5nIGBvcHRpb25zLnJlcXVlc3RgIHdpbGwgZGlzYWJsZSBIVFRQMiBzdXBwb3J0LlxuXG4gICAgQGRlZmF1bHQgZmFsc2VcblxuICAgIEBleGFtcGxlXG4gICAgYGBgXG4gICAgaW1wb3J0IGdvdCBmcm9tICdnb3QnO1xuXG4gICAgY29uc3Qge2hlYWRlcnN9ID0gYXdhaXQgZ290KCdodHRwczovL25naHR0cDIub3JnL2h0dHBiaW4vYW55dGhpbmcnLCB7aHR0cDI6IHRydWV9KTtcblxuICAgIGNvbnNvbGUubG9nKGhlYWRlcnMudmlhKTtcbiAgICAvLz0+ICcyIG5naHR0cHgnXG4gICAgYGBgXG4gICAgKi9cbiAgICBnZXQgaHR0cDIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMuaHR0cDI7XG4gICAgfVxuICAgIHNldCBodHRwMih2YWx1ZSkge1xuICAgICAgICBhc3NlcnQuYm9vbGVhbih2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFscy5odHRwMiA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhpcyB0byBgdHJ1ZWAgdG8gYWxsb3cgc2VuZGluZyBib2R5IGZvciB0aGUgYEdFVGAgbWV0aG9kLlxuICAgIEhvd2V2ZXIsIHRoZSBbSFRUUC8yIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTQwI3NlY3Rpb24tOC4xLjMpIHNheXMgdGhhdCBgQW4gSFRUUCBHRVQgcmVxdWVzdCBpbmNsdWRlcyByZXF1ZXN0IGhlYWRlciBmaWVsZHMgYW5kIG5vIHBheWxvYWQgYm9keWAsIHRoZXJlZm9yZSB3aGVuIHVzaW5nIHRoZSBIVFRQLzIgcHJvdG9jb2wgdGhpcyBvcHRpb24gd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICBUaGlzIG9wdGlvbiBpcyBvbmx5IG1lYW50IHRvIGludGVyYWN0IHdpdGggbm9uLWNvbXBsaWFudCBzZXJ2ZXJzIHdoZW4geW91IGhhdmUgbm8gb3RoZXIgY2hvaWNlLlxuXG4gICAgX19Ob3RlX186IFRoZSBbUkZDIDcyMzFdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjEpIGRvZXNuJ3Qgc3BlY2lmeSBhbnkgcGFydGljdWxhciBiZWhhdmlvciBmb3IgdGhlIEdFVCBtZXRob2QgaGF2aW5nIGEgcGF5bG9hZCwgdGhlcmVmb3JlIF9faXQncyBjb25zaWRlcmVkIGFuIFthbnRpLXBhdHRlcm5dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FudGktcGF0dGVybilfXy5cblxuICAgIEBkZWZhdWx0IGZhbHNlXG4gICAgKi9cbiAgICBnZXQgYWxsb3dHZXRCb2R5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLmFsbG93R2V0Qm9keTtcbiAgICB9XG4gICAgc2V0IGFsbG93R2V0Qm9keSh2YWx1ZSkge1xuICAgICAgICBhc3NlcnQuYm9vbGVhbih2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFscy5hbGxvd0dldEJvZHkgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVxdWVzdCBoZWFkZXJzLlxuXG4gICAgRXhpc3RpbmcgaGVhZGVycyB3aWxsIGJlIG92ZXJ3cml0dGVuLiBIZWFkZXJzIHNldCB0byBgdW5kZWZpbmVkYCB3aWxsIGJlIG9taXR0ZWQuXG5cbiAgICBAZGVmYXVsdCB7fVxuICAgICovXG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMuaGVhZGVycztcbiAgICB9XG4gICAgc2V0IGhlYWRlcnModmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LnBsYWluT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuX21lcmdpbmcpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5faW50ZXJuYWxzLmhlYWRlcnMsIGxvd2VyY2FzZUtleXModmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFscy5oZWFkZXJzID0gbG93ZXJjYXNlS2V5cyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgU3BlY2lmaWVzIGlmIHRoZSBIVFRQIHJlcXVlc3QgbWV0aG9kIHNob3VsZCBiZSBbcmV3cml0dGVuIGFzIGBHRVRgXShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNCkgb24gcmVkaXJlY3RzLlxuXG4gICAgQXMgdGhlIFtzcGVjaWZpY2F0aW9uXShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNCkgcHJlZmVycyB0byByZXdyaXRlIHRoZSBIVFRQIG1ldGhvZCBvbmx5IG9uIGAzMDNgIHJlc3BvbnNlcywgdGhpcyBpcyBHb3QncyBkZWZhdWx0IGJlaGF2aW9yLlxuICAgIFNldHRpbmcgYG1ldGhvZFJld3JpdGluZ2AgdG8gYHRydWVgIHdpbGwgYWxzbyByZXdyaXRlIGAzMDFgIGFuZCBgMzAyYCByZXNwb25zZXMsIGFzIGFsbG93ZWQgYnkgdGhlIHNwZWMuIFRoaXMgaXMgdGhlIGJlaGF2aW9yIGZvbGxvd2VkIGJ5IGBjdXJsYCBhbmQgYnJvd3NlcnMuXG5cbiAgICBfX05vdGVfXzogR290IG5ldmVyIHBlcmZvcm1zIG1ldGhvZCByZXdyaXRpbmcgb24gYDMwN2AgYW5kIGAzMDhgIHJlc3BvbnNlcywgYXMgdGhpcyBpcyBbZXhwbGljaXRseSBwcm9oaWJpdGVkIGJ5IHRoZSBzcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMSNzZWN0aW9uLTYuNC43KS5cblxuICAgIEBkZWZhdWx0IGZhbHNlXG4gICAgKi9cbiAgICBnZXQgbWV0aG9kUmV3cml0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLm1ldGhvZFJld3JpdGluZztcbiAgICB9XG4gICAgc2V0IG1ldGhvZFJld3JpdGluZyh2YWx1ZSkge1xuICAgICAgICBhc3NlcnQuYm9vbGVhbih2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFscy5tZXRob2RSZXdyaXRpbmcgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoaWNoIEROUyByZWNvcmQgZmFtaWx5IHRvIHVzZS5cblxuICAgIFZhbHVlczpcbiAgICAtIGB1bmRlZmluZWRgOiBJUHY0IChpZiBwcmVzZW50KSBvciBJUHY2XG4gICAgLSBgNGA6IE9ubHkgSVB2NFxuICAgIC0gYDZgOiBPbmx5IElQdjZcblxuICAgIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICovXG4gICAgZ2V0IGRuc0xvb2t1cElwVmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFscy5kbnNMb29rdXBJcFZlcnNpb247XG4gICAgfVxuICAgIHNldCBkbnNMb29rdXBJcFZlcnNpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IDQgJiYgdmFsdWUgIT09IDYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgRE5TIGxvb2t1cCBJUCB2ZXJzaW9uOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFscy5kbnNMb29rdXBJcFZlcnNpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQSBmdW5jdGlvbiB1c2VkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2VzLlxuXG4gICAgQGV4YW1wbGVcbiAgICBgYGBcbiAgICBpbXBvcnQgZ290IGZyb20gJ2dvdCc7XG4gICAgaW1wb3J0IEJvdXJuZSBmcm9tICdAaGFwaS9ib3VybmUnO1xuXG4gICAgY29uc3QgcGFyc2VkID0gYXdhaXQgZ290KCdodHRwczovL2V4YW1wbGUuY29tJywge1xuICAgICAgICBwYXJzZUpzb246IHRleHQgPT4gQm91cm5lLnBhcnNlKHRleHQpXG4gICAgfSkuanNvbigpO1xuXG4gICAgY29uc29sZS5sb2cocGFyc2VkKTtcbiAgICBgYGBcbiAgICAqL1xuICAgIGdldCBwYXJzZUpzb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMucGFyc2VKc29uO1xuICAgIH1cbiAgICBzZXQgcGFyc2VKc29uKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5mdW5jdGlvbl8odmFsdWUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbHMucGFyc2VKc29uID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEEgZnVuY3Rpb24gdXNlZCB0byBzdHJpbmdpZnkgdGhlIGJvZHkgb2YgSlNPTiByZXF1ZXN0cy5cblxuICAgIEBleGFtcGxlXG4gICAgYGBgXG4gICAgaW1wb3J0IGdvdCBmcm9tICdnb3QnO1xuXG4gICAgYXdhaXQgZ290LnBvc3QoJ2h0dHBzOi8vZXhhbXBsZS5jb20nLCB7XG4gICAgICAgIHN0cmluZ2lmeUpzb246IG9iamVjdCA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ18nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KSxcbiAgICAgICAganNvbjoge1xuICAgICAgICAgICAgc29tZTogJ3BheWxvYWQnLFxuICAgICAgICAgICAgX2lnbm9yZU1lOiAxMjM0XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBgYGBcblxuICAgIEBleGFtcGxlXG4gICAgYGBgXG4gICAgaW1wb3J0IGdvdCBmcm9tICdnb3QnO1xuXG4gICAgYXdhaXQgZ290LnBvc3QoJ2h0dHBzOi8vZXhhbXBsZS5jb20nLCB7XG4gICAgICAgIHN0cmluZ2lmeUpzb246IG9iamVjdCA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pLFxuICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICBzb21lOiAncGF5bG9hZCcsXG4gICAgICAgICAgICBudW1iZXI6IDFcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGBgYFxuICAgICovXG4gICAgZ2V0IHN0cmluZ2lmeUpzb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMuc3RyaW5naWZ5SnNvbjtcbiAgICB9XG4gICAgc2V0IHN0cmluZ2lmeUpzb24odmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LmZ1bmN0aW9uXyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFscy5zdHJpbmdpZnlKc29uID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYGxpbWl0YCwgYGNhbGN1bGF0ZURlbGF5YCwgYG1ldGhvZHNgLCBgc3RhdHVzQ29kZXNgLCBgbWF4UmV0cnlBZnRlcmAgYW5kIGBlcnJvckNvZGVzYCBmaWVsZHMgZm9yIG1heGltdW0gcmV0cnkgY291bnQsIHJldHJ5IGhhbmRsZXIsIGFsbG93ZWQgbWV0aG9kcywgYWxsb3dlZCBzdGF0dXMgY29kZXMsIG1heGltdW0gW2BSZXRyeS1BZnRlcmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9SZXRyeS1BZnRlcikgdGltZSBhbmQgYWxsb3dlZCBlcnJvciBjb2Rlcy5cblxuICAgIERlbGF5cyBiZXR3ZWVuIHJldHJpZXMgY291bnRzIHdpdGggZnVuY3Rpb24gYDEwMDAgKiBNYXRoLnBvdygyLCByZXRyeSkgKyBNYXRoLnJhbmRvbSgpICogMTAwYCwgd2hlcmUgYHJldHJ5YCBpcyBhdHRlbXB0IG51bWJlciAoc3RhcnRzIGZyb20gMSkuXG5cbiAgICBUaGUgYGNhbGN1bGF0ZURlbGF5YCBwcm9wZXJ0eSBpcyBhIGBmdW5jdGlvbmAgdGhhdCByZWNlaXZlcyBhbiBvYmplY3Qgd2l0aCBgYXR0ZW1wdENvdW50YCwgYHJldHJ5T3B0aW9uc2AsIGBlcnJvcmAgYW5kIGBjb21wdXRlZFZhbHVlYCBwcm9wZXJ0aWVzIGZvciBjdXJyZW50IHJldHJ5IGNvdW50LCB0aGUgcmV0cnkgb3B0aW9ucywgZXJyb3IgYW5kIGRlZmF1bHQgY29tcHV0ZWQgdmFsdWUuXG4gICAgVGhlIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIChvciBhIFByb21pc2UgcmVzb2x2aW5nIHdpdGggaXQpIChgMGAgcmV0dXJuIHZhbHVlIGNhbmNlbHMgcmV0cnkpLlxuXG4gICAgQnkgZGVmYXVsdCwgaXQgcmV0cmllcyAqb25seSogb24gdGhlIHNwZWNpZmllZCBtZXRob2RzLCBzdGF0dXMgY29kZXMsIGFuZCBvbiB0aGVzZSBuZXR3b3JrIGVycm9yczpcblxuICAgIC0gYEVUSU1FRE9VVGA6IE9uZSBvZiB0aGUgW3RpbWVvdXRdKCN0aW1lb3V0KSBsaW1pdHMgd2VyZSByZWFjaGVkLlxuICAgIC0gYEVDT05OUkVTRVRgOiBDb25uZWN0aW9uIHdhcyBmb3JjaWJseSBjbG9zZWQgYnkgYSBwZWVyLlxuICAgIC0gYEVBRERSSU5VU0VgOiBDb3VsZCBub3QgYmluZCB0byBhbnkgZnJlZSBwb3J0LlxuICAgIC0gYEVDT05OUkVGVVNFRGA6IENvbm5lY3Rpb24gd2FzIHJlZnVzZWQgYnkgdGhlIHNlcnZlci5cbiAgICAtIGBFUElQRWA6IFRoZSByZW1vdGUgc2lkZSBvZiB0aGUgc3RyZWFtIGJlaW5nIHdyaXR0ZW4gaGFzIGJlZW4gY2xvc2VkLlxuICAgIC0gYEVOT1RGT1VORGA6IENvdWxkbid0IHJlc29sdmUgdGhlIGhvc3RuYW1lIHRvIGFuIElQIGFkZHJlc3MuXG4gICAgLSBgRU5FVFVOUkVBQ0hgOiBObyBpbnRlcm5ldCBjb25uZWN0aW9uLlxuICAgIC0gYEVBSV9BR0FJTmA6IEROUyBsb29rdXAgdGltZWQgb3V0LlxuXG4gICAgX19Ob3RlX186IElmIGBtYXhSZXRyeUFmdGVyYCBpcyBzZXQgdG8gYHVuZGVmaW5lZGAsIGl0IHdpbGwgdXNlIGBvcHRpb25zLnRpbWVvdXRgLlxuICAgIF9fTm90ZV9fOiBJZiBbYFJldHJ5LUFmdGVyYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1JldHJ5LUFmdGVyKSBoZWFkZXIgaXMgZ3JlYXRlciB0aGFuIGBtYXhSZXRyeUFmdGVyYCwgaXQgd2lsbCBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAgKi9cbiAgICBnZXQgcmV0cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMucmV0cnk7XG4gICAgfVxuICAgIHNldCByZXRyeSh2YWx1ZSkge1xuICAgICAgICBhc3NlcnQucGxhaW5PYmplY3QodmFsdWUpO1xuICAgICAgICBhc3NlcnQuYW55KFtpcy5mdW5jdGlvbl8sIGlzLnVuZGVmaW5lZF0sIHZhbHVlLmNhbGN1bGF0ZURlbGF5KTtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMubnVtYmVyLCBpcy51bmRlZmluZWRdLCB2YWx1ZS5tYXhSZXRyeUFmdGVyKTtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMubnVtYmVyLCBpcy51bmRlZmluZWRdLCB2YWx1ZS5saW1pdCk7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLmFycmF5LCBpcy51bmRlZmluZWRdLCB2YWx1ZS5tZXRob2RzKTtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMuYXJyYXksIGlzLnVuZGVmaW5lZF0sIHZhbHVlLnN0YXR1c0NvZGVzKTtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMuYXJyYXksIGlzLnVuZGVmaW5lZF0sIHZhbHVlLmVycm9yQ29kZXMpO1xuICAgICAgICBhc3NlcnQuYW55KFtpcy5udW1iZXIsIGlzLnVuZGVmaW5lZF0sIHZhbHVlLm5vaXNlKTtcbiAgICAgICAgaWYgKHZhbHVlLm5vaXNlICYmIE1hdGguYWJzKHZhbHVlLm5vaXNlKSA+IDEwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbWF4aW11bSBhY2NlcHRhYmxlIHJldHJ5IG5vaXNlIGlzICsvLSAxMDBtcywgZ290ICR7dmFsdWUubm9pc2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiB0aGlzLl9pbnRlcm5hbHMucmV0cnkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHJldHJ5IG9wdGlvbjogJHtrZXl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21lcmdpbmcpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5faW50ZXJuYWxzLnJldHJ5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbHMucmV0cnkgPSB7IC4uLnZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyByZXRyeSB9ID0gdGhpcy5faW50ZXJuYWxzO1xuICAgICAgICByZXRyeS5tZXRob2RzID0gWy4uLm5ldyBTZXQocmV0cnkubWV0aG9kcy5tYXAobWV0aG9kID0+IG1ldGhvZC50b1VwcGVyQ2FzZSgpKSldO1xuICAgICAgICByZXRyeS5zdGF0dXNDb2RlcyA9IFsuLi5uZXcgU2V0KHJldHJ5LnN0YXR1c0NvZGVzKV07XG4gICAgICAgIHJldHJ5LmVycm9yQ29kZXMgPSBbLi4ubmV3IFNldChyZXRyeS5lcnJvckNvZGVzKV07XG4gICAgfVxuICAgIC8qKlxuICAgIEZyb20gYGh0dHAuUmVxdWVzdE9wdGlvbnNgLlxuXG4gICAgVGhlIElQIGFkZHJlc3MgdXNlZCB0byBzZW5kIHRoZSByZXF1ZXN0IGZyb20uXG4gICAgKi9cbiAgICBnZXQgbG9jYWxBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLmxvY2FsQWRkcmVzcztcbiAgICB9XG4gICAgc2V0IGxvY2FsQWRkcmVzcyh2YWx1ZSkge1xuICAgICAgICBhc3NlcnQuYW55KFtpcy5zdHJpbmcsIGlzLnVuZGVmaW5lZF0sIHZhbHVlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxzLmxvY2FsQWRkcmVzcyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgSFRUUCBtZXRob2QgdXNlZCB0byBtYWtlIHRoZSByZXF1ZXN0LlxuXG4gICAgQGRlZmF1bHQgJ0dFVCdcbiAgICAqL1xuICAgIGdldCBtZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMubWV0aG9kO1xuICAgIH1cbiAgICBzZXQgbWV0aG9kKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5zdHJpbmcodmFsdWUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbHMubWV0aG9kID0gdmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgZ2V0IGNyZWF0ZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMuY3JlYXRlQ29ubmVjdGlvbjtcbiAgICB9XG4gICAgc2V0IGNyZWF0ZUNvbm5lY3Rpb24odmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMuZnVuY3Rpb25fLCBpcy51bmRlZmluZWRdLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFscy5jcmVhdGVDb25uZWN0aW9uID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEZyb20gYGh0dHAtY2FjaGUtc2VtYW50aWNzYFxuXG4gICAgQGRlZmF1bHQge31cbiAgICAqL1xuICAgIGdldCBjYWNoZU9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMuY2FjaGVPcHRpb25zO1xuICAgIH1cbiAgICBzZXQgY2FjaGVPcHRpb25zKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5wbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLmJvb2xlYW4sIGlzLnVuZGVmaW5lZF0sIHZhbHVlLnNoYXJlZCk7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLm51bWJlciwgaXMudW5kZWZpbmVkXSwgdmFsdWUuY2FjaGVIZXVyaXN0aWMpO1xuICAgICAgICBhc3NlcnQuYW55KFtpcy5udW1iZXIsIGlzLnVuZGVmaW5lZF0sIHZhbHVlLmltbXV0YWJsZU1pblRpbWVUb0xpdmUpO1xuICAgICAgICBhc3NlcnQuYW55KFtpcy5ib29sZWFuLCBpcy51bmRlZmluZWRdLCB2YWx1ZS5pZ25vcmVDYXJnb0N1bHQpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuX2ludGVybmFscy5jYWNoZU9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYWNoZSBvcHRpb24gXFxgJHtrZXl9XFxgIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21lcmdpbmcpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5faW50ZXJuYWxzLmNhY2hlT3B0aW9ucywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxzLmNhY2hlT3B0aW9ucyA9IHsgLi4udmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBPcHRpb25zIGZvciB0aGUgYWR2YW5jZWQgSFRUUFMgQVBJLlxuICAgICovXG4gICAgZ2V0IGh0dHBzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLmh0dHBzO1xuICAgIH1cbiAgICBzZXQgaHR0cHModmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LnBsYWluT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMuYm9vbGVhbiwgaXMudW5kZWZpbmVkXSwgdmFsdWUucmVqZWN0VW5hdXRob3JpemVkKTtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMuZnVuY3Rpb25fLCBpcy51bmRlZmluZWRdLCB2YWx1ZS5jaGVja1NlcnZlcklkZW50aXR5KTtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMuc3RyaW5nLCBpcy5vYmplY3QsIGlzLmFycmF5LCBpcy51bmRlZmluZWRdLCB2YWx1ZS5jZXJ0aWZpY2F0ZUF1dGhvcml0eSk7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLnN0cmluZywgaXMub2JqZWN0LCBpcy5hcnJheSwgaXMudW5kZWZpbmVkXSwgdmFsdWUua2V5KTtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMuc3RyaW5nLCBpcy5vYmplY3QsIGlzLmFycmF5LCBpcy51bmRlZmluZWRdLCB2YWx1ZS5jZXJ0aWZpY2F0ZSk7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLnN0cmluZywgaXMudW5kZWZpbmVkXSwgdmFsdWUucGFzc3BocmFzZSk7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLnN0cmluZywgaXMuYnVmZmVyLCBpcy5hcnJheSwgaXMudW5kZWZpbmVkXSwgdmFsdWUucGZ4KTtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMuYXJyYXksIGlzLnVuZGVmaW5lZF0sIHZhbHVlLmFscG5Qcm90b2NvbHMpO1xuICAgICAgICBhc3NlcnQuYW55KFtpcy5zdHJpbmcsIGlzLnVuZGVmaW5lZF0sIHZhbHVlLmNpcGhlcnMpO1xuICAgICAgICBhc3NlcnQuYW55KFtpcy5zdHJpbmcsIGlzLmJ1ZmZlciwgaXMudW5kZWZpbmVkXSwgdmFsdWUuZGhwYXJhbSk7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLnN0cmluZywgaXMudW5kZWZpbmVkXSwgdmFsdWUuc2lnbmF0dXJlQWxnb3JpdGhtcyk7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLnN0cmluZywgaXMudW5kZWZpbmVkXSwgdmFsdWUubWluVmVyc2lvbik7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLnN0cmluZywgaXMudW5kZWZpbmVkXSwgdmFsdWUubWF4VmVyc2lvbik7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLmJvb2xlYW4sIGlzLnVuZGVmaW5lZF0sIHZhbHVlLmhvbm9yQ2lwaGVyT3JkZXIpO1xuICAgICAgICBhc3NlcnQuYW55KFtpcy5udW1iZXIsIGlzLnVuZGVmaW5lZF0sIHZhbHVlLnRsc1Nlc3Npb25MaWZldGltZSk7XG4gICAgICAgIGFzc2VydC5hbnkoW2lzLnN0cmluZywgaXMudW5kZWZpbmVkXSwgdmFsdWUuZWNkaEN1cnZlKTtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMuc3RyaW5nLCBpcy5idWZmZXIsIGlzLmFycmF5LCBpcy51bmRlZmluZWRdLCB2YWx1ZS5jZXJ0aWZpY2F0ZVJldm9jYXRpb25MaXN0cyk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5faW50ZXJuYWxzLmh0dHBzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUFMgb3B0aW9uIFxcYCR7a2V5fVxcYCBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tZXJnaW5nKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2ludGVybmFscy5odHRwcywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxzLmh0dHBzID0geyAuLi52YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFtFbmNvZGluZ10oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNidWZmZXJfYnVmZmVyc19hbmRfY2hhcmFjdGVyX2VuY29kaW5ncykgdG8gYmUgdXNlZCBvbiBgc2V0RW5jb2RpbmdgIG9mIHRoZSByZXNwb25zZSBkYXRhLlxuXG4gICAgVG8gZ2V0IGEgW2BCdWZmZXJgXShodHRwczovL25vZGVqcy5vcmcvYXBpL2J1ZmZlci5odG1sKSwgeW91IG5lZWQgdG8gc2V0IGByZXNwb25zZVR5cGVgIHRvIGBidWZmZXJgIGluc3RlYWQuXG4gICAgRG9uJ3Qgc2V0IHRoaXMgb3B0aW9uIHRvIGBudWxsYC5cblxuICAgIF9fTm90ZV9fOiBUaGlzIGRvZXNuJ3QgYWZmZWN0IHN0cmVhbXMhIEluc3RlYWQsIHlvdSBuZWVkIHRvIGRvIGBnb3Quc3RyZWFtKC4uLikuc2V0RW5jb2RpbmcoZW5jb2RpbmcpYC5cblxuICAgIEBkZWZhdWx0ICd1dGYtOCdcbiAgICAqL1xuICAgIGdldCBlbmNvZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFscy5lbmNvZGluZztcbiAgICB9XG4gICAgc2V0IGVuY29kaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVG8gZ2V0IGEgQnVmZmVyLCBzZXQgYG9wdGlvbnMucmVzcG9uc2VUeXBlYCB0byBgYnVmZmVyYCBpbnN0ZWFkJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0LmFueShbaXMuc3RyaW5nLCBpcy51bmRlZmluZWRdLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFscy5lbmNvZGluZyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIHNldCB0byBgdHJ1ZWAgdGhlIHByb21pc2Ugd2lsbCByZXR1cm4gdGhlIFJlc3BvbnNlIGJvZHkgaW5zdGVhZCBvZiB0aGUgUmVzcG9uc2Ugb2JqZWN0LlxuXG4gICAgQGRlZmF1bHQgZmFsc2VcbiAgICAqL1xuICAgIGdldCByZXNvbHZlQm9keU9ubHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMucmVzb2x2ZUJvZHlPbmx5O1xuICAgIH1cbiAgICBzZXQgcmVzb2x2ZUJvZHlPbmx5KHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5ib29sZWFuKHZhbHVlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxzLnJlc29sdmVCb2R5T25seSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgYFN0cmVhbWAgaW5zdGVhZCBvZiBhIGBQcm9taXNlYC5cbiAgICBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBgZ290LnN0cmVhbSh1cmwsIG9wdGlvbnM/KWAuXG5cbiAgICBAZGVmYXVsdCBmYWxzZVxuICAgICovXG4gICAgZ2V0IGlzU3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLmlzU3RyZWFtO1xuICAgIH1cbiAgICBzZXQgaXNTdHJlYW0odmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LmJvb2xlYW4odmFsdWUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbHMuaXNTdHJlYW0gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBhcnNpbmcgbWV0aG9kLlxuXG4gICAgVGhlIHByb21pc2UgYWxzbyBoYXMgYC50ZXh0KClgLCBgLmpzb24oKWAgYW5kIGAuYnVmZmVyKClgIG1ldGhvZHMgd2hpY2ggcmV0dXJuIGFub3RoZXIgR290IHByb21pc2UgZm9yIHRoZSBwYXJzZWQgYm9keS5cblxuICAgIEl0J3MgbGlrZSBzZXR0aW5nIHRoZSBvcHRpb25zIHRvIGB7cmVzcG9uc2VUeXBlOiAnanNvbicsIHJlc29sdmVCb2R5T25seTogdHJ1ZX1gIGJ1dCB3aXRob3V0IGFmZmVjdGluZyB0aGUgbWFpbiBHb3QgcHJvbWlzZS5cblxuICAgIF9fTm90ZV9fOiBXaGVuIHVzaW5nIHN0cmVhbXMsIHRoaXMgb3B0aW9uIGlzIGlnbm9yZWQuXG5cbiAgICBAZXhhbXBsZVxuICAgIGBgYFxuICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IGdvdCh1cmwpO1xuICAgIGNvbnN0IGJ1ZmZlclByb21pc2UgPSByZXNwb25zZVByb21pc2UuYnVmZmVyKCk7XG4gICAgY29uc3QganNvblByb21pc2UgPSByZXNwb25zZVByb21pc2UuanNvbigpO1xuXG4gICAgY29uc3QgW3Jlc3BvbnNlLCBidWZmZXIsIGpzb25dID0gUHJvbWlzZS5hbGwoW3Jlc3BvbnNlUHJvbWlzZSwgYnVmZmVyUHJvbWlzZSwganNvblByb21pc2VdKTtcbiAgICAvLyBgcmVzcG9uc2VgIGlzIGFuIGluc3RhbmNlIG9mIEdvdCBSZXNwb25zZVxuICAgIC8vIGBidWZmZXJgIGlzIGFuIGluc3RhbmNlIG9mIEJ1ZmZlclxuICAgIC8vIGBqc29uYCBpcyBhbiBvYmplY3RcbiAgICBgYGBcblxuICAgIEBleGFtcGxlXG4gICAgYGBgXG4gICAgLy8gVGhpc1xuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCBnb3QodXJsKS5qc29uKCk7XG5cbiAgICAvLyBpcyBzZW1hbnRpY2FsbHkgdGhlIHNhbWUgYXMgdGhpc1xuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCBnb3QodXJsLCB7cmVzcG9uc2VUeXBlOiAnanNvbicsIHJlc29sdmVCb2R5T25seTogdHJ1ZX0pO1xuICAgIGBgYFxuICAgICovXG4gICAgZ2V0IHJlc3BvbnNlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFscy5yZXNwb25zZVR5cGU7XG4gICAgfVxuICAgIHNldCByZXNwb25zZVR5cGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFscy5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSAndGV4dCcgJiYgdmFsdWUgIT09ICdidWZmZXInICYmIHZhbHVlICE9PSAnanNvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcXGByZXNwb25zZVR5cGVcXGAgb3B0aW9uOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFscy5yZXNwb25zZVR5cGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHBhZ2luYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMucGFnaW5hdGlvbjtcbiAgICB9XG4gICAgc2V0IHBhZ2luYXRpb24odmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0Lm9iamVjdCh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9tZXJnaW5nKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2ludGVybmFscy5wYWdpbmF0aW9uLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbHMucGFnaW5hdGlvbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhdXRoKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciBgYXV0aGAgaXMgZGVwcmVjYXRlZC4gVXNlIGB1c2VybmFtZWAgLyBgcGFzc3dvcmRgIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHNldCBhdXRoKF92YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciBgYXV0aGAgaXMgZGVwcmVjYXRlZC4gVXNlIGB1c2VybmFtZWAgLyBgcGFzc3dvcmRgIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGdldCBzZXRIb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxzLnNldEhvc3Q7XG4gICAgfVxuICAgIHNldCBzZXRIb3N0KHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5ib29sZWFuKHZhbHVlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxzLnNldEhvc3QgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IG1heEhlYWRlclNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbHMubWF4SGVhZGVyU2l6ZTtcbiAgICB9XG4gICAgc2V0IG1heEhlYWRlclNpemUodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0LmFueShbaXMubnVtYmVyLCBpcy51bmRlZmluZWRdLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFscy5tYXhIZWFkZXJTaXplID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBlbmFibGVVbml4U29ja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFscy5lbmFibGVVbml4U29ja2V0cztcbiAgICB9XG4gICAgc2V0IGVuYWJsZVVuaXhTb2NrZXRzKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydC5ib29sZWFuKHZhbHVlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxzLmVuYWJsZVVuaXhTb2NrZXRzID0gdmFsdWU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IC4uLnRoaXMuX2ludGVybmFscyB9O1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oX2RlcHRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMuX2ludGVybmFscywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNyZWF0ZU5hdGl2ZVJlcXVlc3RPcHRpb25zKCkge1xuICAgICAgICBjb25zdCBpbnRlcm5hbHMgPSB0aGlzLl9pbnRlcm5hbHM7XG4gICAgICAgIGNvbnN0IHVybCA9IGludGVybmFscy51cmw7XG4gICAgICAgIGxldCBhZ2VudDtcbiAgICAgICAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIGFnZW50ID0gaW50ZXJuYWxzLmh0dHAyID8gaW50ZXJuYWxzLmFnZW50IDogaW50ZXJuYWxzLmFnZW50Lmh0dHBzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWdlbnQgPSBpbnRlcm5hbHMuYWdlbnQuaHR0cDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGh0dHBzIH0gPSBpbnRlcm5hbHM7XG4gICAgICAgIGxldCB7IHBmeCB9ID0gaHR0cHM7XG4gICAgICAgIGlmIChpcy5hcnJheShwZngpICYmIGlzLnBsYWluT2JqZWN0KHBmeFswXSkpIHtcbiAgICAgICAgICAgIHBmeCA9IHBmeC5tYXAob2JqZWN0ID0+ICh7XG4gICAgICAgICAgICAgICAgYnVmOiBvYmplY3QuYnVmZmVyLFxuICAgICAgICAgICAgICAgIHBhc3NwaHJhc2U6IG9iamVjdC5wYXNzcGhyYXNlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5pbnRlcm5hbHMuY2FjaGVPcHRpb25zLFxuICAgICAgICAgICAgLi4udGhpcy5fdW5peE9wdGlvbnMsXG4gICAgICAgICAgICAvLyBIVFRQUyBvcHRpb25zXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgICAgICAgICBBTFBOUHJvdG9jb2xzOiBodHRwcy5hbHBuUHJvdG9jb2xzLFxuICAgICAgICAgICAgY2E6IGh0dHBzLmNlcnRpZmljYXRlQXV0aG9yaXR5LFxuICAgICAgICAgICAgY2VydDogaHR0cHMuY2VydGlmaWNhdGUsXG4gICAgICAgICAgICBrZXk6IGh0dHBzLmtleSxcbiAgICAgICAgICAgIHBhc3NwaHJhc2U6IGh0dHBzLnBhc3NwaHJhc2UsXG4gICAgICAgICAgICBwZng6IGh0dHBzLnBmeCxcbiAgICAgICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogaHR0cHMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgICAgICAgICAgY2hlY2tTZXJ2ZXJJZGVudGl0eTogaHR0cHMuY2hlY2tTZXJ2ZXJJZGVudGl0eSA/PyBjaGVja1NlcnZlcklkZW50aXR5LFxuICAgICAgICAgICAgY2lwaGVyczogaHR0cHMuY2lwaGVycyxcbiAgICAgICAgICAgIGhvbm9yQ2lwaGVyT3JkZXI6IGh0dHBzLmhvbm9yQ2lwaGVyT3JkZXIsXG4gICAgICAgICAgICBtaW5WZXJzaW9uOiBodHRwcy5taW5WZXJzaW9uLFxuICAgICAgICAgICAgbWF4VmVyc2lvbjogaHR0cHMubWF4VmVyc2lvbixcbiAgICAgICAgICAgIHNpZ2FsZ3M6IGh0dHBzLnNpZ25hdHVyZUFsZ29yaXRobXMsXG4gICAgICAgICAgICBzZXNzaW9uVGltZW91dDogaHR0cHMudGxzU2Vzc2lvbkxpZmV0aW1lLFxuICAgICAgICAgICAgZGhwYXJhbTogaHR0cHMuZGhwYXJhbSxcbiAgICAgICAgICAgIGVjZGhDdXJ2ZTogaHR0cHMuZWNkaEN1cnZlLFxuICAgICAgICAgICAgY3JsOiBodHRwcy5jZXJ0aWZpY2F0ZVJldm9jYXRpb25MaXN0cyxcbiAgICAgICAgICAgIC8vIEhUVFAgb3B0aW9uc1xuICAgICAgICAgICAgbG9va3VwOiBpbnRlcm5hbHMuZG5zTG9va3VwID8/IGludGVybmFscy5kbnNDYWNoZT8ubG9va3VwLFxuICAgICAgICAgICAgZmFtaWx5OiBpbnRlcm5hbHMuZG5zTG9va3VwSXBWZXJzaW9uLFxuICAgICAgICAgICAgYWdlbnQsXG4gICAgICAgICAgICBzZXRIb3N0OiBpbnRlcm5hbHMuc2V0SG9zdCxcbiAgICAgICAgICAgIG1ldGhvZDogaW50ZXJuYWxzLm1ldGhvZCxcbiAgICAgICAgICAgIG1heEhlYWRlclNpemU6IGludGVybmFscy5tYXhIZWFkZXJTaXplLFxuICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBpbnRlcm5hbHMubG9jYWxBZGRyZXNzLFxuICAgICAgICAgICAgaGVhZGVyczogaW50ZXJuYWxzLmhlYWRlcnMsXG4gICAgICAgICAgICBjcmVhdGVDb25uZWN0aW9uOiBpbnRlcm5hbHMuY3JlYXRlQ29ubmVjdGlvbixcbiAgICAgICAgICAgIHRpbWVvdXQ6IGludGVybmFscy5odHRwMiA/IGdldEh0dHAyVGltZW91dE9wdGlvbihpbnRlcm5hbHMpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gSFRUUC8yIG9wdGlvbnNcbiAgICAgICAgICAgIGgyc2Vzc2lvbjogaW50ZXJuYWxzLmgyc2Vzc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0UmVxdWVzdEZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLl9pbnRlcm5hbHMudXJsO1xuICAgICAgICBjb25zdCB7IHJlcXVlc3QgfSA9IHRoaXMuX2ludGVybmFscztcbiAgICAgICAgaWYgKCFyZXF1ZXN0ICYmIHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmFsbGJhY2tSZXF1ZXN0RnVuY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgZ2V0RmFsbGJhY2tSZXF1ZXN0RnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX2ludGVybmFscy51cmw7XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbHMuaHR0cDIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFqb3IgPCAxNSB8fCAobWFqb3IgPT09IDE1ICYmIG1pbm9yIDwgMTApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdUbyB1c2UgdGhlIGBodHRwMmAgb3B0aW9uLCBpbnN0YWxsIE5vZGUuanMgMTUuMTAuMCBvciBhYm92ZScpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gJ0VVTlNVUFBPUlRFRCc7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cDJ3cmFwcGVyLmF1dG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaHR0cHMucmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHR0cC5yZXF1ZXN0O1xuICAgIH1cbiAgICBmcmVlemUoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9pbnRlcm5hbHM7XG4gICAgICAgIE9iamVjdC5mcmVlemUob3B0aW9ucyk7XG4gICAgICAgIE9iamVjdC5mcmVlemUob3B0aW9ucy5ob29rcyk7XG4gICAgICAgIE9iamVjdC5mcmVlemUob3B0aW9ucy5ob29rcy5hZnRlclJlc3BvbnNlKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShvcHRpb25zLmhvb2tzLmJlZm9yZUVycm9yKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShvcHRpb25zLmhvb2tzLmJlZm9yZVJlZGlyZWN0KTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShvcHRpb25zLmhvb2tzLmJlZm9yZVJlcXVlc3QpO1xuICAgICAgICBPYmplY3QuZnJlZXplKG9wdGlvbnMuaG9va3MuYmVmb3JlUmV0cnkpO1xuICAgICAgICBPYmplY3QuZnJlZXplKG9wdGlvbnMuaG9va3MuaW5pdCk7XG4gICAgICAgIE9iamVjdC5mcmVlemUob3B0aW9ucy5odHRwcyk7XG4gICAgICAgIE9iamVjdC5mcmVlemUob3B0aW9ucy5jYWNoZU9wdGlvbnMpO1xuICAgICAgICBPYmplY3QuZnJlZXplKG9wdGlvbnMuYWdlbnQpO1xuICAgICAgICBPYmplY3QuZnJlZXplKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIE9iamVjdC5mcmVlemUob3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShvcHRpb25zLnJldHJ5KTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShvcHRpb25zLnJldHJ5LmVycm9yQ29kZXMpO1xuICAgICAgICBPYmplY3QuZnJlZXplKG9wdGlvbnMucmV0cnkubWV0aG9kcyk7XG4gICAgICAgIE9iamVjdC5mcmVlemUob3B0aW9ucy5yZXRyeS5zdGF0dXNDb2Rlcyk7XG4gICAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VMaW5rSGVhZGVyKGxpbmspIHtcbiAgICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgICBjb25zdCBpdGVtcyA9IGxpbmsuc3BsaXQoJywnKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzU5ODgjc2VjdGlvbi01XG4gICAgICAgIGNvbnN0IFtyYXdVcmlSZWZlcmVuY2UsIC4uLnJhd0xpbmtQYXJhbWV0ZXJzXSA9IGl0ZW0uc3BsaXQoJzsnKTtcbiAgICAgICAgY29uc3QgdHJpbW1lZFVyaVJlZmVyZW5jZSA9IHJhd1VyaVJlZmVyZW5jZS50cmltKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXN0cmluZy1zdGFydHMtZW5kcy13aXRoXG4gICAgICAgIGlmICh0cmltbWVkVXJpUmVmZXJlbmNlWzBdICE9PSAnPCcgfHwgdHJpbW1lZFVyaVJlZmVyZW5jZVt0cmltbWVkVXJpUmVmZXJlbmNlLmxlbmd0aCAtIDFdICE9PSAnPicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmb3JtYXQgb2YgdGhlIExpbmsgaGVhZGVyIHJlZmVyZW5jZTogJHt0cmltbWVkVXJpUmVmZXJlbmNlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZSA9IHRyaW1tZWRVcmlSZWZlcmVuY2Uuc2xpY2UoMSwgLTEpO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0ge307XG4gICAgICAgIGlmIChyYXdMaW5rUGFyYW1ldGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBlbmQgb2YgTGluayBoZWFkZXIgcGFyYW1ldGVyczogJHtyYXdMaW5rUGFyYW1ldGVycy5qb2luKCc7Jyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCByYXdQYXJhbWV0ZXIgb2YgcmF3TGlua1BhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRSYXdQYXJhbWV0ZXIgPSByYXdQYXJhbWV0ZXIudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgY2VudGVyID0gdHJpbW1lZFJhd1BhcmFtZXRlci5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgICBpZiAoY2VudGVyID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIExpbmsgaGVhZGVyOiAke2xpbmt9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdHJpbW1lZFJhd1BhcmFtZXRlci5zbGljZSgwLCBjZW50ZXIpLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdHJpbW1lZFJhd1BhcmFtZXRlci5zbGljZShjZW50ZXIgKyAxKS50cmltKCk7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG59XG4iLCJpbXBvcnQgeyBSZXF1ZXN0RXJyb3IgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5leHBvcnQgY29uc3QgaXNSZXNwb25zZU9rID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgY29uc3QgeyBzdGF0dXNDb2RlIH0gPSByZXNwb25zZTtcbiAgICBjb25zdCBsaW1pdFN0YXR1c0NvZGUgPSByZXNwb25zZS5yZXF1ZXN0Lm9wdGlvbnMuZm9sbG93UmVkaXJlY3QgPyAyOTkgOiAzOTk7XG4gICAgcmV0dXJuIChzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDw9IGxpbWl0U3RhdHVzQ29kZSkgfHwgc3RhdHVzQ29kZSA9PT0gMzA0O1xufTtcbi8qKlxuQW4gZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gc2VydmVyIHJlc3BvbnNlIGNvZGUgaXMgMnh4LCBhbmQgcGFyc2luZyBib2R5IGZhaWxzLlxuSW5jbHVkZXMgYSBgcmVzcG9uc2VgIHByb3BlcnR5LlxuKi9cbmV4cG9ydCBjbGFzcyBQYXJzZUVycm9yIGV4dGVuZHMgUmVxdWVzdEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvciwgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSByZXNwb25zZS5yZXF1ZXN0O1xuICAgICAgICBzdXBlcihgJHtlcnJvci5tZXNzYWdlfSBpbiBcIiR7b3B0aW9ucy51cmwudG9TdHJpbmcoKX1cImAsIGVycm9yLCByZXNwb25zZS5yZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1BhcnNlRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSAnRVJSX0JPRFlfUEFSU0VfRkFJTFVSRSc7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHBhcnNlQm9keSA9IChyZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBwYXJzZUpzb24sIGVuY29kaW5nKSA9PiB7XG4gICAgY29uc3QgeyByYXdCb2R5IH0gPSByZXNwb25zZTtcbiAgICB0cnkge1xuICAgICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHJldHVybiByYXdCb2R5LnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAnanNvbicpIHtcbiAgICAgICAgICAgIHJldHVybiByYXdCb2R5Lmxlbmd0aCA9PT0gMCA/ICcnIDogcGFyc2VKc29uKHJhd0JvZHkudG9TdHJpbmcoZW5jb2RpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAnYnVmZmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHJhd0JvZHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGVycm9yLCByZXNwb25zZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYFVua25vd24gYm9keSB0eXBlICcke3Jlc3BvbnNlVHlwZX0nYCxcbiAgICAgICAgbmFtZTogJ0Vycm9yJyxcbiAgICB9LCByZXNwb25zZSk7XG59O1xuIiwiaW1wb3J0IG5ldCBmcm9tICdub2RlOm5ldCc7XG5pbXBvcnQgdW5oYW5kbGVyIGZyb20gJy4vdXRpbHMvdW5oYW5kbGUuanMnO1xuY29uc3QgcmVlbnRyeSA9IFN5bWJvbCgncmVlbnRyeScpO1xuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcbmV4cG9ydCBjbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IodGhyZXNob2xkLCBldmVudCkge1xuICAgICAgICBzdXBlcihgVGltZW91dCBhd2FpdGluZyAnJHtldmVudH0nIGZvciAke3RocmVzaG9sZH1tc2ApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZXZlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG4gICAgICAgIHRoaXMuY29kZSA9ICdFVElNRURPVVQnO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRpbWVkT3V0KHJlcXVlc3QsIGRlbGF5cywgb3B0aW9ucykge1xuICAgIGlmIChyZWVudHJ5IGluIHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIHJlcXVlc3RbcmVlbnRyeV0gPSB0cnVlO1xuICAgIGNvbnN0IGNhbmNlbGVycyA9IFtdO1xuICAgIGNvbnN0IHsgb25jZSwgdW5oYW5kbGVBbGwgfSA9IHVuaGFuZGxlcigpO1xuICAgIGNvbnN0IGFkZFRpbWVvdXQgPSAoZGVsYXksIGNhbGxiYWNrLCBldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXksIGRlbGF5LCBldmVudCk7XG4gICAgICAgIHRpbWVvdXQudW5yZWY/LigpO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICAgIGNhbmNlbGVycy5wdXNoKGNhbmNlbCk7XG4gICAgICAgIHJldHVybiBjYW5jZWw7XG4gICAgfTtcbiAgICBjb25zdCB7IGhvc3QsIGhvc3RuYW1lIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRpbWVvdXRIYW5kbGVyID0gKGRlbGF5LCBldmVudCkgPT4ge1xuICAgICAgICByZXF1ZXN0LmRlc3Ryb3kobmV3IFRpbWVvdXRFcnJvcihkZWxheSwgZXZlbnQpKTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbmNlbFRpbWVvdXRzID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNhbmNlbCBvZiBjYW5jZWxlcnMpIHtcbiAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHVuaGFuZGxlQWxsKCk7XG4gICAgfTtcbiAgICByZXF1ZXN0Lm9uY2UoJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgICBjYW5jZWxUaW1lb3V0cygpO1xuICAgICAgICAvLyBTYXZlIG9yaWdpbmFsIGJlaGF2aW9yXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChyZXF1ZXN0Lmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBkZWxheXMucmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgY2FuY2VsVGltZW91dCA9IGFkZFRpbWVvdXQoZGVsYXlzLnJlcXVlc3QsIHRpbWVvdXRIYW5kbGVyLCAncmVxdWVzdCcpO1xuICAgICAgICBvbmNlKHJlcXVlc3QsICdyZXNwb25zZScsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgb25jZShyZXNwb25zZSwgJ2VuZCcsIGNhbmNlbFRpbWVvdXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkZWxheXMuc29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCB7IHNvY2tldCB9ID0gZGVsYXlzO1xuICAgICAgICBjb25zdCBzb2NrZXRUaW1lb3V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRpbWVvdXRIYW5kbGVyKHNvY2tldCwgJ3NvY2tldCcpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LnNldFRpbWVvdXQoc29ja2V0LCBzb2NrZXRUaW1lb3V0SGFuZGxlcik7XG4gICAgICAgIC8vIGByZXF1ZXN0LnNldFRpbWVvdXQoMClgIGNhdXNlcyBhIG1lbW9yeSBsZWFrLlxuICAgICAgICAvLyBXZSBjYW4ganVzdCByZW1vdmUgdGhlIGxpc3RlbmVyIGFuZCBmb3JnZXQgYWJvdXQgdGhlIHRpbWVyIC0gaXQncyB1bnJlZmZlZC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZ290L2lzc3Vlcy82OTBcbiAgICAgICAgY2FuY2VsZXJzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndGltZW91dCcsIHNvY2tldFRpbWVvdXRIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGhhc0xvb2t1cCA9IHR5cGVvZiBkZWxheXMubG9va3VwICE9PSAndW5kZWZpbmVkJztcbiAgICBjb25zdCBoYXNDb25uZWN0ID0gdHlwZW9mIGRlbGF5cy5jb25uZWN0ICE9PSAndW5kZWZpbmVkJztcbiAgICBjb25zdCBoYXNTZWN1cmVDb25uZWN0ID0gdHlwZW9mIGRlbGF5cy5zZWN1cmVDb25uZWN0ICE9PSAndW5kZWZpbmVkJztcbiAgICBjb25zdCBoYXNTZW5kID0gdHlwZW9mIGRlbGF5cy5zZW5kICE9PSAndW5kZWZpbmVkJztcbiAgICBpZiAoaGFzTG9va3VwIHx8IGhhc0Nvbm5lY3QgfHwgaGFzU2VjdXJlQ29ubmVjdCB8fCBoYXNTZW5kKSB7XG4gICAgICAgIG9uY2UocmVxdWVzdCwgJ3NvY2tldCcsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc29ja2V0UGF0aCB9ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBoYXJkIHRvIHRlc3QgKi9cbiAgICAgICAgICAgIGlmIChzb2NrZXQuY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1BhdGggPSBCb29sZWFuKHNvY2tldFBhdGggPz8gbmV0LmlzSVAoaG9zdG5hbWUgPz8gaG9zdCA/PyAnJykgIT09IDApO1xuICAgICAgICAgICAgICAgIGlmIChoYXNMb29rdXAgJiYgIWhhc1BhdGggJiYgdHlwZW9mIHNvY2tldC5hZGRyZXNzKCkuYWRkcmVzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsVGltZW91dCA9IGFkZFRpbWVvdXQoZGVsYXlzLmxvb2t1cCwgdGltZW91dEhhbmRsZXIsICdsb29rdXAnKTtcbiAgICAgICAgICAgICAgICAgICAgb25jZShzb2NrZXQsICdsb29rdXAnLCBjYW5jZWxUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc0Nvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZUNvbm5lY3QgPSAoKSA9PiBhZGRUaW1lb3V0KGRlbGF5cy5jb25uZWN0LCB0aW1lb3V0SGFuZGxlciwgJ2Nvbm5lY3QnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1BhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2Uoc29ja2V0LCAnY29ubmVjdCcsIHRpbWVDb25uZWN0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25jZShzb2NrZXQsICdsb29rdXAnLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jZShzb2NrZXQsICdjb25uZWN0JywgdGltZUNvbm5lY3QoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NlY3VyZUNvbm5lY3QgJiYgb3B0aW9ucy5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgICAgICAgICAgb25jZShzb2NrZXQsICdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsVGltZW91dCA9IGFkZFRpbWVvdXQoZGVsYXlzLnNlY3VyZUNvbm5lY3QsIHRpbWVvdXRIYW5kbGVyLCAnc2VjdXJlQ29ubmVjdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25jZShzb2NrZXQsICdzZWN1cmVDb25uZWN0JywgY2FuY2VsVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNTZW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZVJlcXVlc3QgPSAoKSA9PiBhZGRUaW1lb3V0KGRlbGF5cy5zZW5kLCB0aW1lb3V0SGFuZGxlciwgJ3NlbmQnKTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaGFyZCB0byB0ZXN0ICovXG4gICAgICAgICAgICAgICAgaWYgKHNvY2tldC5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2Uoc29ja2V0LCAnY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2UocmVxdWVzdCwgJ3VwbG9hZC1jb21wbGV0ZScsIHRpbWVSZXF1ZXN0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2UocmVxdWVzdCwgJ3VwbG9hZC1jb21wbGV0ZScsIHRpbWVSZXF1ZXN0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGVsYXlzLnJlc3BvbnNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvbmNlKHJlcXVlc3QsICd1cGxvYWQtY29tcGxldGUnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxUaW1lb3V0ID0gYWRkVGltZW91dChkZWxheXMucmVzcG9uc2UsIHRpbWVvdXRIYW5kbGVyLCAncmVzcG9uc2UnKTtcbiAgICAgICAgICAgIG9uY2UocmVxdWVzdCwgJ3Jlc3BvbnNlJywgY2FuY2VsVGltZW91dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRlbGF5cy5yZWFkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvbmNlKHJlcXVlc3QsICdyZXNwb25zZScsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsVGltZW91dCA9IGFkZFRpbWVvdXQoZGVsYXlzLnJlYWQsIHRpbWVvdXRIYW5kbGVyLCAncmVhZCcpO1xuICAgICAgICAgICAgb25jZShyZXNwb25zZSwgJ2VuZCcsIGNhbmNlbFRpbWVvdXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmNlbFRpbWVvdXRzO1xufVxuIiwiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnbm9kZTpidWZmZXInO1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAnbm9kZTp1dGlsJztcbmltcG9ydCBpcyBmcm9tICdAc2luZHJlc29yaHVzL2lzJztcbmltcG9ydCBpc0Zvcm1EYXRhIGZyb20gJy4vaXMtZm9ybS1kYXRhLmpzJztcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGdldEJvZHlTaXplKGJvZHksIGhlYWRlcnMpIHtcbiAgICBpZiAoaGVhZGVycyAmJiAnY29udGVudC1sZW5ndGgnIGluIGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcihoZWFkZXJzWydjb250ZW50LWxlbmd0aCddKTtcbiAgICB9XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoaXMuc3RyaW5nKGJvZHkpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChib2R5KTtcbiAgICB9XG4gICAgaWYgKGlzLmJ1ZmZlcihib2R5KSkge1xuICAgICAgICByZXR1cm4gYm9keS5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChpc0Zvcm1EYXRhKGJvZHkpKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNpZnkoYm9keS5nZXRMZW5ndGguYmluZChib2R5KSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbiIsImZ1bmN0aW9uIGlzQ2xpZW50UmVxdWVzdChjbGllbnRSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIGNsaWVudFJlcXVlc3Qud3JpdGFibGUgJiYgIWNsaWVudFJlcXVlc3Qud3JpdGFibGVFbmRlZDtcbn1cbmV4cG9ydCBkZWZhdWx0IGlzQ2xpZW50UmVxdWVzdDtcbiIsImltcG9ydCBpcyBmcm9tICdAc2luZHJlc29yaHVzL2lzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzRm9ybURhdGEoYm9keSkge1xuICAgIHJldHVybiBpcy5ub2RlU3RyZWFtKGJvZHkpICYmIGlzLmZ1bmN0aW9uXyhib2R5LmdldEJvdW5kYXJ5KTtcbn1cbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVW5peFNvY2tldFVSTCh1cmwpIHtcbiAgICByZXR1cm4gdXJsLnByb3RvY29sID09PSAndW5peDonIHx8IHVybC5ob3N0bmFtZSA9PT0gJ3VuaXgnO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJveHlFdmVudHMoZnJvbSwgdG8sIGV2ZW50cykge1xuICAgIGNvbnN0IGV2ZW50RnVuY3Rpb25zID0ge307XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgY29uc3QgZXZlbnRGdW5jdGlvbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0by5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnRGdW5jdGlvbnNbZXZlbnRdID0gZXZlbnRGdW5jdGlvbjtcbiAgICAgICAgZnJvbS5vbihldmVudCwgZXZlbnRGdW5jdGlvbik7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW2V2ZW50LCBldmVudEZ1bmN0aW9uXSBvZiBPYmplY3QuZW50cmllcyhldmVudEZ1bmN0aW9ucykpIHtcbiAgICAgICAgICAgIGZyb20ub2ZmKGV2ZW50LCBldmVudEZ1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4iLCIvLyBXaGVuIGF0dGFjaGluZyBsaXN0ZW5lcnMsIGl0J3MgdmVyeSBlYXN5IHRvIGZvcmdldCBhYm91dCB0aGVtLlxuLy8gRXNwZWNpYWxseSBpZiB5b3UgZG8gZXJyb3IgaGFuZGxpbmcgYW5kIHNldCB0aW1lb3V0cy5cbi8vIFNvIGluc3RlYWQgb2YgY2hlY2tpbmcgaWYgaXQncyBwcm9wZXIgdG8gdGhyb3cgYW4gZXJyb3Igb24gZXZlcnkgdGltZW91dCBldmVyLFxuLy8gdXNlIHRoaXMgc2ltcGxlIHRvb2wgd2hpY2ggd2lsbCByZW1vdmUgYWxsIGxpc3RlbmVycyB5b3UgaGF2ZSBhdHRhY2hlZC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVuaGFuZGxlKCkge1xuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb25jZShvcmlnaW4sIGV2ZW50LCBmbikge1xuICAgICAgICAgICAgb3JpZ2luLm9uY2UoZXZlbnQsIGZuKTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2goeyBvcmlnaW4sIGV2ZW50LCBmbiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5oYW5kbGVBbGwoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9yaWdpbiwgZXZlbnQsIGZuIH0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgIG9yaWdpbi5yZW1vdmVMaXN0ZW5lcihldmVudCwgZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuIiwiaW1wb3J0IGlzIGZyb20gJ0BzaW5kcmVzb3JodXMvaXMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXJsVG9PcHRpb25zKHVybCkge1xuICAgIC8vIENhc3QgdG8gVVJMXG4gICAgdXJsID0gdXJsO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHByb3RvY29sOiB1cmwucHJvdG9jb2wsXG4gICAgICAgIGhvc3RuYW1lOiBpcy5zdHJpbmcodXJsLmhvc3RuYW1lKSAmJiB1cmwuaG9zdG5hbWUuc3RhcnRzV2l0aCgnWycpID8gdXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKSA6IHVybC5ob3N0bmFtZSxcbiAgICAgICAgaG9zdDogdXJsLmhvc3QsXG4gICAgICAgIGhhc2g6IHVybC5oYXNoLFxuICAgICAgICBzZWFyY2g6IHVybC5zZWFyY2gsXG4gICAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgICAgIGhyZWY6IHVybC5ocmVmLFxuICAgICAgICBwYXRoOiBgJHt1cmwucGF0aG5hbWUgfHwgJyd9JHt1cmwuc2VhcmNoIHx8ICcnfWAsXG4gICAgfTtcbiAgICBpZiAoaXMuc3RyaW5nKHVybC5wb3J0KSAmJiB1cmwucG9ydC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9wdGlvbnMucG9ydCA9IE51bWJlcih1cmwucG9ydCk7XG4gICAgfVxuICAgIGlmICh1cmwudXNlcm5hbWUgfHwgdXJsLnBhc3N3b3JkKSB7XG4gICAgICAgIG9wdGlvbnMuYXV0aCA9IGAke3VybC51c2VybmFtZSB8fCAnJ306JHt1cmwucGFzc3dvcmQgfHwgJyd9YDtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBXZWFrYWJsZU1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndlYWtNYXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWFwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud2Vha01hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMud2Vha01hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYWtNYXAuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldChrZXkpO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2Vha01hcC5oYXMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGtleSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IGlzLCB7IGFzc2VydCB9IGZyb20gJ0BzaW5kcmVzb3JodXMvaXMnO1xuaW1wb3J0IGFzUHJvbWlzZSBmcm9tICcuL2FzLXByb21pc2UvaW5kZXguanMnO1xuaW1wb3J0IFJlcXVlc3QgZnJvbSAnLi9jb3JlL2luZGV4LmpzJztcbmltcG9ydCBPcHRpb25zIGZyb20gJy4vY29yZS9vcHRpb25zLmpzJztcbi8vIFRoZSBgZGVsYXlgIHBhY2thZ2Ugd2VpZ2hzIDEwS0IgKCEpXG5jb25zdCBkZWxheSA9IGFzeW5jIChtcykgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCBtcyk7XG59KTtcbmNvbnN0IGlzR290SW5zdGFuY2UgPSAodmFsdWUpID0+IGlzLmZ1bmN0aW9uXyh2YWx1ZSk7XG5jb25zdCBhbGlhc2VzID0gW1xuICAgICdnZXQnLFxuICAgICdwb3N0JyxcbiAgICAncHV0JyxcbiAgICAncGF0Y2gnLFxuICAgICdoZWFkJyxcbiAgICAnZGVsZXRlJyxcbl07XG5jb25zdCBjcmVhdGUgPSAoZGVmYXVsdHMpID0+IHtcbiAgICBkZWZhdWx0cyA9IHtcbiAgICAgICAgb3B0aW9uczogbmV3IE9wdGlvbnModW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmF1bHRzLm9wdGlvbnMpLFxuICAgICAgICBoYW5kbGVyczogWy4uLmRlZmF1bHRzLmhhbmRsZXJzXSxcbiAgICAgICAgbXV0YWJsZURlZmF1bHRzOiBkZWZhdWx0cy5tdXRhYmxlRGVmYXVsdHMsXG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVmYXVsdHMsICdtdXRhYmxlRGVmYXVsdHMnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9KTtcbiAgICAvLyBHb3QgaW50ZXJmYWNlXG4gICAgY29uc3QgZ290ID0gKCh1cmwsIG9wdGlvbnMsIGRlZmF1bHRPcHRpb25zID0gZGVmYXVsdHMub3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCBvcHRpb25zLCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgICAgIGxldCBwcm9taXNlO1xuICAgICAgICBjb25zdCBsYXN0SGFuZGxlciA9IChub3JtYWxpemVkKSA9PiB7XG4gICAgICAgICAgICAvLyBOb3RlOiBgb3B0aW9uc2AgaXMgYHVuZGVmaW5lZGAgd2hlbiBgbmV3IE9wdGlvbnMoLi4uKWAgZmFpbHNcbiAgICAgICAgICAgIHJlcXVlc3Qub3B0aW9ucyA9IG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICByZXF1ZXN0Ll9ub1BpcGUgPSAhbm9ybWFsaXplZC5pc1N0cmVhbTtcbiAgICAgICAgICAgIHZvaWQgcmVxdWVzdC5mbHVzaCgpO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQuaXNTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSBhc1Byb21pc2UocmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGl0ZXJhdGlvbiA9IDA7XG4gICAgICAgIGNvbnN0IGl0ZXJhdGVIYW5kbGVycyA9IChuZXdPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gZGVmYXVsdHMuaGFuZGxlcnNbaXRlcmF0aW9uKytdID8/IGxhc3RIYW5kbGVyO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaGFuZGxlcihuZXdPcHRpb25zLCBpdGVyYXRlSGFuZGxlcnMpO1xuICAgICAgICAgICAgaWYgKGlzLnByb21pc2UocmVzdWx0KSAmJiAhcmVxdWVzdC5vcHRpb25zLmlzU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBhc1Byb21pc2UocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkZXNjcmlwdG9yc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBkZXNjcmlwdG9ycyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jYW5jZWwgPSBwcm9taXNlLmNhbmNlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0ZUhhbmRsZXJzKHJlcXVlc3Qub3B0aW9ucyk7XG4gICAgfSk7XG4gICAgZ290LmV4dGVuZCA9ICguLi5pbnN0YW5jZXNPck9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG5ldyBPcHRpb25zKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZhdWx0cy5vcHRpb25zKTtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBbLi4uZGVmYXVsdHMuaGFuZGxlcnNdO1xuICAgICAgICBsZXQgbXV0YWJsZURlZmF1bHRzO1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGluc3RhbmNlc09yT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGlzR290SW5zdGFuY2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXJnZSh2YWx1ZS5kZWZhdWx0cy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKC4uLnZhbHVlLmRlZmF1bHRzLmhhbmRsZXJzKTtcbiAgICAgICAgICAgICAgICBtdXRhYmxlRGVmYXVsdHMgPSB2YWx1ZS5kZWZhdWx0cy5tdXRhYmxlRGVmYXVsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lcmdlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMucHVzaCguLi52YWx1ZS5oYW5kbGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG11dGFibGVEZWZhdWx0cyA9IHZhbHVlLm11dGFibGVEZWZhdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlKHtcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBoYW5kbGVycyxcbiAgICAgICAgICAgIG11dGFibGVEZWZhdWx0czogQm9vbGVhbihtdXRhYmxlRGVmYXVsdHMpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFBhZ2luYXRpb25cbiAgICBjb25zdCBwYWdpbmF0ZUVhY2ggPSAoYXN5bmMgZnVuY3Rpb24qICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRPcHRpb25zID0gbmV3IE9wdGlvbnModXJsLCBvcHRpb25zLCBkZWZhdWx0cy5vcHRpb25zKTtcbiAgICAgICAgbm9ybWFsaXplZE9wdGlvbnMucmVzb2x2ZUJvZHlPbmx5ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgcGFnaW5hdGlvbiB9ID0gbm9ybWFsaXplZE9wdGlvbnM7XG4gICAgICAgIGFzc2VydC5mdW5jdGlvbl8ocGFnaW5hdGlvbi50cmFuc2Zvcm0pO1xuICAgICAgICBhc3NlcnQuZnVuY3Rpb25fKHBhZ2luYXRpb24uc2hvdWxkQ29udGludWUpO1xuICAgICAgICBhc3NlcnQuZnVuY3Rpb25fKHBhZ2luYXRpb24uZmlsdGVyKTtcbiAgICAgICAgYXNzZXJ0LmZ1bmN0aW9uXyhwYWdpbmF0aW9uLnBhZ2luYXRlKTtcbiAgICAgICAgYXNzZXJ0Lm51bWJlcihwYWdpbmF0aW9uLmNvdW50TGltaXQpO1xuICAgICAgICBhc3NlcnQubnVtYmVyKHBhZ2luYXRpb24ucmVxdWVzdExpbWl0KTtcbiAgICAgICAgYXNzZXJ0Lm51bWJlcihwYWdpbmF0aW9uLmJhY2tvZmYpO1xuICAgICAgICBjb25zdCBhbGxJdGVtcyA9IFtdO1xuICAgICAgICBsZXQgeyBjb3VudExpbWl0IH0gPSBwYWdpbmF0aW9uO1xuICAgICAgICBsZXQgbnVtYmVyT2ZSZXF1ZXN0cyA9IDA7XG4gICAgICAgIHdoaWxlIChudW1iZXJPZlJlcXVlc3RzIDwgcGFnaW5hdGlvbi5yZXF1ZXN0TGltaXQpIHtcbiAgICAgICAgICAgIGlmIChudW1iZXJPZlJlcXVlc3RzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgICAgICBhd2FpdCBkZWxheShwYWdpbmF0aW9uLmJhY2tvZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IGdvdCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgbm9ybWFsaXplZE9wdGlvbnMpKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBhd2FpdCBwYWdpbmF0aW9uLnRyYW5zZm9ybShyZXNwb25zZSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SXRlbXMgPSBbXTtcbiAgICAgICAgICAgIGFzc2VydC5hcnJheShwYXJzZWQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHBhcnNlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYWdpbmF0aW9uLmZpbHRlcih7IGl0ZW0sIGN1cnJlbnRJdGVtcywgYWxsSXRlbXMgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYWdpbmF0aW9uLnNob3VsZENvbnRpbnVlKHsgaXRlbSwgY3VycmVudEl0ZW1zLCBhbGxJdGVtcyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWdpbmF0aW9uLnN0YWNrQWxsSXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWNvdW50TGltaXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3B0aW9uc1RvTWVyZ2UgPSBwYWdpbmF0aW9uLnBhZ2luYXRlKHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50SXRlbXMsXG4gICAgICAgICAgICAgICAgYWxsSXRlbXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zVG9NZXJnZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9uc1RvTWVyZ2UgPT09IHJlc3BvbnNlLnJlcXVlc3Qub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRPcHRpb25zID0gcmVzcG9uc2UucmVxdWVzdC5vcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZE9wdGlvbnMubWVyZ2Uob3B0aW9uc1RvTWVyZ2UpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5hbnkoW2lzLnVybEluc3RhbmNlLCBpcy51bmRlZmluZWRdLCBvcHRpb25zVG9NZXJnZS51cmwpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zVG9NZXJnZS51cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkT3B0aW9ucy5wcmVmaXhVcmwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZE9wdGlvbnMudXJsID0gb3B0aW9uc1RvTWVyZ2UudXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bWJlck9mUmVxdWVzdHMrKztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGdvdC5wYWdpbmF0ZSA9IHBhZ2luYXRlRWFjaDtcbiAgICBnb3QucGFnaW5hdGUuYWxsID0gKGFzeW5jICh1cmwsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgcGFnaW5hdGVFYWNoKHVybCwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KTtcbiAgICAvLyBGb3IgdGhvc2Ugd2hvIGxpa2UgdmVyeSBkZXNjcmlwdGl2ZSBuYW1lc1xuICAgIGdvdC5wYWdpbmF0ZS5lYWNoID0gcGFnaW5hdGVFYWNoO1xuICAgIC8vIFN0cmVhbSBBUElcbiAgICBnb3Quc3RyZWFtID0gKCh1cmwsIG9wdGlvbnMpID0+IGdvdCh1cmwsIHsgLi4ub3B0aW9ucywgaXNTdHJlYW06IHRydWUgfSkpO1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIGFsaWFzZXMpIHtcbiAgICAgICAgZ290W21ldGhvZF0gPSAoKHVybCwgb3B0aW9ucykgPT4gZ290KHVybCwgeyAuLi5vcHRpb25zLCBtZXRob2QgfSkpO1xuICAgICAgICBnb3Quc3RyZWFtW21ldGhvZF0gPSAoKHVybCwgb3B0aW9ucykgPT4gZ290KHVybCwgeyAuLi5vcHRpb25zLCBtZXRob2QsIGlzU3RyZWFtOiB0cnVlIH0pKTtcbiAgICB9XG4gICAgaWYgKCFkZWZhdWx0cy5tdXRhYmxlRGVmYXVsdHMpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShkZWZhdWx0cy5oYW5kbGVycyk7XG4gICAgICAgIGRlZmF1bHRzLm9wdGlvbnMuZnJlZXplKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnb3QsICdkZWZhdWx0cycsIHtcbiAgICAgICAgdmFsdWU6IGRlZmF1bHRzLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfSk7XG4gICAgcmV0dXJuIGdvdDtcbn07XG5leHBvcnQgZGVmYXVsdCBjcmVhdGU7XG4iLCJpbXBvcnQgY3JlYXRlIGZyb20gJy4vY3JlYXRlLmpzJztcbmltcG9ydCBPcHRpb25zIGZyb20gJy4vY29yZS9vcHRpb25zLmpzJztcbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIG9wdGlvbnM6IG5ldyBPcHRpb25zKCksXG4gICAgaGFuZGxlcnM6IFtdLFxuICAgIG11dGFibGVEZWZhdWx0czogZmFsc2UsXG59O1xuY29uc3QgZ290ID0gY3JlYXRlKGRlZmF1bHRzKTtcbmV4cG9ydCBkZWZhdWx0IGdvdDtcbmV4cG9ydCB7IGdvdCB9O1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBPcHRpb25zIH0gZnJvbSAnLi9jb3JlL29wdGlvbnMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL29wdGlvbnMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL3Jlc3BvbnNlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvZXJyb3JzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY2FsY3VsYXRlUmV0cnlEZWxheSB9IGZyb20gJy4vY29yZS9jYWxjdWxhdGUtcmV0cnktZGVsYXkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hcy1wcm9taXNlL3R5cGVzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjcmVhdGUgfSBmcm9tICcuL2NyZWF0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhcnNlTGlua0hlYWRlciB9IGZyb20gJy4vY29yZS9wYXJzZS1saW5rLWhlYWRlci5qcyc7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsb3dlcmNhc2VLZXlzKG9iamVjdCkge1xuXHRyZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9iamVjdCkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXkudG9Mb3dlckNhc2UoKSwgdmFsdWVdKSk7XG59XG4iLCIvLyBXZSBkZWZpbmUgdGhlc2UgbWFudWFsbHkgdG8gZW5zdXJlIHRoZXkncmUgYWx3YXlzIGNvcGllZFxuLy8gZXZlbiBpZiB0aGV5IHdvdWxkIG1vdmUgdXAgdGhlIHByb3RvdHlwZSBjaGFpblxuLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9jbGFzc19odHRwX2luY29taW5nbWVzc2FnZVxuY29uc3Qga25vd25Qcm9wZXJ0aWVzID0gW1xuXHQnYWJvcnRlZCcsXG5cdCdjb21wbGV0ZScsXG5cdCdoZWFkZXJzJyxcblx0J2h0dHBWZXJzaW9uJyxcblx0J2h0dHBWZXJzaW9uTWlub3InLFxuXHQnaHR0cFZlcnNpb25NYWpvcicsXG5cdCdtZXRob2QnLFxuXHQncmF3SGVhZGVycycsXG5cdCdyYXdUcmFpbGVycycsXG5cdCdzZXRUaW1lb3V0Jyxcblx0J3NvY2tldCcsXG5cdCdzdGF0dXNDb2RlJyxcblx0J3N0YXR1c01lc3NhZ2UnLFxuXHQndHJhaWxlcnMnLFxuXHQndXJsJyxcbl07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pbWljUmVzcG9uc2UoZnJvbVN0cmVhbSwgdG9TdHJlYW0pIHtcblx0aWYgKHRvU3RyZWFtLl9yZWFkYWJsZVN0YXRlLmF1dG9EZXN0cm95KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgc2Vjb25kIHN0cmVhbSBtdXN0IGhhdmUgdGhlIGBhdXRvRGVzdHJveWAgb3B0aW9uIHNldCB0byBgZmFsc2VgJyk7XG5cdH1cblxuXHRjb25zdCBmcm9tUHJvcGVydGllcyA9IG5ldyBTZXQoWy4uLk9iamVjdC5rZXlzKGZyb21TdHJlYW0pLCAuLi5rbm93blByb3BlcnRpZXNdKTtcblxuXHRjb25zdCBwcm9wZXJ0aWVzID0ge307XG5cblx0Zm9yIChjb25zdCBwcm9wZXJ0eSBvZiBmcm9tUHJvcGVydGllcykge1xuXHRcdC8vIERvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBwcm9wZXJ0aWVzLlxuXHRcdGlmIChwcm9wZXJ0eSBpbiB0b1N0cmVhbSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0cHJvcGVydGllc1twcm9wZXJ0eV0gPSB7XG5cdFx0XHRnZXQoKSB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gZnJvbVN0cmVhbVtwcm9wZXJ0eV07XG5cdFx0XHRcdGNvbnN0IGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5cblx0XHRcdFx0cmV0dXJuIGlzRnVuY3Rpb24gPyB2YWx1ZS5iaW5kKGZyb21TdHJlYW0pIDogdmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0KHZhbHVlKSB7XG5cdFx0XHRcdGZyb21TdHJlYW1bcHJvcGVydHldID0gdmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0fTtcblx0fVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRvU3RyZWFtLCBwcm9wZXJ0aWVzKTtcblxuXHRmcm9tU3RyZWFtLm9uY2UoJ2Fib3J0ZWQnLCAoKSA9PiB7XG5cdFx0dG9TdHJlYW0uZGVzdHJveSgpO1xuXG5cdFx0dG9TdHJlYW0uZW1pdCgnYWJvcnRlZCcpO1xuXHR9KTtcblxuXHRmcm9tU3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuXHRcdGlmIChmcm9tU3RyZWFtLmNvbXBsZXRlKSB7XG5cdFx0XHRpZiAodG9TdHJlYW0ucmVhZGFibGUpIHtcblx0XHRcdFx0dG9TdHJlYW0ub25jZSgnZW5kJywgKCkgPT4ge1xuXHRcdFx0XHRcdHRvU3RyZWFtLmVtaXQoJ2Nsb3NlJyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG9TdHJlYW0uZW1pdCgnY2xvc2UnKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9TdHJlYW0uZW1pdCgnY2xvc2UnKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiB0b1N0cmVhbTtcbn1cbiIsIi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUklzXG5jb25zdCBEQVRBX1VSTF9ERUZBVUxUX01JTUVfVFlQRSA9ICd0ZXh0L3BsYWluJztcbmNvbnN0IERBVEFfVVJMX0RFRkFVTFRfQ0hBUlNFVCA9ICd1cy1hc2NpaSc7XG5cbmNvbnN0IHRlc3RQYXJhbWV0ZXIgPSAobmFtZSwgZmlsdGVycykgPT4gZmlsdGVycy5zb21lKGZpbHRlciA9PiBmaWx0ZXIgaW5zdGFuY2VvZiBSZWdFeHAgPyBmaWx0ZXIudGVzdChuYW1lKSA6IGZpbHRlciA9PT0gbmFtZSk7XG5cbmNvbnN0IHN1cHBvcnRlZFByb3RvY29scyA9IG5ldyBTZXQoW1xuXHQnaHR0cHM6Jyxcblx0J2h0dHA6Jyxcblx0J2ZpbGU6Jyxcbl0pO1xuXG5jb25zdCBoYXNDdXN0b21Qcm90b2NvbCA9IHVybFN0cmluZyA9PiB7XG5cdHRyeSB7XG5cdFx0Y29uc3Qge3Byb3RvY29sfSA9IG5ldyBVUkwodXJsU3RyaW5nKTtcblx0XHRyZXR1cm4gcHJvdG9jb2wuZW5kc1dpdGgoJzonKSAmJiAhc3VwcG9ydGVkUHJvdG9jb2xzLmhhcyhwcm90b2NvbCk7XG5cdH0gY2F0Y2gge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxuY29uc3Qgbm9ybWFsaXplRGF0YVVSTCA9ICh1cmxTdHJpbmcsIHtzdHJpcEhhc2h9KSA9PiB7XG5cdGNvbnN0IG1hdGNoID0gL15kYXRhOig/PHR5cGU+W14sXSo/KSwoPzxkYXRhPlteI10qPykoPzojKD88aGFzaD4uKikpPyQvLmV4ZWModXJsU3RyaW5nKTtcblxuXHRpZiAoIW1hdGNoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHt1cmxTdHJpbmd9YCk7XG5cdH1cblxuXHRsZXQge3R5cGUsIGRhdGEsIGhhc2h9ID0gbWF0Y2guZ3JvdXBzO1xuXHRjb25zdCBtZWRpYVR5cGUgPSB0eXBlLnNwbGl0KCc7Jyk7XG5cdGhhc2ggPSBzdHJpcEhhc2ggPyAnJyA6IGhhc2g7XG5cblx0bGV0IGlzQmFzZTY0ID0gZmFsc2U7XG5cdGlmIChtZWRpYVR5cGVbbWVkaWFUeXBlLmxlbmd0aCAtIDFdID09PSAnYmFzZTY0Jykge1xuXHRcdG1lZGlhVHlwZS5wb3AoKTtcblx0XHRpc0Jhc2U2NCA9IHRydWU7XG5cdH1cblxuXHQvLyBMb3dlcmNhc2UgTUlNRSB0eXBlXG5cdGNvbnN0IG1pbWVUeXBlID0gbWVkaWFUeXBlLnNoaWZ0KCk/LnRvTG93ZXJDYXNlKCkgPz8gJyc7XG5cdGNvbnN0IGF0dHJpYnV0ZXMgPSBtZWRpYVR5cGVcblx0XHQubWFwKGF0dHJpYnV0ZSA9PiB7XG5cdFx0XHRsZXQgW2tleSwgdmFsdWUgPSAnJ10gPSBhdHRyaWJ1dGUuc3BsaXQoJz0nKS5tYXAoc3RyaW5nID0+IHN0cmluZy50cmltKCkpO1xuXG5cdFx0XHQvLyBMb3dlcmNhc2UgYGNoYXJzZXRgXG5cdFx0XHRpZiAoa2V5ID09PSAnY2hhcnNldCcpIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gREFUQV9VUkxfREVGQVVMVF9DSEFSU0VUKSB7XG5cdFx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBgJHtrZXl9JHt2YWx1ZSA/IGA9JHt2YWx1ZX1gIDogJyd9YDtcblx0XHR9KVxuXHRcdC5maWx0ZXIoQm9vbGVhbik7XG5cblx0Y29uc3Qgbm9ybWFsaXplZE1lZGlhVHlwZSA9IFtcblx0XHQuLi5hdHRyaWJ1dGVzLFxuXHRdO1xuXG5cdGlmIChpc0Jhc2U2NCkge1xuXHRcdG5vcm1hbGl6ZWRNZWRpYVR5cGUucHVzaCgnYmFzZTY0Jyk7XG5cdH1cblxuXHRpZiAobm9ybWFsaXplZE1lZGlhVHlwZS5sZW5ndGggPiAwIHx8IChtaW1lVHlwZSAmJiBtaW1lVHlwZSAhPT0gREFUQV9VUkxfREVGQVVMVF9NSU1FX1RZUEUpKSB7XG5cdFx0bm9ybWFsaXplZE1lZGlhVHlwZS51bnNoaWZ0KG1pbWVUeXBlKTtcblx0fVxuXG5cdHJldHVybiBgZGF0YToke25vcm1hbGl6ZWRNZWRpYVR5cGUuam9pbignOycpfSwke2lzQmFzZTY0ID8gZGF0YS50cmltKCkgOiBkYXRhfSR7aGFzaCA/IGAjJHtoYXNofWAgOiAnJ31gO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplVXJsKHVybFN0cmluZywgb3B0aW9ucykge1xuXHRvcHRpb25zID0ge1xuXHRcdGRlZmF1bHRQcm90b2NvbDogJ2h0dHAnLFxuXHRcdG5vcm1hbGl6ZVByb3RvY29sOiB0cnVlLFxuXHRcdGZvcmNlSHR0cDogZmFsc2UsXG5cdFx0Zm9yY2VIdHRwczogZmFsc2UsXG5cdFx0c3RyaXBBdXRoZW50aWNhdGlvbjogdHJ1ZSxcblx0XHRzdHJpcEhhc2g6IGZhbHNlLFxuXHRcdHN0cmlwVGV4dEZyYWdtZW50OiB0cnVlLFxuXHRcdHN0cmlwV1dXOiB0cnVlLFxuXHRcdHJlbW92ZVF1ZXJ5UGFyYW1ldGVyczogWy9edXRtX1xcdysvaV0sXG5cdFx0cmVtb3ZlVHJhaWxpbmdTbGFzaDogdHJ1ZSxcblx0XHRyZW1vdmVTaW5nbGVTbGFzaDogdHJ1ZSxcblx0XHRyZW1vdmVEaXJlY3RvcnlJbmRleDogZmFsc2UsXG5cdFx0cmVtb3ZlRXhwbGljaXRQb3J0OiBmYWxzZSxcblx0XHRzb3J0UXVlcnlQYXJhbWV0ZXJzOiB0cnVlLFxuXHRcdC4uLm9wdGlvbnMsXG5cdH07XG5cblx0Ly8gTGVnYWN5OiBBcHBlbmQgYDpgIHRvIHRoZSBwcm90b2NvbCBpZiBtaXNzaW5nLlxuXHRpZiAodHlwZW9mIG9wdGlvbnMuZGVmYXVsdFByb3RvY29sID09PSAnc3RyaW5nJyAmJiAhb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wuZW5kc1dpdGgoJzonKSkge1xuXHRcdG9wdGlvbnMuZGVmYXVsdFByb3RvY29sID0gYCR7b3B0aW9ucy5kZWZhdWx0UHJvdG9jb2x9OmA7XG5cdH1cblxuXHR1cmxTdHJpbmcgPSB1cmxTdHJpbmcudHJpbSgpO1xuXG5cdC8vIERhdGEgVVJMXG5cdGlmICgvXmRhdGE6L2kudGVzdCh1cmxTdHJpbmcpKSB7XG5cdFx0cmV0dXJuIG5vcm1hbGl6ZURhdGFVUkwodXJsU3RyaW5nLCBvcHRpb25zKTtcblx0fVxuXG5cdGlmIChoYXNDdXN0b21Qcm90b2NvbCh1cmxTdHJpbmcpKSB7XG5cdFx0cmV0dXJuIHVybFN0cmluZztcblx0fVxuXG5cdGNvbnN0IGhhc1JlbGF0aXZlUHJvdG9jb2wgPSB1cmxTdHJpbmcuc3RhcnRzV2l0aCgnLy8nKTtcblx0Y29uc3QgaXNSZWxhdGl2ZVVybCA9ICFoYXNSZWxhdGl2ZVByb3RvY29sICYmIC9eXFwuKlxcLy8udGVzdCh1cmxTdHJpbmcpO1xuXG5cdC8vIFByZXBlbmQgcHJvdG9jb2xcblx0aWYgKCFpc1JlbGF0aXZlVXJsKSB7XG5cdFx0dXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL14oPyEoPzpcXHcrOik/XFwvXFwvKXxeXFwvXFwvLywgb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wpO1xuXHR9XG5cblx0Y29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuXG5cdGlmIChvcHRpb25zLmZvcmNlSHR0cCAmJiBvcHRpb25zLmZvcmNlSHR0cHMpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgZm9yY2VIdHRwYCBhbmQgYGZvcmNlSHR0cHNgIG9wdGlvbnMgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXInKTtcblx0fVxuXG5cdGlmIChvcHRpb25zLmZvcmNlSHR0cCAmJiB1cmxPYmplY3QucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG5cdFx0dXJsT2JqZWN0LnByb3RvY29sID0gJ2h0dHA6Jztcblx0fVxuXG5cdGlmIChvcHRpb25zLmZvcmNlSHR0cHMgJiYgdXJsT2JqZWN0LnByb3RvY29sID09PSAnaHR0cDonKSB7XG5cdFx0dXJsT2JqZWN0LnByb3RvY29sID0gJ2h0dHBzOic7XG5cdH1cblxuXHQvLyBSZW1vdmUgYXV0aFxuXHRpZiAob3B0aW9ucy5zdHJpcEF1dGhlbnRpY2F0aW9uKSB7XG5cdFx0dXJsT2JqZWN0LnVzZXJuYW1lID0gJyc7XG5cdFx0dXJsT2JqZWN0LnBhc3N3b3JkID0gJyc7XG5cdH1cblxuXHQvLyBSZW1vdmUgaGFzaFxuXHRpZiAob3B0aW9ucy5zdHJpcEhhc2gpIHtcblx0XHR1cmxPYmplY3QuaGFzaCA9ICcnO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuc3RyaXBUZXh0RnJhZ21lbnQpIHtcblx0XHR1cmxPYmplY3QuaGFzaCA9IHVybE9iamVjdC5oYXNoLnJlcGxhY2UoLyM/On46dGV4dC4qPyQvaSwgJycpO1xuXHR9XG5cblx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZSBzbGFzaGVzIGlmIG5vdCBwcmVjZWRlZCBieSBhIHByb3RvY29sXG5cdC8vIE5PVEU6IFRoaXMgY291bGQgYmUgaW1wbGVtZW50ZWQgdXNpbmcgYSBzaW5nbGUgbmVnYXRpdmUgbG9va2JlaGluZFxuXHQvLyByZWdleCwgYnV0IHdlIGF2b2lkIHRoYXQgdG8gbWFpbnRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIGpzIGVuZ2luZXNcblx0Ly8gd2hpY2ggZG8gbm90IGhhdmUgc3VwcG9ydCBmb3IgdGhhdCBmZWF0dXJlLlxuXHRpZiAodXJsT2JqZWN0LnBhdGhuYW1lKSB7XG5cdFx0Ly8gVE9ETzogUmVwbGFjZSBldmVyeXRoaW5nIGJlbG93IHdpdGggYHVybE9iamVjdC5wYXRobmFtZSA9IHVybE9iamVjdC5wYXRobmFtZS5yZXBsYWNlKC8oPzwhXFxiW2Etel1bYS16XFxkK1xcLS5dezEsNTB9OilcXC97Mix9L2csICcvJyk7YCB3aGVuIFNhZmFyaSBzdXBwb3J0cyBuZWdhdGl2ZSBsb29rYmVoaW5kLlxuXG5cdFx0Ly8gU3BsaXQgdGhlIHN0cmluZyBieSBvY2N1cnJlbmNlcyBvZiB0aGlzIHByb3RvY29sIHJlZ2V4LCBhbmQgcGVyZm9ybVxuXHRcdC8vIGR1cGxpY2F0ZS1zbGFzaCByZXBsYWNlbWVudCBvbiB0aGUgc3RyaW5ncyBiZXR3ZWVuIHRob3NlIG9jY3VycmVuY2VzXG5cdFx0Ly8gKGlmIGFueSkuXG5cdFx0Y29uc3QgcHJvdG9jb2xSZWdleCA9IC9cXGJbYS16XVthLXpcXGQrXFwtLl17MSw1MH06XFwvXFwvL2c7XG5cblx0XHRsZXQgbGFzdEluZGV4ID0gMDtcblx0XHRsZXQgcmVzdWx0ID0gJyc7XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBwcm90b2NvbFJlZ2V4LmV4ZWModXJsT2JqZWN0LnBhdGhuYW1lKTtcblx0XHRcdGlmICghbWF0Y2gpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHByb3RvY29sID0gbWF0Y2hbMF07XG5cdFx0XHRjb25zdCBwcm90b2NvbEF0SW5kZXggPSBtYXRjaC5pbmRleDtcblx0XHRcdGNvbnN0IGludGVybWVkaWF0ZSA9IHVybE9iamVjdC5wYXRobmFtZS5zbGljZShsYXN0SW5kZXgsIHByb3RvY29sQXRJbmRleCk7XG5cblx0XHRcdHJlc3VsdCArPSBpbnRlcm1lZGlhdGUucmVwbGFjZSgvXFwvezIsfS9nLCAnLycpO1xuXHRcdFx0cmVzdWx0ICs9IHByb3RvY29sO1xuXHRcdFx0bGFzdEluZGV4ID0gcHJvdG9jb2xBdEluZGV4ICsgcHJvdG9jb2wubGVuZ3RoO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJlbW5hbnQgPSB1cmxPYmplY3QucGF0aG5hbWUuc2xpY2UobGFzdEluZGV4LCB1cmxPYmplY3QucGF0aG5hbWUubGVuZ3RoKTtcblx0XHRyZXN1bHQgKz0gcmVtbmFudC5yZXBsYWNlKC9cXC97Mix9L2csICcvJyk7XG5cblx0XHR1cmxPYmplY3QucGF0aG5hbWUgPSByZXN1bHQ7XG5cdH1cblxuXHQvLyBEZWNvZGUgVVJJIG9jdGV0c1xuXHRpZiAodXJsT2JqZWN0LnBhdGhuYW1lKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHVybE9iamVjdC5wYXRobmFtZSA9IGRlY29kZVVSSSh1cmxPYmplY3QucGF0aG5hbWUpO1xuXHRcdH0gY2F0Y2gge31cblx0fVxuXG5cdC8vIFJlbW92ZSBkaXJlY3RvcnkgaW5kZXhcblx0aWYgKG9wdGlvbnMucmVtb3ZlRGlyZWN0b3J5SW5kZXggPT09IHRydWUpIHtcblx0XHRvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4ID0gWy9eaW5kZXhcXC5bYS16XSskL107XG5cdH1cblxuXHRpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4KSAmJiBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4Lmxlbmd0aCA+IDApIHtcblx0XHRsZXQgcGF0aENvbXBvbmVudHMgPSB1cmxPYmplY3QucGF0aG5hbWUuc3BsaXQoJy8nKTtcblx0XHRjb25zdCBsYXN0Q29tcG9uZW50ID0gcGF0aENvbXBvbmVudHNbcGF0aENvbXBvbmVudHMubGVuZ3RoIC0gMV07XG5cblx0XHRpZiAodGVzdFBhcmFtZXRlcihsYXN0Q29tcG9uZW50LCBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4KSkge1xuXHRcdFx0cGF0aENvbXBvbmVudHMgPSBwYXRoQ29tcG9uZW50cy5zbGljZSgwLCAtMSk7XG5cdFx0XHR1cmxPYmplY3QucGF0aG5hbWUgPSBwYXRoQ29tcG9uZW50cy5zbGljZSgxKS5qb2luKCcvJykgKyAnLyc7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHVybE9iamVjdC5ob3N0bmFtZSkge1xuXHRcdC8vIFJlbW92ZSB0cmFpbGluZyBkb3Rcblx0XHR1cmxPYmplY3QuaG9zdG5hbWUgPSB1cmxPYmplY3QuaG9zdG5hbWUucmVwbGFjZSgvXFwuJC8sICcnKTtcblxuXHRcdC8vIFJlbW92ZSBgd3d3LmBcblx0XHRpZiAob3B0aW9ucy5zdHJpcFdXVyAmJiAvXnd3d1xcLig/IXd3d1xcLilbYS16XFwtXFxkXXsxLDYzfVxcLlthLXouXFwtXFxkXXsyLDYzfSQvLnRlc3QodXJsT2JqZWN0Lmhvc3RuYW1lKSkge1xuXHRcdFx0Ly8gRWFjaCBsYWJlbCBzaG91bGQgYmUgbWF4IDYzIGF0IGxlbmd0aCAobWluOiAxKS5cblx0XHRcdC8vIFNvdXJjZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSG9zdG5hbWUjUmVzdHJpY3Rpb25zX29uX3ZhbGlkX2hvc3RfbmFtZXNcblx0XHRcdC8vIEVhY2ggVExEIHNob3VsZCBiZSB1cCB0byA2MyBjaGFyYWN0ZXJzIGxvbmcgKG1pbjogMikuXG5cdFx0XHQvLyBJdCBpcyB0ZWNobmljYWxseSBwb3NzaWJsZSB0byBoYXZlIGEgc2luZ2xlIGNoYXJhY3RlciBUTEQsIGJ1dCBub25lIGN1cnJlbnRseSBleGlzdC5cblx0XHRcdHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgJycpO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSBxdWVyeSB1bndhbnRlZCBwYXJhbWV0ZXJzXG5cdGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzKSkge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLXVzZWxlc3Mtc3ByZWFkIC0tIFdlIGFyZSBpbnRlbnRpb25hbGx5IHNwcmVhZGluZyB0byBnZXQgYSBjb3B5LlxuXHRcdGZvciAoY29uc3Qga2V5IG9mIFsuLi51cmxPYmplY3Quc2VhcmNoUGFyYW1zLmtleXMoKV0pIHtcblx0XHRcdGlmICh0ZXN0UGFyYW1ldGVyKGtleSwgb3B0aW9ucy5yZW1vdmVRdWVyeVBhcmFtZXRlcnMpKSB7XG5cdFx0XHRcdHVybE9iamVjdC5zZWFyY2hQYXJhbXMuZGVsZXRlKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMua2VlcFF1ZXJ5UGFyYW1ldGVycykgJiYgb3B0aW9ucy5yZW1vdmVRdWVyeVBhcmFtZXRlcnMgPT09IHRydWUpIHtcblx0XHR1cmxPYmplY3Quc2VhcmNoID0gJyc7XG5cdH1cblxuXHQvLyBLZWVwIHdhbnRlZCBxdWVyeSBwYXJhbWV0ZXJzXG5cdGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMua2VlcFF1ZXJ5UGFyYW1ldGVycykgJiYgb3B0aW9ucy5rZWVwUXVlcnlQYXJhbWV0ZXJzLmxlbmd0aCA+IDApIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby11c2VsZXNzLXNwcmVhZCAtLSBXZSBhcmUgaW50ZW50aW9uYWxseSBzcHJlYWRpbmcgdG8gZ2V0IGEgY29weS5cblx0XHRmb3IgKGNvbnN0IGtleSBvZiBbLi4udXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5rZXlzKCldKSB7XG5cdFx0XHRpZiAoIXRlc3RQYXJhbWV0ZXIoa2V5LCBvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMpKSB7XG5cdFx0XHRcdHVybE9iamVjdC5zZWFyY2hQYXJhbXMuZGVsZXRlKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU29ydCBxdWVyeSBwYXJhbWV0ZXJzXG5cdGlmIChvcHRpb25zLnNvcnRRdWVyeVBhcmFtZXRlcnMpIHtcblx0XHR1cmxPYmplY3Quc2VhcmNoUGFyYW1zLnNvcnQoKTtcblxuXHRcdC8vIENhbGxpbmcgYC5zb3J0KClgIGVuY29kZXMgdGhlIHNlYXJjaCBwYXJhbWV0ZXJzLCBzbyB3ZSBuZWVkIHRvIGRlY29kZSB0aGVtIGFnYWluLlxuXHRcdHRyeSB7XG5cdFx0XHR1cmxPYmplY3Quc2VhcmNoID0gZGVjb2RlVVJJQ29tcG9uZW50KHVybE9iamVjdC5zZWFyY2gpO1xuXHRcdH0gY2F0Y2gge31cblx0fVxuXG5cdGlmIChvcHRpb25zLnJlbW92ZVRyYWlsaW5nU2xhc2gpIHtcblx0XHR1cmxPYmplY3QucGF0aG5hbWUgPSB1cmxPYmplY3QucGF0aG5hbWUucmVwbGFjZSgvXFwvJC8sICcnKTtcblx0fVxuXG5cdC8vIFJlbW92ZSBhbiBleHBsaWNpdCBwb3J0IG51bWJlciwgZXhjbHVkaW5nIGEgZGVmYXVsdCBwb3J0IG51bWJlciwgaWYgYXBwbGljYWJsZVxuXHRpZiAob3B0aW9ucy5yZW1vdmVFeHBsaWNpdFBvcnQgJiYgdXJsT2JqZWN0LnBvcnQpIHtcblx0XHR1cmxPYmplY3QucG9ydCA9ICcnO1xuXHR9XG5cblx0Y29uc3Qgb2xkVXJsU3RyaW5nID0gdXJsU3RyaW5nO1xuXG5cdC8vIFRha2UgYWR2YW50YWdlIG9mIG1hbnkgb2YgdGhlIE5vZGUgYHVybGAgbm9ybWFsaXphdGlvbnNcblx0dXJsU3RyaW5nID0gdXJsT2JqZWN0LnRvU3RyaW5nKCk7XG5cblx0aWYgKCFvcHRpb25zLnJlbW92ZVNpbmdsZVNsYXNoICYmIHVybE9iamVjdC5wYXRobmFtZSA9PT0gJy8nICYmICFvbGRVcmxTdHJpbmcuZW5kc1dpdGgoJy8nKSAmJiB1cmxPYmplY3QuaGFzaCA9PT0gJycpIHtcblx0XHR1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXFwvJC8sICcnKTtcblx0fVxuXG5cdC8vIFJlbW92ZSBlbmRpbmcgYC9gIHVubGVzcyByZW1vdmVTaW5nbGVTbGFzaCBpcyBmYWxzZVxuXHRpZiAoKG9wdGlvbnMucmVtb3ZlVHJhaWxpbmdTbGFzaCB8fCB1cmxPYmplY3QucGF0aG5hbWUgPT09ICcvJykgJiYgdXJsT2JqZWN0Lmhhc2ggPT09ICcnICYmIG9wdGlvbnMucmVtb3ZlU2luZ2xlU2xhc2gpIHtcblx0XHR1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXFwvJC8sICcnKTtcblx0fVxuXG5cdC8vIFJlc3RvcmUgcmVsYXRpdmUgcHJvdG9jb2wsIGlmIGFwcGxpY2FibGVcblx0aWYgKGhhc1JlbGF0aXZlUHJvdG9jb2wgJiYgIW9wdGlvbnMubm9ybWFsaXplUHJvdG9jb2wpIHtcblx0XHR1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXmh0dHA6XFwvXFwvLywgJy8vJyk7XG5cdH1cblxuXHQvLyBSZW1vdmUgaHR0cC9odHRwc1xuXHRpZiAob3B0aW9ucy5zdHJpcFByb3RvY29sKSB7XG5cdFx0dXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL14oPzpodHRwcz86KT9cXC9cXC8vLCAnJyk7XG5cdH1cblxuXHRyZXR1cm4gdXJsU3RyaW5nO1xufVxuIiwiZXhwb3J0IGNsYXNzIENhbmNlbEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihyZWFzb24pIHtcblx0XHRzdXBlcihyZWFzb24gfHwgJ1Byb21pc2Ugd2FzIGNhbmNlbGVkJyk7XG5cdFx0dGhpcy5uYW1lID0gJ0NhbmNlbEVycm9yJztcblx0fVxuXG5cdGdldCBpc0NhbmNlbGVkKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG5cbi8vIFRPRE86IFVzZSBwcml2YXRlIGNsYXNzIGZpZWxkcyB3aGVuIEVTTGludCA4IGlzIG91dC5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUENhbmNlbGFibGUge1xuXHRzdGF0aWMgZm4odXNlckZ1bmN0aW9uKSB7XG5cdFx0cmV0dXJuICguLi5hcmd1bWVudHNfKSA9PiB7XG5cdFx0XHRyZXR1cm4gbmV3IFBDYW5jZWxhYmxlKChyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKSA9PiB7XG5cdFx0XHRcdGFyZ3VtZW50c18ucHVzaChvbkNhbmNlbCk7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuXG5cdFx0XHRcdHVzZXJGdW5jdGlvbiguLi5hcmd1bWVudHNfKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9XG5cblx0Y29uc3RydWN0b3IoZXhlY3V0b3IpIHtcblx0XHR0aGlzLl9jYW5jZWxIYW5kbGVycyA9IFtdO1xuXHRcdHRoaXMuX2lzUGVuZGluZyA9IHRydWU7XG5cdFx0dGhpcy5faXNDYW5jZWxlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3JlamVjdE9uQ2FuY2VsID0gdHJ1ZTtcblxuXHRcdHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHR0aGlzLl9yZWplY3QgPSByZWplY3Q7XG5cblx0XHRcdGNvbnN0IG9uUmVzb2x2ZSA9IHZhbHVlID0+IHtcblx0XHRcdFx0aWYgKCF0aGlzLl9pc0NhbmNlbGVkIHx8ICFvbkNhbmNlbC5zaG91bGRSZWplY3QpIHtcblx0XHRcdFx0XHR0aGlzLl9pc1BlbmRpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRyZXNvbHZlKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3Qgb25SZWplY3QgPSBlcnJvciA9PiB7XG5cdFx0XHRcdHRoaXMuX2lzUGVuZGluZyA9IGZhbHNlO1xuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3Qgb25DYW5jZWwgPSBoYW5kbGVyID0+IHtcblx0XHRcdFx0aWYgKCF0aGlzLl9pc1BlbmRpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgb25DYW5jZWxgIGhhbmRsZXIgd2FzIGF0dGFjaGVkIGFmdGVyIHRoZSBwcm9taXNlIHNldHRsZWQuJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9jYW5jZWxIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuXHRcdFx0fTtcblxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMob25DYW5jZWwsIHtcblx0XHRcdFx0c2hvdWxkUmVqZWN0OiB7XG5cdFx0XHRcdFx0Z2V0OiAoKSA9PiB0aGlzLl9yZWplY3RPbkNhbmNlbCxcblx0XHRcdFx0XHRzZXQ6IGJvb2xlYW4gPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5fcmVqZWN0T25DYW5jZWwgPSBib29sZWFuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGV4ZWN1dG9yKG9uUmVzb2x2ZSwgb25SZWplY3QsIG9uQ2FuY2VsKTtcblx0XHR9KTtcblx0fVxuXG5cdHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tdGhlblxuXHRcdHJldHVybiB0aGlzLl9wcm9taXNlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuXHR9XG5cblx0Y2F0Y2gob25SZWplY3RlZCkge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuXG5cdFx0cmV0dXJuIHRoaXMuX3Byb21pc2UuY2F0Y2gob25SZWplY3RlZCk7XG5cdH1cblxuXHRmaW5hbGx5KG9uRmluYWxseSkge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuXG5cdFx0cmV0dXJuIHRoaXMuX3Byb21pc2UuZmluYWxseShvbkZpbmFsbHkpO1xuXHR9XG5cblx0Y2FuY2VsKHJlYXNvbikge1xuXHRcdGlmICghdGhpcy5faXNQZW5kaW5nIHx8IHRoaXMuX2lzQ2FuY2VsZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9pc0NhbmNlbGVkID0gdHJ1ZTtcblxuXHRcdGlmICh0aGlzLl9jYW5jZWxIYW5kbGVycy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGhhbmRsZXIgb2YgdGhpcy5fY2FuY2VsSGFuZGxlcnMpIHtcblx0XHRcdFx0XHRoYW5kbGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdHRoaXMuX3JlamVjdChlcnJvcik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5fcmVqZWN0T25DYW5jZWwpIHtcblx0XHRcdHRoaXMuX3JlamVjdChuZXcgQ2FuY2VsRXJyb3IocmVhc29uKSk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IGlzQ2FuY2VsZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzQ2FuY2VsZWQ7XG5cdH1cbn1cblxuT2JqZWN0LnNldFByb3RvdHlwZU9mKFBDYW5jZWxhYmxlLnByb3RvdHlwZSwgUHJvbWlzZS5wcm90b3R5cGUpO1xuIiwiaW1wb3J0IHtSZWFkYWJsZSBhcyBSZWFkYWJsZVN0cmVhbX0gZnJvbSAnbm9kZTpzdHJlYW0nO1xuaW1wb3J0IGxvd2VyY2FzZUtleXMgZnJvbSAnbG93ZXJjYXNlLWtleXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNwb25zZSBleHRlbmRzIFJlYWRhYmxlU3RyZWFtIHtcblx0c3RhdHVzQ29kZTtcblx0aGVhZGVycztcblx0Ym9keTtcblx0dXJsO1xuXG5cdGNvbnN0cnVjdG9yKHtzdGF0dXNDb2RlLCBoZWFkZXJzLCBib2R5LCB1cmx9KSB7XG5cdFx0aWYgKHR5cGVvZiBzdGF0dXNDb2RlICE9PSAnbnVtYmVyJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgYHN0YXR1c0NvZGVgIHNob3VsZCBiZSBhIG51bWJlcicpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgaGVhZGVycyAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IGBoZWFkZXJzYCBzaG91bGQgYmUgYW4gb2JqZWN0Jyk7XG5cdFx0fVxuXG5cdFx0aWYgKCEoYm9keSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBgYm9keWAgc2hvdWxkIGJlIGEgYnVmZmVyJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBgdXJsYCBzaG91bGQgYmUgYSBzdHJpbmcnKTtcblx0XHR9XG5cblx0XHRzdXBlcih7XG5cdFx0XHRyZWFkKCkge1xuXHRcdFx0XHR0aGlzLnB1c2goYm9keSk7XG5cdFx0XHRcdHRoaXMucHVzaChudWxsKTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuXHRcdHRoaXMuaGVhZGVycyA9IGxvd2VyY2FzZUtleXMoaGVhZGVycyk7XG5cdFx0dGhpcy5ib2R5ID0gYm9keTtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0fVxufVxuIiwiaW1wb3J0IHBhdGggZnJvbSAnbm9kZTpwYXRoJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ25vZGU6ZXZlbnRzJztcbmltcG9ydCB7IGNyZWF0ZVJlcXVpcmUgfSBmcm9tICdub2RlOm1vZHVsZSc7XG5pbXBvcnQgbG9nZ2VyIGZyb20gJ0B3ZGlvL2xvZ2dlcic7XG5pbXBvcnQgeyB0cmFuc2Zvcm1Db21tYW5kTG9nUmVzdWx0IH0gZnJvbSAnQHdkaW8vdXRpbHMnO1xuaW1wb3J0IHsgVVJMRmFjdG9yeSB9IGZyb20gJy4vZmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBpc1N1Y2Nlc3NmdWxSZXNwb25zZSwgZ2V0RXJyb3JGcm9tUmVzcG9uc2VCb2R5LCBnZXRUaW1lb3V0RXJyb3IgfSBmcm9tICcuLi91dGlscy5qcyc7XG5jb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuY29uc3QgcGtnID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJyk7XG5leHBvcnQgY2xhc3MgUmVxdWVzdExpYkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIHN0YXR1c0NvZGU7XG4gICAgYm9keTtcbiAgICBjb2RlO1xufVxuY29uc3QgREVGQVVMVF9IRUFERVJTID0ge1xuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOCcsXG4gICAgJ0Nvbm5lY3Rpb24nOiAna2VlcC1hbGl2ZScsXG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAnVXNlci1BZ2VudCc6ICd3ZWJkcml2ZXIvJyArIHBrZy52ZXJzaW9uXG59O1xuY29uc3QgbG9nID0gbG9nZ2VyKCd3ZWJkcml2ZXInKTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkRyaXZlclJlcXVlc3QgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGJvZHk7XG4gICAgbWV0aG9kO1xuICAgIGVuZHBvaW50O1xuICAgIGlzSHViQ29tbWFuZDtcbiAgICByZXF1aXJlc1Nlc3Npb25JZDtcbiAgICBkZWZhdWx0QWdlbnRzO1xuICAgIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBmb2xsb3dSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgIHRocm93SHR0cEVycm9yczogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgZW5kcG9pbnQsIGJvZHksIGlzSHViQ29tbWFuZCA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gICAgICAgIHRoaXMuaXNIdWJDb21tYW5kID0gaXNIdWJDb21tYW5kO1xuICAgICAgICB0aGlzLnJlcXVpcmVzU2Vzc2lvbklkID0gQm9vbGVhbih0aGlzLmVuZHBvaW50Lm1hdGNoKC86c2Vzc2lvbklkLykpO1xuICAgIH1cbiAgICBhc3luYyBtYWtlUmVxdWVzdChvcHRpb25zLCBzZXNzaW9uSWQpIHtcbiAgICAgICAgbGV0IGZ1bGxSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6IHRoaXMubWV0aG9kIH0sIHRoaXMuZGVmYXVsdE9wdGlvbnMsIGF3YWl0IHRoaXMuX2NyZWF0ZU9wdGlvbnMob3B0aW9ucywgc2Vzc2lvbklkKSk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm1SZXF1ZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBmdWxsUmVxdWVzdE9wdGlvbnMgPSBvcHRpb25zLnRyYW5zZm9ybVJlcXVlc3QoZnVsbFJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCBmdWxsUmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChmdWxsUmVxdWVzdE9wdGlvbnMsIG9wdGlvbnMudHJhbnNmb3JtUmVzcG9uc2UsIG9wdGlvbnMuY29ubmVjdGlvblJldHJ5Q291bnQsIDApO1xuICAgIH1cbiAgICBhc3luYyBfY3JlYXRlT3B0aW9ucyhvcHRpb25zLCBzZXNzaW9uSWQsIGlzQnJvd3NlciA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGFnZW50ID0gaXNCcm93c2VyID8gdW5kZWZpbmVkIDogKG9wdGlvbnMuYWdlbnQgfHwgdGhpcy5kZWZhdWx0QWdlbnRzKTtcbiAgICAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gaXNCcm93c2VyID9cbiAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAodHlwZW9mIG9wdGlvbnMucXVlcnlQYXJhbXMgPT09ICdvYmplY3QnID8gb3B0aW9ucy5xdWVyeVBhcmFtcyA6IHt9KTtcbiAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBodHRwczoge30sXG4gICAgICAgICAgICBhZ2VudCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAuLi5ERUZBVUxUX0hFQURFUlMsXG4gICAgICAgICAgICAgICAgLi4uKHR5cGVvZiBvcHRpb25zLmhlYWRlcnMgPT09ICdvYmplY3QnID8gb3B0aW9ucy5oZWFkZXJzIDoge30pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLFxuICAgICAgICAgICAgcmV0cnk6IHsgbGltaXQ6IG9wdGlvbnMuY29ubmVjdGlvblJldHJ5Q291bnQgfSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IHsgcmVzcG9uc2U6IG9wdGlvbnMuY29ubmVjdGlvblJldHJ5VGltZW91dCB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvbmx5IGFwcGx5IGJvZHkgcHJvcGVydHkgaWYgZXhpc3RpbmdcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmJvZHkgJiYgKE9iamVjdC5rZXlzKHRoaXMuYm9keSkubGVuZ3RoIHx8IHRoaXMubWV0aG9kID09PSAnUE9TVCcpKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KSwgJ3V0ZjgnKTtcbiAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLmpzb24gPSB0aGlzLmJvZHk7XG4gICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gYCR7Y29udGVudExlbmd0aH1gO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpZiB3ZSBkb24ndCBoYXZlIGEgc2Vzc2lvbiBpZCB3ZSBzZXQgaXQgaGVyZSwgdW5sZXNzIHdlIGNhbGwgY29tbWFuZHMgdGhhdCBkb24ndCByZXF1aXJlIHNlc3Npb24gaWRzLCBmb3JcbiAgICAgICAgICogZXhhbXBsZSAvc2Vzc2lvbnMuIFRoZSBjYWxsIHRvIC9zZXNzaW9ucyBpcyBub3QgY29ubmVjdGVkIHRvIGEgc2Vzc2lvbiBpdHNlbGYgYW5kIGl0IHRoZXJlZm9yZSBkb2Vzbid0XG4gICAgICAgICAqIHJlcXVpcmUgaXRcbiAgICAgICAgICovXG4gICAgICAgIGxldCBlbmRwb2ludCA9IHRoaXMuZW5kcG9pbnQ7XG4gICAgICAgIGlmICh0aGlzLnJlcXVpcmVzU2Vzc2lvbklkKSB7XG4gICAgICAgICAgICBpZiAoIXNlc3Npb25JZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBzZXNzaW9uSWQgaXMgcmVxdWlyZWQgZm9yIHRoaXMgY29tbWFuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kcG9pbnQgPSBlbmRwb2ludC5yZXBsYWNlKCc6c2Vzc2lvbklkJywgc2Vzc2lvbklkKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0T3B0aW9ucy51cmwgPSBhd2FpdCBVUkxGYWN0b3J5LmdldEluc3RhbmNlKGAke29wdGlvbnMucHJvdG9jb2x9Oi8vYCArXG4gICAgICAgICAgICBgJHtvcHRpb25zLmhvc3RuYW1lfToke29wdGlvbnMucG9ydH1gICtcbiAgICAgICAgICAgICh0aGlzLmlzSHViQ29tbWFuZCA/IHRoaXMuZW5kcG9pbnQgOiBwYXRoLmpvaW4ob3B0aW9ucy5wYXRoIHx8ICcnLCBlbmRwb2ludCkpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlbmQgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMgb25seSB3aGVuIGNyZWF0aW5nIG5ldyBzZXNzaW9uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5lbmRwb2ludCA9PT0gJy9zZXNzaW9uJyAmJiBvcHRpb25zLnVzZXIgJiYgb3B0aW9ucy5rZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnVzZXJuYW1lID0gb3B0aW9ucy51c2VyO1xuICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMucGFzc3dvcmQgPSBvcHRpb25zLmtleTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogaWYgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIFwiU1RSSUNUX1NTTFwiIGlzIGRlZmluZWQgYXMgXCJmYWxzZVwiLCBpdCBkb2Vzbid0IHJlcXVpcmUgU1NMIGNlcnRpZmljYXRlcyB0byBiZSB2YWxpZC5cbiAgICAgICAgICogT3IgdGhlIHJlcXVlc3RPcHRpb25zIGhhcyBzdHJpY3RTU0wgZm9yIGFuIGVudmlyb25tZW50IHdoaWNoIGNhbm5vdCBnZXQgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIGNvcnJlY3RseSBsaWtlIG9uIGFuIEVsZWN0cm9uIGFwcC5cbiAgICAgICAgICovXG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmh0dHBzLnJlamVjdFVuYXV0aG9yaXplZCA9ICEob3B0aW9ucy5zdHJpY3RTU0wgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5TVFJJQ1RfU1NMID09PSAnZmFsc2UnIHx8XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5zdHJpY3Rfc3NsID09PSAnZmFsc2UnKTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RPcHRpb25zO1xuICAgIH1cbiAgICBhc3luYyBfbGliUmVxdWVzdCh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGZ1bmN0aW9uIG11c3QgYmUgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgX2xpYlBlcmZvcm1hbmNlTm93KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZnVuY3Rpb24gbXVzdCBiZSBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICBhc3luYyBfcmVxdWVzdChmdWxsUmVxdWVzdE9wdGlvbnMsIHRyYW5zZm9ybVJlc3BvbnNlLCB0b3RhbFJldHJ5Q291bnQgPSAwLCByZXRyeUNvdW50ID0gMCkge1xuICAgICAgICBsb2cuaW5mbyhgWyR7ZnVsbFJlcXVlc3RPcHRpb25zLm1ldGhvZH1dICR7ZnVsbFJlcXVlc3RPcHRpb25zLnVybC5ocmVmfWApO1xuICAgICAgICBpZiAoZnVsbFJlcXVlc3RPcHRpb25zLmpzb24gJiYgT2JqZWN0LmtleXMoZnVsbFJlcXVlc3RPcHRpb25zLmpzb24pLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nLmluZm8oJ0RBVEEnLCB0cmFuc2Zvcm1Db21tYW5kTG9nUmVzdWx0KGZ1bGxSZXF1ZXN0T3B0aW9ucy5qc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB1cmwsIC4uLnJlcXVlc3RMaWJPcHRpb25zIH0gPSBmdWxsUmVxdWVzdE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHRoaXMuX2xpYlBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2xpYlJlcXVlc3QodXJsLCByZXF1ZXN0TGliT3B0aW9ucylcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiBlcnIpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbk1pbGxpc2Vjb25kID0gdGhpcy5fbGliUGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhhbmRsZSByZXRyaWVzIGZvciByZXF1ZXN0c1xuICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciAgZXJyb3Igb2JqZWN0IHRoYXQgY2F1c2VzIHRoZSByZXRyeVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnICAgbWVzc2FnZSB0aGF0IGlzIGJlaW5nIHNob3duIGFzIHdhcm5pbmcgdG8gdXNlclxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmV0cnkgPSAoZXJyb3IsIG1zZykgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzdG9wIHJldHJ5aW5nIGlmIHRvdGFsUmV0cnlDb3VudCB3YXMgZXhjZWVkZWQgb3IgdGhlcmUgaXMgbm8gcmVhc29uIHRvXG4gICAgICAgICAgICAgKiByZXRyeSwgZS5nLiBpZiBzZXNzaW9uSWQgaXMgaW52YWxpZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAocmV0cnlDb3VudCA+PSB0b3RhbFJldHJ5Q291bnQgfHwgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnaW52YWxpZCBzZXNzaW9uIGlkJykpIHtcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzQ29kZX0gZHVlIHRvICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXNwb25zZScsIHsgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwZXJmb3JtYW5jZScsIHsgcmVxdWVzdDogZnVsbFJlcXVlc3RPcHRpb25zLCBkdXJhdGlvbk1pbGxpc2Vjb25kLCBzdWNjZXNzOiBmYWxzZSwgZXJyb3IsIHJldHJ5Q291bnQgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK3JldHJ5Q291bnQ7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JldHJ5JywgeyBlcnJvciwgcmV0cnlDb3VudCB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncGVyZm9ybWFuY2UnLCB7IHJlcXVlc3Q6IGZ1bGxSZXF1ZXN0T3B0aW9ucywgZHVyYXRpb25NaWxsaXNlY29uZCwgc3VjY2VzczogZmFsc2UsIGVycm9yLCByZXRyeUNvdW50IH0pO1xuICAgICAgICAgICAgbG9nLndhcm4obXNnKTtcbiAgICAgICAgICAgIGxvZy5pbmZvKGBSZXRyeWluZyAke3JldHJ5Q291bnR9LyR7dG90YWxSZXRyeUNvdW50fWApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoZnVsbFJlcXVlc3RPcHRpb25zLCB0cmFuc2Zvcm1SZXNwb25zZSwgdG90YWxSZXRyeUNvdW50LCByZXRyeUNvdW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhhbmRsZSByZXF1ZXN0IGVycm9yc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogaGFuZGxlIHRpbWVvdXRzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5jb2RlID09PSAnRVRJTUVET1VUJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZ2V0VGltZW91dEVycm9yKHJlc3BvbnNlLCBmdWxsUmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRyeShlcnJvciwgJ1JlcXVlc3QgdGltZWQgb3V0ISBDb25zaWRlciBpbmNyZWFzaW5nIHRoZSBcImNvbm5lY3Rpb25SZXRyeVRpbWVvdXRcIiBvcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHRocm93IGlmIHJlcXVlc3QgZXJyb3IgaXMgdW5rbm93blxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3BlcmZvcm1hbmNlJywgeyByZXF1ZXN0OiBmdWxsUmVxdWVzdE9wdGlvbnMsIGR1cmF0aW9uTWlsbGlzZWNvbmQsIHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzcG9uc2UsIHJldHJ5Q291bnQgfSk7XG4gICAgICAgICAgICB0aHJvdyByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybVJlc3BvbnNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IHRyYW5zZm9ybVJlc3BvbnNlKHJlc3BvbnNlLCBmdWxsUmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yID0gZ2V0RXJyb3JGcm9tUmVzcG9uc2VCb2R5KHJlc3BvbnNlLmJvZHksIGZ1bGxSZXF1ZXN0T3B0aW9ucy5qc29uKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHJ5IGNvbm5lY3Rpb24gcmVmdXNlZCBlcnJvcnNcbiAgICAgICAgICovXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnamF2YS5uZXQuQ29ubmVjdEV4Y2VwdGlvbjogQ29ubmVjdGlvbiByZWZ1c2VkOiBjb25uZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5KGVycm9yLCAnQ29ubmVjdGlvbiB0byBTZWxlbml1bSBTdGFuZGFsb25lIHNlcnZlciB3YXMgcmVmdXNlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogaHViIGNvbW1hbmRzIGRvbid0IGZvbGxvdyBzdGFuZGFyZCByZXNwb25zZSBmb3JtYXRzXG4gICAgICAgICAqIGFuZCBjYW4gaGF2ZSBlbXB0eSBib2RpZXNcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmlzSHViQ29tbWFuZCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBpZiBib2R5IGNvbnRhaW5zIEhUTUwgdGhlIGNvbW1hbmQgd2FzIGNhbGxlZCBvbiBhIG5vZGVcbiAgICAgICAgICAgICAqIGRpcmVjdGx5IHdpdGhvdXQgdXNpbmcgYSBodWIsIHRoZXJlZm9yZSB0aHJvd1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmJvZHkgPT09ICdzdHJpbmcnICYmIHJlc3BvbnNlLmJvZHkuc3RhcnRzV2l0aCgnPCFET0NUWVBFIGh0bWw+JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3BlcmZvcm1hbmNlJywgeyByZXF1ZXN0OiBmdWxsUmVxdWVzdE9wdGlvbnMsIGR1cmF0aW9uTWlsbGlzZWNvbmQsIHN1Y2Nlc3M6IGZhbHNlLCBlcnJvciwgcmV0cnlDb3VudCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDb21tYW5kIGNhbiBvbmx5IGJlIGNhbGxlZCB0byBhIFNlbGVuaXVtIEh1YicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXNwb25zZS5ib2R5IHx8IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzb2x2ZSBvbmx5IGlmIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc1N1Y2Nlc3NmdWxSZXNwb25zZShyZXNwb25zZS5zdGF0dXNDb2RlLCByZXNwb25zZS5ib2R5KSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXNwb25zZScsIHsgcmVzdWx0OiByZXNwb25zZS5ib2R5IH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwZXJmb3JtYW5jZScsIHsgcmVxdWVzdDogZnVsbFJlcXVlc3RPcHRpb25zLCBkdXJhdGlvbk1pbGxpc2Vjb25kLCBzdWNjZXNzOiB0cnVlLCByZXRyeUNvdW50IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqICBzdG9wIHJldHJ5aW5nIGFzIHRoaXMgd2lsbCBuZXZlciBiZSBzdWNjZXNzZnVsLlxuICAgICAgICAgKiAgd2Ugd2lsbCBoYW5kbGUgdGhpcyBhdCB0aGUgZWxlbWVudEVycm9ySGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdzdGFsZSBlbGVtZW50IHJlZmVyZW5jZScpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKCdSZXF1ZXN0IGVuY291bnRlcmVkIGEgc3RhbGUgZWxlbWVudCAtIHRlcm1pbmF0aW5nIHJlcXVlc3QnKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVzcG9uc2UnLCB7IGVycm9yIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwZXJmb3JtYW5jZScsIHsgcmVxdWVzdDogZnVsbFJlcXVlc3RPcHRpb25zLCBkdXJhdGlvbk1pbGxpc2Vjb25kLCBzdWNjZXNzOiBmYWxzZSwgZXJyb3IsIHJldHJ5Q291bnQgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0cnkoZXJyb3IsIGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9IGR1ZSB0byAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IGh0dHAgZnJvbSAnbm9kZTpodHRwJztcbmltcG9ydCBodHRwcyBmcm9tICdub2RlOmh0dHBzJztcbmltcG9ydCB7IHBlcmZvcm1hbmNlIH0gZnJvbSAnbm9kZTpwZXJmX2hvb2tzJztcbmltcG9ydCBnb3QgZnJvbSAnZ290JztcbmltcG9ydCBXZWJEcml2ZXJSZXF1ZXN0LCB7IFJlcXVlc3RMaWJFcnJvciB9IGZyb20gJy4vaW5kZXguanMnO1xuY29uc3QgYWdlbnRzID0ge1xuICAgIGh0dHA6IG5ldyBodHRwLkFnZW50KHsga2VlcEFsaXZlOiB0cnVlIH0pLFxuICAgIGh0dHBzOiBuZXcgaHR0cHMuQWdlbnQoeyBrZWVwQWxpdmU6IHRydWUgfSlcbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb2RlSlNSZXF1ZXN0IGV4dGVuZHMgV2ViRHJpdmVyUmVxdWVzdCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBlbmRwb2ludCwgYm9keSwgaXNIdWJDb21tYW5kID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCBlbmRwb2ludCwgYm9keSwgaXNIdWJDb21tYW5kKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0QWdlbnRzID0gYWdlbnRzO1xuICAgIH1cbiAgICBhc3luYyBfbGliUmVxdWVzdCh1cmwsIG9wdHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgZ290KHVybCwgb3B0cykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1ZXN0TGliRXJyb3IoZXJyLm1lc3NhZ2UgfHwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfbGliUGVyZm9ybWFuY2VOb3coKSB7XG4gICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=